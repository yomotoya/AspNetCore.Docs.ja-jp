---
title: 目的の階層と ASP.NET Core でのマルチ テナント
author: rick-anderson
description: ASP.NET Core データ保護 Api に関連する、目的の文字列の階層とマルチ テナント機能について説明します。
ms.author: riande
ms.date: 10/14/2016
uid: security/data-protection/consumer-apis/purpose-strings-multitenancy
ms.openlocfilehash: 1133d40e7b325d58b3f70e7387494dae36ff8ac9
ms.sourcegitcommit: fd461c60b5e36c7019f81da0138cc859d0fddaa2
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 08/10/2018
ms.locfileid: "41830227"
---
# <a name="purpose-hierarchy-and-multi-tenancy-in-aspnet-core"></a><span data-ttu-id="a5e56-103">目的の階層と ASP.NET Core でのマルチ テナント</span><span class="sxs-lookup"><span data-stu-id="a5e56-103">Purpose hierarchy and multi-tenancy in ASP.NET Core</span></span>

<span data-ttu-id="a5e56-104">以降、`IDataProtector`は暗黙的にも、`IDataProtectionProvider`目的を連結することができます。</span><span class="sxs-lookup"><span data-stu-id="a5e56-104">Since an `IDataProtector` is also implicitly an `IDataProtectionProvider`, purposes can be chained together.</span></span> <span data-ttu-id="a5e56-105">この意味で`provider.CreateProtector([ "purpose1", "purpose2" ])`と等価`provider.CreateProtector("purpose1").CreateProtector("purpose2")`します。</span><span class="sxs-lookup"><span data-stu-id="a5e56-105">In this sense, `provider.CreateProtector([ "purpose1", "purpose2" ])` is equivalent to `provider.CreateProtector("purpose1").CreateProtector("purpose2")`.</span></span>

<span data-ttu-id="a5e56-106">これにより、データ保護システムを通じていくつか興味深い階層リレーションシップ。</span><span class="sxs-lookup"><span data-stu-id="a5e56-106">This allows for some interesting hierarchical relationships through the data protection system.</span></span> <span data-ttu-id="a5e56-107">前の例で[Contoso.Messaging.SecureMessage](xref:security/data-protection/consumer-apis/purpose-strings#data-protection-contoso-purpose)、SecureMessage コンポーネントを呼び出すことができます`provider.CreateProtector("Contoso.Messaging.SecureMessage")`1 回前払いプライベートに結果をキャッシュおよび`_myProvider`フィールド。</span><span class="sxs-lookup"><span data-stu-id="a5e56-107">In the earlier example of [Contoso.Messaging.SecureMessage](xref:security/data-protection/consumer-apis/purpose-strings#data-protection-contoso-purpose), the SecureMessage component can call `provider.CreateProtector("Contoso.Messaging.SecureMessage")` once up-front and cache the result into a private `_myProvider` field.</span></span> <span data-ttu-id="a5e56-108">今後の保護機能への呼び出しを使用して作成できます`_myProvider.CreateProtector("User: username")`、されこれらの保護機能は、個々 のメッセージを保護するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="a5e56-108">Future protectors can then be created via calls to `_myProvider.CreateProtector("User: username")`, and these protectors would be used for securing the individual messages.</span></span>

<span data-ttu-id="a5e56-109">これを反転もできます。</span><span class="sxs-lookup"><span data-stu-id="a5e56-109">This can also be flipped.</span></span> <span data-ttu-id="a5e56-110">どのホストに独自の認証と状態管理システムで構成できます (妥当なは、CMS よう) 複数のテナントとテナントごとの 1 つの論理アプリケーションを検討してください。</span><span class="sxs-lookup"><span data-stu-id="a5e56-110">Consider a single logical application which hosts multiple tenants (a CMS seems reasonable), and each tenant can be configured with its own authentication and state management system.</span></span> <span data-ttu-id="a5e56-111">包括的なアプリケーションが 1 つのマスター プロバイダーと呼び出す`provider.CreateProtector("Tenant 1")`と`provider.CreateProtector("Tenant 2")`各テナントに独自の分離スライスのデータ保護システムを提供します。</span><span class="sxs-lookup"><span data-stu-id="a5e56-111">The umbrella application has a single master provider, and it calls `provider.CreateProtector("Tenant 1")` and `provider.CreateProtector("Tenant 2")` to give each tenant its own isolated slice of the data protection system.</span></span> <span data-ttu-id="a5e56-112">テナントが独自のニーズに基づいて個々 の保護機能が独自派生させることしますが、どの程度難しいしようとすると関係なくことはできませんを作成するプロテクターが競合する、他のテナントで、システムで。</span><span class="sxs-lookup"><span data-stu-id="a5e56-112">The tenants could then derive their own individual protectors based on their own needs, but no matter how hard they try they cannot create protectors which collide with any other tenant in the system.</span></span> <span data-ttu-id="a5e56-113">視覚的に、これは次のようです。</span><span class="sxs-lookup"><span data-stu-id="a5e56-113">Graphically, this is represented as below.</span></span>

![マルチ テナント機能の目的](purpose-strings-multitenancy/_static/purposes-multi-tenancy.png)

>[!WARNING]
> <span data-ttu-id="a5e56-115">包括的なアプリケーション制御を個々 のテナント Api で利用およびテナントが、サーバー上の任意のコードを実行できないことを前提です。</span><span class="sxs-lookup"><span data-stu-id="a5e56-115">This assumes the umbrella application controls which APIs are available to individual tenants and that tenants cannot execute arbitrary code on the server.</span></span> <span data-ttu-id="a5e56-116">かどうか、テナントが任意のコードを実行できる、分離の保証を中断するプライベート リフレクションを実行する可能性がありますまたはマスター_キー生成情報を直接読み取るし、どのようなサブキーの派生する可能性がありますがだけが必要です。</span><span class="sxs-lookup"><span data-stu-id="a5e56-116">If a tenant can execute arbitrary code, they could perform private reflection to break the isolation guarantees, or they could just read the master keying material directly and derive whatever subkeys they desire.</span></span>

<span data-ttu-id="a5e56-117">データ保護システムは、実際には既定のボックスの構成でのマルチ テナント機能の一種を使用します。</span><span class="sxs-lookup"><span data-stu-id="a5e56-117">The data protection system actually uses a sort of multi-tenancy in its default out-of-the-box configuration.</span></span> <span data-ttu-id="a5e56-118">既定では、マスター_キー生成情報は、ワーカー プロセス アカウントのユーザー プロファイル フォルダー (または、IIS アプリケーション プール id のレジストリ) に格納されます。</span><span class="sxs-lookup"><span data-stu-id="a5e56-118">By default master keying material is stored in the worker process account's user profile folder (or the registry, for IIS application pool identities).</span></span> <span data-ttu-id="a5e56-119">実際には、単一のアカウントを使用して、複数のアプリケーションを実行する非常に一般的ないて、これらすべてのアプリケーションがマスター_キー生成情報を共有しまうためです。</span><span class="sxs-lookup"><span data-stu-id="a5e56-119">But it's actually fairly common to use a single account to run multiple applications, and thus all these applications would end up sharing the master keying material.</span></span> <span data-ttu-id="a5e56-120">これを解決するには、データ保護システムは自動的に、全体的な目的のチェーンの最初の要素として、アプリケーションあたり一意の識別子を挿入します。</span><span class="sxs-lookup"><span data-stu-id="a5e56-120">To solve this, the data protection system automatically inserts a unique-per-application identifier as the first element in the overall purpose chain.</span></span> <span data-ttu-id="a5e56-121">この暗黙的な目的では[個々 のアプリケーションの分離](xref:security/data-protection/configuration/overview#per-application-isolation)から、システム、および保護機能の作成プロセス内で一意のテナントは、上の図と同じ外観と各アプリケーションを効果的に扱うことにより別です。</span><span class="sxs-lookup"><span data-stu-id="a5e56-121">This implicit purpose serves to [isolate individual applications](xref:security/data-protection/configuration/overview#per-application-isolation) from one another by effectively treating each application as a unique tenant within the system, and the protector creation process looks identical to the image above.</span></span>
