---
title: ASP.NET Core でのコンテキスト ヘッダー
author: rick-anderson
description: コンテキスト ヘッダーを ASP.NET Core データ保護の実装の詳細について説明します。
ms.author: riande
ms.date: 10/14/2016
uid: security/data-protection/implementation/context-headers
ms.openlocfilehash: 2b8fd594672bf623d38bfae90d05a984f92ce6a3
ms.sourcegitcommit: dd9c73db7853d87b566eef136d2162f648a43b85
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 05/06/2019
ms.locfileid: "65087566"
---
# <a name="context-headers-in-aspnet-core"></a>ASP.NET Core でのコンテキスト ヘッダー

<a name="data-protection-implementation-context-headers"></a>

## <a name="background-and-theory"></a>背景と理論的には

データ保護システムでは、「キー」は、認証された暗号化サービスを提供できるオブジェクトを意味します。 各キーは一意の id (GUID) によって識別され、それが伴うことアルゴリズム情報や entropic マテリアル。 各キーが一意のエントロピを実行するが、システムを適用することはできず、キー リング内の既存のキーのアルゴリズム情報を変更してキー リングを手動で変更が開発者のために考慮する必要もありますが目的です。 このような場合に指定された、セキュリティ要件を実現するために、データ保護システムがの概念を持つ[暗号化方式の指定](https://www.microsoft.com/en-us/research/publication/cryptographic-agility-and-its-relation-to-circular-encryption/)、entropic 1 つの値を使用して複数の暗号化アルゴリズムの間で安全にできます。

暗号化方式の指定をサポートするほとんどのシステムでは、ペイロード内でアルゴリズムに関するいくつかの識別情報を含めることによって行います。 アルゴリズムの OID は、通常、これに適した候補です。 しかし、私たちが直面する問題の 1 つでは、同じアルゴリズムを指定する複数の方法があることです。"AES"(CNG) と、マネージ Aes、AesManaged、AesCryptoServiceProvider、AesCng、および (指定した特定のパラメーター) RijndaelManaged クラスは、同じすべて実際には、適切な OID にこれらすべてのマッピングを維持する必要があります。 開発者は、カスタム アルゴリズム (または別の実装の AES!) を提供する場合は、その OID お知らせする必要があります。 この余分な登録ステップでシステムの構成は特に厄介です。

誤った方向から問題に取り組みされたことを決めましたステップ バック。 OID は、アルゴリズムを示しますが、実際にこれについては注目しません。 場合は、2 つの異なるアルゴリズムの 1 つの entropic 値を安全に使用する必要があります、アルゴリズムが実際には何を把握する必要はありません。 どのような非常に心配、動作方法です。 任意の適切な対称ブロック暗号アルゴリズムも強力な擬似順列 (PRP): (キー、モード、IV、プレーン テキストの組み合わせ) の入力を修正し、暗号化テキストの出力は確率を過負荷に異なる名前に、その他の対称ブロック暗号アルゴリズムは、同じ入力を指定します。 同様に、任意の適切なキー付きハッシュ関数は厳密な擬似乱数関数 (PRF) でも、指定した固定の入力セットの出力は圧倒的に他のすべてのキー付きハッシュ関数とは異なります。

コンテキスト ヘッダーを構築する PRPs と PRFs の強力なは、この概念を使用します。 このコンテキスト ヘッダーが本質的には、アルゴリズムで使用して、特定の操作を安定した拇印として機能し、データ保護システムで必要な暗号化方式の指定を提供します。 このヘッダーが再現可能およびの一部として後で使用されて、[サブキーの派生プロセス](xref:security/data-protection/implementation/subkeyderivation#data-protection-implementation-subkey-derivation)します。 基になるアルゴリズムの動作モードに応じてコンテキスト ヘッダーを構築する 2 つのさまざまな方法はあります。

## <a name="cbc-mode-encryption--hmac-authentication"></a>CBC モードの暗号化 + HMAC 認証

<a name="data-protection-implementation-context-headers-cbc-components"></a>

コンテキスト ヘッダーは、次のコンポーネントで構成されます。

* [16 ビット]値 00 時 00 分、マーカーである「CBC 暗号化 + HMAC 認証」を意味します。

* [32 ビット]対称ブロック暗号アルゴリズムのキーの長さ (単位: バイト、ビッグ エンディアン)。

* [32 ビット]対称ブロック暗号アルゴリズムのブロック サイズ (単位: バイト、ビッグ エンディアン)。

* [32 ビット]HMAC アルゴリズムのキーの長さ (単位: バイト、ビッグ エンディアン)。 (現在、キー サイズ常に一致ダイジェストのサイズ。)

* [32 ビット]HMAC アルゴリズムのダイジェスト サイズ (単位: バイト、ビッグ エンディアン)。

* EncCBC (K_E、IV、"")、これは、指定した空の文字列入力対称ブロック暗号アルゴリズムの出力および IV が、すべてゼロのベクトルが。 K_E の構築を以下に示します。

* MAC (K_H、"")、指定した空の文字列入力 HMAC アルゴリズムの出力であります。 K_H の構築を以下に示します。

理想的には、K_E と K_H すべてゼロのベクトルを渡すことができます。 ただし、基になるアルゴリズムが、すべてゼロのベクターのような単純型または反復可能なパターンを使用して適応 (特に DES および 3 des) の操作を実行する前に脆弱なキーの存在をチェックする状況を回避します。

代わりに、NIST SP800 108 の KDF カウンター モードの使用 (を参照してください[108-NIST SP800](http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-108.pdf)、Sec. 5.1) の長さ 0 のキー、ラベルとコンテキスト、および基になる PRF として HMACSHA512。 派生 |K_E |+ |K_H |出力のバイトし、結果に分解 K_E と K_H 自体。 数学的に、これは、ように表されます。

( K_E || K_H ) = SP800_108_CTR(prf = HMACSHA512, key = "", label = "", context = "")

### <a name="example-aes-192-cbc--hmacsha256"></a>例:AES-192-CBC + HMACSHA256

例として、対称ブロック暗号アルゴリズムは、AES-CBC 192 検証アルゴリズムが HMACSHA256 場合を検討してください。 システムでは、次の手順を使用して、コンテキスト ヘッダーを生成します。

まず、(K_E | |K_H) = SP800_108_CTR (prf = HMACSHA512、キー =""、ラベル =""、コンテキスト ="")、|K_E |= 192 ビット、|K_H |指定したアルゴリズムごとの 256 ビットを = です。 これにより、K_E 5BB6 =.21DD と K_H A04A =.次の例で 00A9:

```
5B B6 C9 83 13 78 22 1D 8E 10 73 CA CF 65 8E B0
61 62 42 71 CB 83 21 DD A0 4A 05 00 5B AB C0 A2
49 6F A5 61 E3 E2 49 87 AA 63 55 CD 74 0A DA C4
B7 92 3D BF 59 90 00 A9
```

Enc_CBC を次に、コンピューティング (K_E、IV、"") = 0 CBC 192 AES IV を指定 * と K_E 上とします。

結果: F474B1872B3B53E4721DE19C0841DB6F を =

次に、MAC の計算 (K_H、"") の HMACSHA256 K_H 上記として指定されています。

結果: D4791184B996092EE1202F36E8608FA8FBD98ABDFF5402F264B1D7211536220C を =

これには、次の完全なコンテキスト ヘッダーが生成されます。

```
00 00 00 00 00 18 00 00 00 10 00 00 00 20 00 00
00 20 F4 74 B1 87 2B 3B 53 E4 72 1D E1 9C 08 41
DB 6F D4 79 11 84 B9 96 09 2E E1 20 2F 36 E8 60
8F A8 FB D9 8A BD FF 54 02 F2 64 B1 D7 21 15 36
22 0C
```

このコンテキスト ヘッダーには、認証された暗号化アルゴリズムのペア (AES-CBC 192 暗号化 + HMACSHA256 検証) の拇印です。 説明に従って、コンポーネント[上](xref:security/data-protection/implementation/context-headers#data-protection-implementation-context-headers-cbc-components)は。

* マーカー (00 00)

* ブロック暗号キー長 (00 00 00 18)

* ブロック暗号ブロック サイズ (00 00 00 10)

* HMAC キーの長さ (00 00 00 20)

* HMAC ダイジェストのサイズ (00 00 00 20)

* PRP の出力 (F4 74 - DB 6F) ブロック暗号と

* HMAC PRF 出力 (D4 79 - 終了)。

> [!NOTE]
> CBC モードの暗号化 + HMAC 認証コンテキスト ヘッダーが Windows CNG または SymmetricAlgorithm と KeyedHashAlgorithm のマネージ型に、アルゴリズムの実装を提供するかどうかに関係なく同じように構築されます。 これにより、アルゴリズムの実装は Os によって異なる場合でも確実に同じコンテキスト ヘッダーを生成するためにさまざまなオペレーティング システムで実行されているアプリケーション。 (実際には、KeyedHashAlgorithm が、適切な HMAC がありません。 できます任意のキー付きハッシュ アルゴリズムの種類。)

### <a name="example-3des-192-cbc--hmacsha1"></a>例:3 DES-192-CBC + HMACSHA1

まず、(K_E | |K_H) = SP800_108_CTR (prf = HMACSHA512、キー =""、ラベル =""、コンテキスト ="")、|K_E |= 192 ビット、|K_H |指定したアルゴリズムごとの 160 ビットを = です。 これにより、K_E A219 =.E2BB と K_H DC4A =.次の例で B464:

```
A2 19 60 2F 83 A9 13 EA B0 61 3A 39 B8 A6 7E 22
61 D9 F8 6C 10 51 E2 BB DC 4A 00 D7 03 A2 48 3E
D1 F7 5A 34 EB 28 3E D7 D4 67 B4 64
```

Enc_CBC を次に、コンピューティング (K_E、IV、"") = 0 CBC 192 3 des IV を指定 * と K_E 上とします。

結果: ABB100F81E53E10E を =

次に、MAC の計算 (K_H、"") の HMACSHA1 K_H 上記として指定されています。

結果: 76EB189B35CF03461DDF877CD9F4B1B4D63A7555 を =

これにより、認証の拇印である完全なコンテキスト ヘッダーが生成されます。 暗号化アルゴリズムのペア (3 des-192-CBC 暗号化 + HMACSHA1 検証)、次に示します。

```
00 00 00 00 00 18 00 00 00 08 00 00 00 14 00 00
00 14 AB B1 00 F8 1E 53 E1 0E 76 EB 18 9B 35 CF
03 46 1D DF 87 7C D9 F4 B1 B4 D6 3A 75 55
```

コンポーネントが次のように分割します。

* マーカー (00 00)

* ブロック暗号キー長 (00 00 00 18)

* ブロック暗号ブロック サイズ (00 00 00 08)

* HMAC キーの長さ (00 00 00 14)

* HMAC ダイジェストのサイズ (00 00 00 14)

* PRP の出力 (AB B1 - E1 0 e) ブロック暗号と

* HMAC PRF 出力 (76 EB - 終了)。

## <a name="galoiscounter-mode-encryption--authentication"></a>Galois/カウンター モード暗号化 + 認証

コンテキスト ヘッダーは、次のコンポーネントで構成されます。

* [16 ビット]値 00 はマーカー 01、「GCM 暗号化 + 認証」を意味します。

* [32 ビット]対称ブロック暗号アルゴリズムのキーの長さ (単位: バイト、ビッグ エンディアン)。

* [32 ビット]Nonce サイズ (バイト単位、ビッグ エンディアン) 認証された暗号化の操作中に使用します。 (Nonce のサイズに固定このシステムは、の 96 ビットを = です)。

* [32 ビット]対称ブロック暗号アルゴリズムのブロック サイズ (単位: バイト、ビッグ エンディアン)。 (ブロック サイズに固定これの GCM、128 ビットを = です)。

* [32 ビット]認証タグ サイズ (バイト、ビッグ エンディアン) 認証された暗号化関数によって生成されます。 (、システムの場合は、タグのサイズに固定してこれが 128 ビットを = です)。

* [128 ビット]Enc_GCM のタグ (K_E、nonce、"")、これは、指定した空の文字列入力対称ブロック暗号アルゴリズムの出力および nonce が 96 ビットすべてゼロのベクトルが。

K_E は CBC 暗号化 + 認証シナリオの HMAC のように同じメカニズムを使用して派生します。 ただし、このアプローチで K_H がないため本質的が |K_H |= 0 の場合、アルゴリズムを解除し、フォームの下。

K_E = SP800_108_CTR(prf = HMACSHA512, key = "", label = "", context = "")

### <a name="example-aes-256-gcm"></a>例:AES-256-GCM

K_E おきます SP800_108_CTR = (prf = HMACSHA512、キー =""、ラベル =""、コンテキスト ="")、|K_E |= 256 ビットです。

K_E: 22BC6F1B171C08C4AE2F27444AF8FC8B3087A90006CAEA91FDCFB47C1B8733B8 を =

Enc_GCM の認証タグを次に、コンピューティング (K_E、nonce、"") GCM 256 AES nonce を指定するのには、上記 096 と K_E を = です。

結果: E7DCCE66DF855A323A6BB7BD7A59BE45 を =

これには、次の完全なコンテキスト ヘッダーが生成されます。

```
00 01 00 00 00 20 00 00 00 0C 00 00 00 10 00 00
00 10 E7 DC CE 66 DF 85 5A 32 3A 6B B7 BD 7A 59
BE 45
```

コンポーネントが次のように分割します。

* マーカー (00 01)

* ブロック暗号キー長 (00 00 00 20)

* nonce のサイズ (00 00 00 0 C)

* ブロック暗号ブロック サイズ (00 00 00 10)

* 認証タグのサイズ (00 00 00 10) と

* ブロック暗号を実行してから認証タグ (E7 DC の終了)。
