---
uid: web-forms/overview/data-access/caching-data/caching-data-at-application-startup-cs
title: アプリケーションの起動 (c#) にデータをキャッシュ |Microsoft Docs
author: rick-anderson
description: 一部のデータが頻繁に使用する Web アプリケーションで、一部のデータの使用は頻度の低い。 この ASP.NET アプリケーション b のパフォーマンスを改善できる.
ms.author: aspnetcontent
manager: wpickett
ms.date: 05/30/2007
ms.topic: article
ms.assetid: 22ca8efa-7cd1-45a7-b9ce-ce6eb3b3ff95
ms.technology: dotnet-webforms
msc.legacyurl: /web-forms/overview/data-access/caching-data/caching-data-at-application-startup-cs
msc.type: authoredcontent
ms.openlocfilehash: 01f80353e3f871606d022b01c98b0d36d15d2379
ms.sourcegitcommit: 953ff9ea4369f154d6fd0239599279ddd3280009
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 07/03/2018
ms.locfileid: "37370479"
---
<a name="caching-data-at-application-startup-c"></a><span data-ttu-id="31fcb-104">アプリケーションの起動時 (c#) にデータをキャッシュします。</span><span class="sxs-lookup"><span data-stu-id="31fcb-104">Caching Data at Application Startup (C#)</span></span>
====================
<span data-ttu-id="31fcb-105">によって[Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="31fcb-105">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

[<span data-ttu-id="31fcb-106">PDF のダウンロード</span><span class="sxs-lookup"><span data-stu-id="31fcb-106">Download PDF</span></span>](caching-data-at-application-startup-cs/_static/datatutorial60cs1.pdf)

> <span data-ttu-id="31fcb-107">一部のデータが頻繁に使用する Web アプリケーションで、一部のデータの使用は頻度の低い。</span><span class="sxs-lookup"><span data-stu-id="31fcb-107">In any Web application some data will be frequently used and some data will be infrequently used.</span></span> <span data-ttu-id="31fcb-108">頻繁に使用されるデータと呼ばれる手法を事前に読み込むことによって、ASP.NET アプリケーションのパフォーマンスを改善できます。</span><span class="sxs-lookup"><span data-stu-id="31fcb-108">We can improve the performance of our ASP.NET application by loading in advance the frequently-used data, a technique known as.</span></span> <span data-ttu-id="31fcb-109">このチュートリアルでは、事前対応型の読み込みは、アプリケーションの起動時にキャッシュにデータを読み込むを 1 つの方法を示します。</span><span class="sxs-lookup"><span data-stu-id="31fcb-109">This tutorial demonstrates one approach to proactive loading, which is to load data into the cache at application startup.</span></span>


## <a name="introduction"></a><span data-ttu-id="31fcb-110">はじめに</span><span class="sxs-lookup"><span data-stu-id="31fcb-110">Introduction</span></span>

<span data-ttu-id="31fcb-111">2 つの前のチュートリアル、プレゼンテーション層と層のキャッシュのデータ キャッシュについて説明しました。</span><span class="sxs-lookup"><span data-stu-id="31fcb-111">The two previous tutorials looked at caching data in the Presentation and Caching Layers.</span></span> <span data-ttu-id="31fcb-112">[ObjectDataSource でデータをキャッシュ](caching-data-with-the-objectdatasource-cs.md)ObjectDataSource s がプレゼンテーション層でデータをキャッシュする機能のキャッシュを使用しました。</span><span class="sxs-lookup"><span data-stu-id="31fcb-112">In [Caching Data with the ObjectDataSource](caching-data-with-the-objectdatasource-cs.md), we looked at using the ObjectDataSource s caching features to cache data in the Presentation Layer.</span></span> <span data-ttu-id="31fcb-113">[アーキテクチャでデータをキャッシュ](caching-data-in-the-architecture-cs.md)新しい、個別のキャッシュ レイヤーでのキャッシュを確認します。</span><span class="sxs-lookup"><span data-stu-id="31fcb-113">[Caching Data in the Architecture](caching-data-in-the-architecture-cs.md) examined caching in a new, separate Caching Layer.</span></span> <span data-ttu-id="31fcb-114">両方のために使用するこれらのチュートリアル*事後対応型の読み込み*でデータ キャッシュを操作します。</span><span class="sxs-lookup"><span data-stu-id="31fcb-114">Both of these tutorials used *reactive loading* in working with the data cache.</span></span> <span data-ttu-id="31fcb-115">事後対応型の読み込み、データが要求されるたびに、最初にチェック場合、キャッシュで s。</span><span class="sxs-lookup"><span data-stu-id="31fcb-115">With reactive loading, each time the data is requested, the system first checks if it s in the cache.</span></span> <span data-ttu-id="31fcb-116">されていない場合、キャッシュに格納し、データベースなど、元のソースからデータを取得します。</span><span class="sxs-lookup"><span data-stu-id="31fcb-116">If not, it grabs the data from the originating source, such as the database, and then stores it in the cache.</span></span> <span data-ttu-id="31fcb-117">事後対応型の読み込みの主な利点は、簡単に実装します。</span><span class="sxs-lookup"><span data-stu-id="31fcb-117">The main advantage to reactive loading is its ease of implementation.</span></span> <span data-ttu-id="31fcb-118">不均一なパフォーマンスは、要求間での短所の 1 つです。</span><span class="sxs-lookup"><span data-stu-id="31fcb-118">One of its disadvantages is its uneven performance across requests.</span></span> <span data-ttu-id="31fcb-119">上記のチュートリアルからキャッシュ レイヤーを使用して、製品情報を表示するページを想像してください。</span><span class="sxs-lookup"><span data-stu-id="31fcb-119">Imagine a page that uses the Caching Layer from the preceding tutorial to display product information.</span></span> <span data-ttu-id="31fcb-120">このページは、初めてアクセスしたか、メモリの制約または指定した有効期限に到達したことにより、キャッシュされたデータが削除された後に初めてアクセス、データをデータベースから取得する必要があります。</span><span class="sxs-lookup"><span data-stu-id="31fcb-120">When this page is visited for the first time, or visited for the first time after the cached data has been evicted due to memory constraints or the specified expiry having been reached, the data must be retrieved from the database.</span></span> <span data-ttu-id="31fcb-121">そのため、キャッシュによってこれらのユーザー要求を処理できるユーザーの要求よりも長くかかります。</span><span class="sxs-lookup"><span data-stu-id="31fcb-121">Therefore, these users requests will take longer than users requests that can be served by the cache.</span></span>

<span data-ttu-id="31fcb-122">*プロアクティブな読み込み*のために必要なの前にキャッシュされたデータを読み込むことで要求間で別のキャッシュ管理戦略を滑らかになり、パフォーマンスを提供します。</span><span class="sxs-lookup"><span data-stu-id="31fcb-122">*Proactive loading* provides an alternative cache management strategy that smoothes out the performance across requests by loading the cached data before it s needed.</span></span> <span data-ttu-id="31fcb-123">通常、事前対応型の読み込みは、定期的にチェック、または基になるデータへの更新されたときに通知するいくつかのプロセスを使用します。</span><span class="sxs-lookup"><span data-stu-id="31fcb-123">Typically, proactive loading uses some process that either periodically checks or is notified when there has been an update to the underlying data.</span></span> <span data-ttu-id="31fcb-124">このプロセスは、最新に保つためにキャッシュを更新します。</span><span class="sxs-lookup"><span data-stu-id="31fcb-124">This process then updates the cache to keep it fresh.</span></span> <span data-ttu-id="31fcb-125">事前対応型の読み込みが遅いデータベース接続、Web サービス、またはその他の動作の遅い特にデータ ソースからデータを基になる場合に特に便利です。</span><span class="sxs-lookup"><span data-stu-id="31fcb-125">Proactive loading is especially useful if the underlying data comes from a slow database connection, a Web service, or some other particularly sluggish data source.</span></span> <span data-ttu-id="31fcb-126">事前対応型の読み込みには、この方法は、作成、管理、および展開プロセスの変更を確認し、キャッシュを更新する必要があるを実装することが困難。</span><span class="sxs-lookup"><span data-stu-id="31fcb-126">But this approach to proactive loading is more difficult to implement, as it requires creating, managing, and deploying a process to check for changes and update the cache.</span></span>

<span data-ttu-id="31fcb-127">事前対応型の読み込み、およびいきますでこのチュートリアルでは、型の別のフレーバーでは、アプリケーションの起動時にキャッシュにデータを読み込んでいます。</span><span class="sxs-lookup"><span data-stu-id="31fcb-127">Another flavor of proactive loading, and the type we'll be exploring in this tutorial, is loading data into the cache at application startup.</span></span> <span data-ttu-id="31fcb-128">この方法は、データベース ルックアップ テーブル内のレコードなどの静的データをキャッシュに特に便利です。</span><span class="sxs-lookup"><span data-stu-id="31fcb-128">This approach is especially useful for caching static data, such as the records in database lookup tables.</span></span>

> [!NOTE]
> <span data-ttu-id="31fcb-129">主体的および対応の読み込みと長所と短所、および実装の推奨事項のリスト間の相違点の詳細についてを参照してください、 [、キャッシュの内容を管理する](https://msdn.microsoft.com/library/ms978503.aspx)のセクション、 [.NET Framework アプリケーションのアーキテクチャ ガイドのキャッシュ](https://msdn.microsoft.com/library/ms978498.aspx)します。</span><span class="sxs-lookup"><span data-stu-id="31fcb-129">For a more in-depth look at the differences between proactive and reactive loading, as well as lists of pros, cons, and implementation recommendations, refer to the [Managing the Contents of a Cache](https://msdn.microsoft.com/library/ms978503.aspx) section of the [Caching Architecture Guide for .NET Framework Applications](https://msdn.microsoft.com/library/ms978498.aspx).</span></span>


## <a name="step-1-determining-what-data-to-cache-at-application-startup"></a><span data-ttu-id="31fcb-130">手順 1: アプリケーションの起動時にキャッシュするデータを決定します。</span><span class="sxs-lookup"><span data-stu-id="31fcb-130">Step 1: Determining What Data to Cache at Application Startup</span></span>

<span data-ttu-id="31fcb-131">キャッシュの例は、事後対応型の読み込みを使用して生成するデータを定期的に変更し、長い exorbitantly 受け取らないでうまく前の 2 つのチュートリアルの作業で調べる。</span><span class="sxs-lookup"><span data-stu-id="31fcb-131">The caching examples using reactive loading that we examined in the previous two tutorials work well with data that may periodically change and does not take exorbitantly long to generate.</span></span> <span data-ttu-id="31fcb-132">事後対応型の読み込みで使用される有効期限は余分な場合は、キャッシュされたデータが変更ことはありません。</span><span class="sxs-lookup"><span data-stu-id="31fcb-132">But if the cached data never changes, the expiry used by reactive loading is superfluous.</span></span> <span data-ttu-id="31fcb-133">同様に、キャッシュ データが生成する極端に時間を受け取る場合は、それらのユーザー要求が検索に時間がかかる待機中、基になるデータに耐えられるキャッシュを空になりますが取得されます。</span><span class="sxs-lookup"><span data-stu-id="31fcb-133">Likewise, if the data being cached takes an exceedingly long time to generate, then those users whose requests find the cache empty will have to endure a lengthy wait while the underlying data is retrieved.</span></span> <span data-ttu-id="31fcb-134">静的なデータとアプリケーションの起動時に生成する非常に長い時間がかかるデータのキャッシュを検討してください。</span><span class="sxs-lookup"><span data-stu-id="31fcb-134">Consider caching static data and data that takes an exceptionally long time to generate at application startup.</span></span>

<span data-ttu-id="31fcb-135">データベースには、多くの動的がありますが、値を頻繁に変更する、ほとんどが、かなりの静的データもあります。</span><span class="sxs-lookup"><span data-stu-id="31fcb-135">While databases have many dynamic, frequently-changing values, most also have a fair amount of static data.</span></span> <span data-ttu-id="31fcb-136">たとえば、ほぼすべてのデータ モデルでは、選択肢の固定セットから特定の値を含む 1 つまたは複数の列があります。</span><span class="sxs-lookup"><span data-stu-id="31fcb-136">For example, virtually all data models have one or more columns that contain a particular value from a fixed set of choices.</span></span> <span data-ttu-id="31fcb-137">A`Patients`データベース テーブルがあります、`PrimaryLanguage`列を持つ一連の値は、英語、スペイン語、フランス語、ロシア語、日本語、およびの可能性があります。</span><span class="sxs-lookup"><span data-stu-id="31fcb-137">A `Patients` database table might have a `PrimaryLanguage` column, whose set of values could be English, Spanish, French, Russian, Japanese, and so on.</span></span> <span data-ttu-id="31fcb-138">多くの場合、このような列を使用して実装*ルックアップ テーブル*します。</span><span class="sxs-lookup"><span data-stu-id="31fcb-138">Oftentimes, these types of columns are implemented using *lookup tables*.</span></span> <span data-ttu-id="31fcb-139">英語またはフランス語の文字列を格納するのではなく、`Patients`テーブル、2 番目のテーブルが作成を一般的には、それぞれの値のレコードを持つ 2 つの列の一意の識別子と文字列による説明 - を持ちます。</span><span class="sxs-lookup"><span data-stu-id="31fcb-139">Rather than storing the string English or French in the `Patients` table, a second table is created that has, commonly, two columns - a unique identifier and a string description - with a record for each possible value.</span></span> <span data-ttu-id="31fcb-140">`PrimaryLanguage`内の列、`Patients`テーブルが参照テーブルに対応する一意識別子を格納します。</span><span class="sxs-lookup"><span data-stu-id="31fcb-140">The `PrimaryLanguage` column in the `Patients` table stores the corresponding unique identifier in the lookup table.</span></span> <span data-ttu-id="31fcb-141">図 1 の場合は、患者の John Doe の第一言語は英語、Ed Johnson s はロシア語です。</span><span class="sxs-lookup"><span data-stu-id="31fcb-141">In Figure 1, patient John Doe s primary language is English, while Ed Johnson s is Russian.</span></span>


![言語の表は、Patients テーブルで使用される参照テーブルです。](caching-data-at-application-startup-cs/_static/image1.png)

<span data-ttu-id="31fcb-143">**図 1**:`Languages`テーブルで使用される参照テーブル、`Patients`テーブル</span><span class="sxs-lookup"><span data-stu-id="31fcb-143">**Figure 1**: The `Languages` Table is a Lookup Table Used by the `Patients` Table</span></span>


<span data-ttu-id="31fcb-144">内のレコードによって設定されます、使用可能な言語のドロップダウン リストには編集または作成の新しい患者のユーザー インターフェイスが含まれます、`Languages`テーブル。</span><span class="sxs-lookup"><span data-stu-id="31fcb-144">The user interface for editing or creating a new patient would include a drop-down list of allowable languages populated by the records in the `Languages` table.</span></span> <span data-ttu-id="31fcb-145">このインターフェイスは、毎回キャッシュを使用しないシステムがアクセスしたクエリを実行する必要があります、`Languages`テーブル。</span><span class="sxs-lookup"><span data-stu-id="31fcb-145">Without caching, each time this interface is visited the system must query the `Languages` table.</span></span> <span data-ttu-id="31fcb-146">これは無駄な不要な参照テーブルの値の変更頻度の非常に低いため場合、これまでです。</span><span class="sxs-lookup"><span data-stu-id="31fcb-146">This is wasteful and unnecessary since lookup table values change very infrequently, if ever.</span></span>

<span data-ttu-id="31fcb-147">キャッシュでした、`Languages`前のチュートリアルで同じ事後対応型の読み込みの手法を使用してデータ。</span><span class="sxs-lookup"><span data-stu-id="31fcb-147">We could cache the `Languages` data using the same reactive loading techniques examined in the previous tutorials.</span></span> <span data-ttu-id="31fcb-148">事後対応型の読み込みでは、ただし、静的な参照テーブルのデータは必要ありません時間ベースの期限を使用します。</span><span class="sxs-lookup"><span data-stu-id="31fcb-148">Reactive loading, however, uses a time-based expiry, which is not needed for static lookup table data.</span></span> <span data-ttu-id="31fcb-149">事後対応型の読み込みを使用して、キャッシュがまったくないキャッシュよりも良いでしょう中、に事前に参照テーブルのデータをアプリケーションの起動時にキャッシュに読み込む最善の方法があります。</span><span class="sxs-lookup"><span data-stu-id="31fcb-149">While caching using reactive loading would be better than no caching at all, the best approach would be to proactively load the lookup table data into the cache at application startup.</span></span>

<span data-ttu-id="31fcb-150">このチュートリアルでは、ルックアップ テーブルのデータをキャッシュおよびその他の静的情報する方法に注目します。</span><span class="sxs-lookup"><span data-stu-id="31fcb-150">In this tutorial we will look at how to cache lookup table data and other static information.</span></span>

## <a name="step-2-examining-the-different-ways-to-cache-data"></a><span data-ttu-id="31fcb-151">手順 2: データをキャッシュするさまざまな方法を確認します。</span><span class="sxs-lookup"><span data-stu-id="31fcb-151">Step 2: Examining the Different Ways to Cache Data</span></span>

<span data-ttu-id="31fcb-152">情報は、さまざまな方法を使用して ASP.NET アプリケーションでプログラムによってキャッシュされます。</span><span class="sxs-lookup"><span data-stu-id="31fcb-152">Information can be programmatically cached in an ASP.NET application using a variety of approaches.</span></span> <span data-ttu-id="31fcb-153">私たち ve 既に前のチュートリアルで、データ キャッシュを使用する方法を説明します。</span><span class="sxs-lookup"><span data-stu-id="31fcb-153">We ve already seen how to use the data cache in previous tutorials.</span></span> <span data-ttu-id="31fcb-154">または、オブジェクトできるプログラムでキャッシュを使用して*静的メンバー*または*アプリケーション状態*します。</span><span class="sxs-lookup"><span data-stu-id="31fcb-154">Alternatively, objects can be programmatically cached using *static members* or *application state*.</span></span>

<span data-ttu-id="31fcb-155">クラスを使用する場合通常クラスする必要があります最初にインスタンス化前に、そのメンバーにアクセスすることができます。</span><span class="sxs-lookup"><span data-stu-id="31fcb-155">When working with a class, typically the class must first be instantiated before its members can be accessed.</span></span> <span data-ttu-id="31fcb-156">たとえばから、ビジネス ロジック層のクラスのいずれかのメソッドを呼び出すためにする必要があります最初にインスタンスを作成、クラスの。</span><span class="sxs-lookup"><span data-stu-id="31fcb-156">For example, in order to invoke a method from one of the classes in our Business Logic Layer, we must first create an instance of the class:</span></span>


[!code-csharp[Main](caching-data-at-application-startup-cs/samples/sample1.cs)]

<span data-ttu-id="31fcb-157">呼び出すことができます前に*SomeMethod*操作または*SomeProperty*を使用して、クラスのインスタンスを作成する必要があります最初、`new`キーワード。</span><span class="sxs-lookup"><span data-stu-id="31fcb-157">Before we can invoke *SomeMethod* or work with *SomeProperty*, we must first create an instance of the class using the `new` keyword.</span></span> <span data-ttu-id="31fcb-158">*SomeMethod*と*SomeProperty*は特定のインスタンスに関連付けられます。</span><span class="sxs-lookup"><span data-stu-id="31fcb-158">*SomeMethod* and *SomeProperty* are associated with a particular instance.</span></span> <span data-ttu-id="31fcb-159">これらのメンバーの有効期間は、関連付けられているオブジェクトの有効期間に関連付けられています。</span><span class="sxs-lookup"><span data-stu-id="31fcb-159">The lifetime of these members is tied to the lifetime of their associated object.</span></span> <span data-ttu-id="31fcb-160">*静的メンバー*、一方では、変数、プロパティ、メソッド間で共有される*すべて*クラスのインスタンスと、その結果、有効期間は、クラスと同じくらいにあります。</span><span class="sxs-lookup"><span data-stu-id="31fcb-160">*Static members*, on the other hand, are variables, properties, and methods that are shared among *all* instances of the class and, consequently, have a lifetime as long as the class.</span></span> <span data-ttu-id="31fcb-161">静的メンバーがキーワードで表される`static`します。</span><span class="sxs-lookup"><span data-stu-id="31fcb-161">Static members are denoted by the keyword `static`.</span></span>

<span data-ttu-id="31fcb-162">静的メンバーだけでなくアプリケーションの状態を使用してデータをキャッシュできます。</span><span class="sxs-lookup"><span data-stu-id="31fcb-162">In addition to static members, data can be cached using application state.</span></span> <span data-ttu-id="31fcb-163">各 ASP.NET アプリケーションでは、すべてのユーザーとアプリケーションのページ間で共有される s 名前/値コレクションを保持します。</span><span class="sxs-lookup"><span data-stu-id="31fcb-163">Each ASP.NET application maintains a name/value collection that s shared across all users and pages of the application.</span></span> <span data-ttu-id="31fcb-164">使用してこのコレクションにアクセスできる、 [ `HttpContext`クラス](https://msdn.microsoft.com/library/system.web.httpcontext.aspx)s [ `Application`プロパティ](https://msdn.microsoft.com/library/system.web.httpcontext.application.aspx)、ASP.NET ページの分離コード クラスから使用して次のようにします。</span><span class="sxs-lookup"><span data-stu-id="31fcb-164">This collection can be accessed using the [`HttpContext` class](https://msdn.microsoft.com/library/system.web.httpcontext.aspx) s [`Application` property](https://msdn.microsoft.com/library/system.web.httpcontext.application.aspx), and used from an ASP.NET page s code-behind class like so:</span></span>


[!code-csharp[Main](caching-data-at-application-startup-cs/samples/sample2.cs)]

<span data-ttu-id="31fcb-165">データ キャッシュは、時間および依存関係に基づく切れ、キャッシュ項目の優先度などのメカニズムを提供するデータのキャッシュの多くの高度な API を提供します。</span><span class="sxs-lookup"><span data-stu-id="31fcb-165">The data cache provides a much richer API for caching data, providing mechanisms for time- and dependency-based expiries, cache item priorities, and so forth.</span></span> <span data-ttu-id="31fcb-166">静的メンバーとアプリケーションの状態の場合は、このような機能をページの開発者によって手動で追加する必要があります。</span><span class="sxs-lookup"><span data-stu-id="31fcb-166">With static members and application state, such features must be manually added by the page developer.</span></span> <span data-ttu-id="31fcb-167">アプリケーションの有効期間にわたってアプリケーションの起動時にデータをキャッシュする場合はただし、データ キャッシュの利点は議論の余地です。</span><span class="sxs-lookup"><span data-stu-id="31fcb-167">When caching data at application startup for the lifetime of the application, however, the data cache s advantages are moot.</span></span> <span data-ttu-id="31fcb-168">このチュートリアルでは、静的データのキャッシュのすべての 3 つの手法を使用するコードを紹介します。</span><span class="sxs-lookup"><span data-stu-id="31fcb-168">In this tutorial we'll look at code that uses all three techniques for caching static data.</span></span>

## <a name="step-3-caching-thesupplierstable-data"></a><span data-ttu-id="31fcb-169">手順 3: キャッシュ、`Suppliers`テーブル データ</span><span class="sxs-lookup"><span data-stu-id="31fcb-169">Step 3: Caching the`Suppliers`Table Data</span></span>

<span data-ttu-id="31fcb-170">データベース テーブルの日付に実装した Northwind は、従来のルックアップ テーブルを含めないでください。</span><span class="sxs-lookup"><span data-stu-id="31fcb-170">The Northwind database tables we ve implemented to date do not include any traditional lookup tables.</span></span> <span data-ttu-id="31fcb-171">4 つのデータ テーブルは、値が静的でないすべてのモデル テーブルを DAL に実装されます。</span><span class="sxs-lookup"><span data-stu-id="31fcb-171">The four DataTables implemented in our DAL all model tables whose values are non-static.</span></span> <span data-ttu-id="31fcb-172">DAL とし、新しいクラスと、BLL をメソッドに、新しい DataTable を追加する時間を費やすのではなくできるように s だけをこのチュートリアルのふりを`Suppliers`テーブル %s のデータは静的です。</span><span class="sxs-lookup"><span data-stu-id="31fcb-172">Rather than spending the time to add a new DataTable to the DAL and then a new class and methods to the BLL, for this tutorial let s just pretend that the `Suppliers` table s data is static.</span></span> <span data-ttu-id="31fcb-173">そのため、アプリケーションの起動時にこのデータをキャッシュします。</span><span class="sxs-lookup"><span data-stu-id="31fcb-173">Therefore, we could cache this data at application startup.</span></span>

<span data-ttu-id="31fcb-174">という名前の新しいクラスの作成を開始する`StaticCache.cs`で、`CL`フォルダー。</span><span class="sxs-lookup"><span data-stu-id="31fcb-174">To start, create a new class named `StaticCache.cs` in the `CL` folder.</span></span>


![CL フォルダーに StaticCache.cs クラスを作成します。](caching-data-at-application-startup-cs/_static/image2.png)

<span data-ttu-id="31fcb-176">**図 2**: 作成、`StaticCache.cs`クラス、`CL`フォルダー</span><span class="sxs-lookup"><span data-stu-id="31fcb-176">**Figure 2**: Create the `StaticCache.cs` Class in the `CL` Folder</span></span>


<span data-ttu-id="31fcb-177">このキャッシュからデータを返すメソッドと同様に、適切なキャッシュ ストアに起動時にデータを読み込むメソッドを追加する必要があります。</span><span class="sxs-lookup"><span data-stu-id="31fcb-177">We need to add a method that loads the data at startup into the appropriate cache store, as well as methods that return data from this cache.</span></span>


[!code-csharp[Main](caching-data-at-application-startup-cs/samples/sample3.cs)]

<span data-ttu-id="31fcb-178">上記の例では、静的メンバー変数、`suppliers`からの結果を保持するために、`SuppliersBLL`クラス s`GetSuppliers()`メソッドから呼び出される、`LoadStaticCache()`メソッド。</span><span class="sxs-lookup"><span data-stu-id="31fcb-178">The above code uses a static member variable, `suppliers`, to hold the results from the `SuppliersBLL` class s `GetSuppliers()` method, which is called from the `LoadStaticCache()` method.</span></span> <span data-ttu-id="31fcb-179">`LoadStaticCache()`メソッドは、まず、アプリケーションの中に呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="31fcb-179">The `LoadStaticCache()` method is meant to be called during the application s start.</span></span> <span data-ttu-id="31fcb-180">このデータはアプリケーションの起動時に読み込まれると、仕入先データを使用する必要がある任意のページを呼び出すことができます、`StaticCache`クラスの`GetSuppliers()`メソッド。</span><span class="sxs-lookup"><span data-stu-id="31fcb-180">Once this data has been loaded at application startup, any page that needs to work with supplier data can call the `StaticCache` class s `GetSuppliers()` method.</span></span> <span data-ttu-id="31fcb-181">そのため、仕入先を取得するデータベースへの呼び出しのみアプリケーションの起動時に 1 回行われます。</span><span class="sxs-lookup"><span data-stu-id="31fcb-181">Therefore, the call to the database to get the suppliers only happens once, at application start.</span></span>

<span data-ttu-id="31fcb-182">静的メンバー変数を使用して、キャッシュ ストアとしてではなく別の方法として使用できますアプリケーションの状態やデータのキャッシュ。</span><span class="sxs-lookup"><span data-stu-id="31fcb-182">Rather than using a static member variable as the cache store, we could have alternatively used application state or the data cache.</span></span> <span data-ttu-id="31fcb-183">次のコードでは、アプリケーションの状態の使用によるクラスを示します。</span><span class="sxs-lookup"><span data-stu-id="31fcb-183">The following code shows the class retooled to use application state:</span></span>


[!code-csharp[Main](caching-data-at-application-startup-cs/samples/sample4.cs)]

<span data-ttu-id="31fcb-184">`LoadStaticCache()`、仕入先の情報がアプリケーション変数に格納されている*キー*します。</span><span class="sxs-lookup"><span data-stu-id="31fcb-184">In `LoadStaticCache()`, the supplier information is stored to the application variable *key*.</span></span> <span data-ttu-id="31fcb-185">適切な型として返されます (`Northwind.SuppliersDataTable`) から`GetSuppliers()`します。</span><span class="sxs-lookup"><span data-stu-id="31fcb-185">It s returned as the appropriate type (`Northwind.SuppliersDataTable`) from `GetSuppliers()`.</span></span> <span data-ttu-id="31fcb-186">アプリケーションの状態を使用して ASP.NET ページの分離コード クラスにアクセスできる間`Application["key"]`を使用しなければならないアーキテクチャで`HttpContext.Current.Application["key"]`現在を取得するために`HttpContext`します。</span><span class="sxs-lookup"><span data-stu-id="31fcb-186">While application state can be accessed in the code-behind classes of ASP.NET pages using `Application["key"]`, in the architecture we must use `HttpContext.Current.Application["key"]` in order to get the current `HttpContext`.</span></span>

<span data-ttu-id="31fcb-187">同様に、データ キャッシュは、次のコードに示すとしてのキャッシュ ストアとして使用できます。</span><span class="sxs-lookup"><span data-stu-id="31fcb-187">Likewise, the data cache can be used as a cache store, as the following code shows:</span></span>


[!code-csharp[Main](caching-data-at-application-startup-cs/samples/sample5.cs)]

<span data-ttu-id="31fcb-188">時間ベースの期限なしでデータ キャッシュに項目を追加するには、使用、`System.Web.Caching.Cache.NoAbsoluteExpiration`と`System.Web.Caching.Cache.NoSlidingExpiration`入力パラメーターとして値。</span><span class="sxs-lookup"><span data-stu-id="31fcb-188">To add an item to the data cache with no time-based expiry, use the `System.Web.Caching.Cache.NoAbsoluteExpiration` and `System.Web.Caching.Cache.NoSlidingExpiration` values as input parameters.</span></span> <span data-ttu-id="31fcb-189">S データ キャッシュのこの特定のオーバー ロード`Insert`指定できればようにメソッドが選択されて、*優先度*のキャッシュ項目。</span><span class="sxs-lookup"><span data-stu-id="31fcb-189">This particular overload of the data cache s `Insert` method was selected so that we could specify the *priority* of the cache item.</span></span> <span data-ttu-id="31fcb-190">優先順位を使用して、使用可能なメモリが不足しているときに、キャッシュから清掃を行うには、どのような項目を決定します。</span><span class="sxs-lookup"><span data-stu-id="31fcb-190">The priority is used to determine what items to scavenge from the cache when available memory runs low.</span></span> <span data-ttu-id="31fcb-191">ここでは、優先順位を使用`NotRemovable`、清掃このキャッシュ項目が、t が勝利したことが保証されます。</span><span class="sxs-lookup"><span data-stu-id="31fcb-191">Here we use the priority `NotRemovable`, which ensures that this cache item won t be scavenged.</span></span>

> [!NOTE]
> <span data-ttu-id="31fcb-192">このチュートリアルのダウンロードの実装、`StaticCache`クラスの静的メンバー変数のアプローチを使用します。</span><span class="sxs-lookup"><span data-stu-id="31fcb-192">This tutorial s download implements the `StaticCache` class using the static member variable approach.</span></span> <span data-ttu-id="31fcb-193">アプリケーションの状態とデータのキャッシュの手法のコードは、クラス ファイル内のコメントで使用できます。</span><span class="sxs-lookup"><span data-stu-id="31fcb-193">The code for the application state and data cache techniques is available in the comments in the class file.</span></span>


## <a name="step-4-executing-code-at-application-startup"></a><span data-ttu-id="31fcb-194">手順 4: アプリケーションの起動時にコードを実行します。</span><span class="sxs-lookup"><span data-stu-id="31fcb-194">Step 4: Executing Code at Application Startup</span></span>

<span data-ttu-id="31fcb-195">という名前の特殊なファイルの作成に必要なコードを実行するには、web アプリケーションの初回起動時に`Global.asax`します。</span><span class="sxs-lookup"><span data-stu-id="31fcb-195">To execute code when a web application first starts, we need to create a special file named `Global.asax`.</span></span> <span data-ttu-id="31fcb-196">このファイルは、アプリケーションで、セッションでのイベント ハンドラーを含めることができ、要求レベルのイベントとそれがここで、アプリケーションが起動されるたびに実行されるコードを追加できます。</span><span class="sxs-lookup"><span data-stu-id="31fcb-196">This file can contain event handlers for application-, session-, and request-level events, and it is here where we can add code that will be executed whenever the application starts.</span></span>

<span data-ttu-id="31fcb-197">追加、`Global.asax`ファイルを Visual Studio のソリューション エクスプ ローラーで web サイト プロジェクト名を右クリックし、新しい項目の追加を選択して web アプリケーションのルート ディレクトリ。</span><span class="sxs-lookup"><span data-stu-id="31fcb-197">Add the `Global.asax` file to your web application s root directory by right-clicking on the website project name in Visual Studio s Solution Explorer and choosing Add New Item.</span></span> <span data-ttu-id="31fcb-198">新しい項目の追加 ダイアログ ボックスで、グローバル アプリケーション クラスの項目の種類を選択し、追加 ボタンをクリックします。</span><span class="sxs-lookup"><span data-stu-id="31fcb-198">From the Add New Item dialog box, select the Global Application Class item type and then click the Add button.</span></span>

> [!NOTE]
> <span data-ttu-id="31fcb-199">既にある場合、`Global.asax`ファイルで、プロジェクトでは、グローバル アプリケーション クラスが項目の種類は、新しい項目の追加 ダイアログ ボックスは表示されません。</span><span class="sxs-lookup"><span data-stu-id="31fcb-199">If you already have a `Global.asax` file in your project, the Global Application Class item type will not be listed in the Add New Item dialog box.</span></span>


<span data-ttu-id="31fcb-200">[![Global.asax ファイルを Web アプリケーションのルート ディレクトリに追加します。](caching-data-at-application-startup-cs/_static/image4.png)](caching-data-at-application-startup-cs/_static/image3.png)</span><span class="sxs-lookup"><span data-stu-id="31fcb-200">[![Add the Global.asax File to Your Web Application s Root Directory](caching-data-at-application-startup-cs/_static/image4.png)](caching-data-at-application-startup-cs/_static/image3.png)</span></span>

<span data-ttu-id="31fcb-201">**図 3**: 追加、 `Global.asax` Web アプリケーション ルート ディレクトリにファイル ([フルサイズの画像を表示する をクリックします](caching-data-at-application-startup-cs/_static/image5.png))。</span><span class="sxs-lookup"><span data-stu-id="31fcb-201">**Figure 3**: Add the `Global.asax` File to Your Web Application s Root Directory ([Click to view full-size image](caching-data-at-application-startup-cs/_static/image5.png))</span></span>


<span data-ttu-id="31fcb-202">既定の`Global.asax`ファイル テンプレートには、サーバー側で 5 つのメソッドが含まれています。`<script>`タグ。</span><span class="sxs-lookup"><span data-stu-id="31fcb-202">The default `Global.asax` file template includes five methods within a server-side `<script>` tag:</span></span>

- <span data-ttu-id="31fcb-203">**`Application_Start`** 初回起動時に web アプリケーションを実行します。</span><span class="sxs-lookup"><span data-stu-id="31fcb-203">**`Application_Start`** executes when the web application first starts</span></span>
- <span data-ttu-id="31fcb-204">**`Application_End`** アプリケーションのシャット ダウン時に実行</span><span class="sxs-lookup"><span data-stu-id="31fcb-204">**`Application_End`** runs when the application is shutting down</span></span>
- <span data-ttu-id="31fcb-205">**`Application_Error`** ハンドルされない例外がアプリケーションに到達するたびに実行します。</span><span class="sxs-lookup"><span data-stu-id="31fcb-205">**`Application_Error`** executes whenever an unhandled exception reaches the application</span></span>
- <span data-ttu-id="31fcb-206">**`Session_Start`** 新しいセッションが作成されるときに実行します</span><span class="sxs-lookup"><span data-stu-id="31fcb-206">**`Session_Start`** executes when a new session is created</span></span>
- <span data-ttu-id="31fcb-207">**`Session_End`** セッションが期限切れか、破棄されたときに実行されます。</span><span class="sxs-lookup"><span data-stu-id="31fcb-207">**`Session_End`** runs when a session is expired or abandoned</span></span>

<span data-ttu-id="31fcb-208">`Application_Start`イベント ハンドラーは、アプリケーションのライフ サイクル中に 1 回だけ呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="31fcb-208">The `Application_Start` event handler is called only once during an application s life cycle.</span></span> <span data-ttu-id="31fcb-209">アプリケーションの起動時と、最初に、ASP.NET のリソースが、アプリケーションから要求されたアプリケーションが再起動されるまでの実行を継続の内容を変更することによって発生することが、`/Bin`フォルダーを変更する`Global.asax`、変更、内容、`App_Code`フォルダー、または変更、`Web.config`ファイル、その他の原因です。</span><span class="sxs-lookup"><span data-stu-id="31fcb-209">The application starts the first time an ASP.NET resource is requested from the application and continues to run until the application is restarted, which can happen by modifying the contents of the `/Bin` folder, modifying `Global.asax`, modifying the contents in the `App_Code` folder, or modifying the `Web.config` file, among other causes.</span></span> <span data-ttu-id="31fcb-210">参照してください[ASP.NET アプリケーションのライフ サイクルの概要](https://msdn.microsoft.com/library/ms178473.aspx)の詳細については、アプリケーションのライフ サイクルにします。</span><span class="sxs-lookup"><span data-stu-id="31fcb-210">Refer to [ASP.NET Application Life Cycle Overview](https://msdn.microsoft.com/library/ms178473.aspx) for a more detailed discussion on the application life cycle.</span></span>

<span data-ttu-id="31fcb-211">これらのチュートリアルにのみ必要があるコードを追加、`Application_Start`メソッドは、そのを自由に、他のユーザーを削除します。</span><span class="sxs-lookup"><span data-stu-id="31fcb-211">For these tutorials we only need to add code to the `Application_Start` method, so feel free to remove the others.</span></span> <span data-ttu-id="31fcb-212">`Application_Start`を呼び出すだけで、`StaticCache`クラスの`LoadStaticCache()`メソッドは、読み込みおよび仕入先の情報をキャッシュします。</span><span class="sxs-lookup"><span data-stu-id="31fcb-212">In `Application_Start`, simply call the `StaticCache` class s `LoadStaticCache()` method, which will load and cache the supplier information:</span></span>


[!code-aspx[Main](caching-data-at-application-startup-cs/samples/sample6.aspx)]

<span data-ttu-id="31fcb-213">すべてが s で終了です。</span><span class="sxs-lookup"><span data-stu-id="31fcb-213">That s all there is to it!</span></span> <span data-ttu-id="31fcb-214">アプリケーションの起動時に、`LoadStaticCache()`メソッドは、BLL から供給業者の情報を取得し、静的メンバー変数に保存 (を使用して最終的にどのようなキャッシュに格納するか、`StaticCache`クラス)。</span><span class="sxs-lookup"><span data-stu-id="31fcb-214">At application startup, the `LoadStaticCache()` method will grab the supplier information from the BLL, and store it in a static member variable (or whatever cache store you ended up using in the `StaticCache` class).</span></span> <span data-ttu-id="31fcb-215">この動作を確認するためにブレークポイントを設定、`Application_Start`メソッドと、アプリケーションを実行します。</span><span class="sxs-lookup"><span data-stu-id="31fcb-215">To verify this behavior, set a breakpoint in the `Application_Start` method and run your application.</span></span> <span data-ttu-id="31fcb-216">アプリケーションの開始時にブレークポイントをヒットしたことに注意してください。</span><span class="sxs-lookup"><span data-stu-id="31fcb-216">Note that the breakpoint is hit upon the application starting.</span></span> <span data-ttu-id="31fcb-217">ただし、後続の要求も、実行、`Application_Start`メソッドを実行します。</span><span class="sxs-lookup"><span data-stu-id="31fcb-217">Subsequent requests, however, do not cause the `Application_Start` method to execute.</span></span>


<span data-ttu-id="31fcb-218">[![Application_Start イベント ハンドラーが実行されていることを確認するブレークポイントを使用してください。](caching-data-at-application-startup-cs/_static/image7.png)](caching-data-at-application-startup-cs/_static/image6.png)</span><span class="sxs-lookup"><span data-stu-id="31fcb-218">[![Use a Breakpoint to Verify that the Application_Start Event Handler is Being Executed](caching-data-at-application-startup-cs/_static/image7.png)](caching-data-at-application-startup-cs/_static/image6.png)</span></span>

<span data-ttu-id="31fcb-219">**図 4**: ことを確認するブレークポイントを使用している、`Application_Start`イベント ハンドラーが実行されている ([フルサイズの画像を表示する をクリックします](caching-data-at-application-startup-cs/_static/image8.png))。</span><span class="sxs-lookup"><span data-stu-id="31fcb-219">**Figure 4**: Use a Breakpoint to Verify that the `Application_Start` Event Handler is Being Executed ([Click to view full-size image](caching-data-at-application-startup-cs/_static/image8.png))</span></span>


> [!NOTE]
> <span data-ttu-id="31fcb-220">ヒットしない場合、`Application_Start`ブレークポイント デバッグを開始するときに、アプリケーションが既に開始します。</span><span class="sxs-lookup"><span data-stu-id="31fcb-220">If you do not hit the `Application_Start` breakpoint when you first start debugging, it is because your application has already started.</span></span> <span data-ttu-id="31fcb-221">強制的に変更して再度実行するアプリケーション、`Global.asax`または`Web.config`ファイルし、し、もう一度お試しください。</span><span class="sxs-lookup"><span data-stu-id="31fcb-221">Force the application to restart by modifying your `Global.asax` or `Web.config` files and then try again.</span></span> <span data-ttu-id="31fcb-222">単に追加 (または削除できます)、アプリケーションを迅速に再起動するこれらのファイルのいずれかの末尾に空白行。</span><span class="sxs-lookup"><span data-stu-id="31fcb-222">You can simply add (or remove) a blank line at the end of one of these files to quickly restart the application.</span></span>


## <a name="step-5-displaying-the-cached-data"></a><span data-ttu-id="31fcb-223">手順 5: キャッシュされたデータを表示します。</span><span class="sxs-lookup"><span data-stu-id="31fcb-223">Step 5: Displaying the Cached Data</span></span>

<span data-ttu-id="31fcb-224">この時点で、`StaticCache`クラスを介してアクセスできるアプリケーションの起動時にキャッシュされた仕入先データのバージョンには、その`GetSuppliers()`メソッド。</span><span class="sxs-lookup"><span data-stu-id="31fcb-224">At this point the `StaticCache` class has a version of the supplier data cached at application startup that can be accessed through its `GetSuppliers()` method.</span></span> <span data-ttu-id="31fcb-225">プレゼンテーション層からこのデータを使用するには、ObjectDataSource を使用して、またはプログラムで呼び出すことができます、`StaticCache`クラスの`GetSuppliers()`ASP.NET ページの分離コード クラスのメソッド。</span><span class="sxs-lookup"><span data-stu-id="31fcb-225">To work with this data from the Presentation Layer, we can use an ObjectDataSource or programmatically invoke the `StaticCache` class s `GetSuppliers()` method from an ASP.NET page s code-behind class.</span></span> <span data-ttu-id="31fcb-226">キャッシュされた仕入先情報を表示する、ObjectDataSource コントロールと GridView コントロールの使い方を見て s を使用できます。</span><span class="sxs-lookup"><span data-stu-id="31fcb-226">Let s look at using the ObjectDataSource and GridView controls to display the cached supplier information.</span></span>

<span data-ttu-id="31fcb-227">開いて開始、`AtApplicationStartup.aspx`ページで、`Caching`フォルダー。</span><span class="sxs-lookup"><span data-stu-id="31fcb-227">Start by opening the `AtApplicationStartup.aspx` page in the `Caching` folder.</span></span> <span data-ttu-id="31fcb-228">GridView をデザイナーの設定には、ツールボックスからドラッグしてその`ID`プロパティを`Suppliers`します。</span><span class="sxs-lookup"><span data-stu-id="31fcb-228">Drag a GridView from the Toolbox onto the designer, setting its `ID` property to `Suppliers`.</span></span> <span data-ttu-id="31fcb-229">次に、GridView から s のスマート タグを選択してという名前の新しい ObjectDataSource を作成する`SuppliersCachedDataSource`します。</span><span class="sxs-lookup"><span data-stu-id="31fcb-229">Next, from the GridView s smart tag choose to create a new ObjectDataSource named `SuppliersCachedDataSource`.</span></span> <span data-ttu-id="31fcb-230">構成を使用する ObjectDataSource、`StaticCache`クラスの`GetSuppliers()`メソッド。</span><span class="sxs-lookup"><span data-stu-id="31fcb-230">Configure the ObjectDataSource to use the `StaticCache` class s `GetSuppliers()` method.</span></span>


<span data-ttu-id="31fcb-231">[![StaticCache クラスを使用する ObjectDataSource を構成します。](caching-data-at-application-startup-cs/_static/image10.png)](caching-data-at-application-startup-cs/_static/image9.png)</span><span class="sxs-lookup"><span data-stu-id="31fcb-231">[![Configure the ObjectDataSource to use the StaticCache Class](caching-data-at-application-startup-cs/_static/image10.png)](caching-data-at-application-startup-cs/_static/image9.png)</span></span>

<span data-ttu-id="31fcb-232">**図 5**: 構成を使用する ObjectDataSource、`StaticCache`クラス ([フルサイズの画像を表示する をクリックします](caching-data-at-application-startup-cs/_static/image11.png))。</span><span class="sxs-lookup"><span data-stu-id="31fcb-232">**Figure 5**: Configure the ObjectDataSource to use the `StaticCache` Class ([Click to view full-size image](caching-data-at-application-startup-cs/_static/image11.png))</span></span>


<span data-ttu-id="31fcb-233">[![GetSuppliers() メソッドを使用して、キャッシュされた仕入先データを取得するには](caching-data-at-application-startup-cs/_static/image13.png)](caching-data-at-application-startup-cs/_static/image12.png)</span><span class="sxs-lookup"><span data-stu-id="31fcb-233">[![Use the GetSuppliers() Method to Retrieve the Cached Supplier Data](caching-data-at-application-startup-cs/_static/image13.png)](caching-data-at-application-startup-cs/_static/image12.png)</span></span>

<span data-ttu-id="31fcb-234">**図 6**: 使用して、`GetSuppliers()`キャッシュ仕入先データを取得するメソッド ([フルサイズの画像を表示する をクリックします](caching-data-at-application-startup-cs/_static/image14.png))。</span><span class="sxs-lookup"><span data-stu-id="31fcb-234">**Figure 6**: Use the `GetSuppliers()` Method to Retrieve the Cached Supplier Data ([Click to view full-size image](caching-data-at-application-startup-cs/_static/image14.png))</span></span>


<span data-ttu-id="31fcb-235">ウィザードを完了すると、Visual Studio が自動的に追加 BoundFields のデータ フィールドの各`SuppliersDataTable`します。</span><span class="sxs-lookup"><span data-stu-id="31fcb-235">After completing the wizard, Visual Studio will automatically add BoundFields for each of the data fields in `SuppliersDataTable`.</span></span> <span data-ttu-id="31fcb-236">GridView コントロールと ObjectDataSource s 宣言型マークアップは、次のようになります。</span><span class="sxs-lookup"><span data-stu-id="31fcb-236">Your GridView and ObjectDataSource s declarative markup should look similar to the following:</span></span>


[!code-aspx[Main](caching-data-at-application-startup-cs/samples/sample7.aspx)]

<span data-ttu-id="31fcb-237">図 7 では、ブラウザーで表示する際、ページを示します。</span><span class="sxs-lookup"><span data-stu-id="31fcb-237">Figure 7 shows the page when viewed through a browser.</span></span> <span data-ttu-id="31fcb-238">出力は同じ BLL s から、データをプルしますが`SuppliersBLL`クラスが使用して、`StaticCache`クラスは、アプリケーションの起動時にキャッシュされたとして仕入先データを返します。</span><span class="sxs-lookup"><span data-stu-id="31fcb-238">The output is the same had we pulled the data from the BLL s `SuppliersBLL` class, but using the `StaticCache` class returns the supplier data as cached at application startup.</span></span> <span data-ttu-id="31fcb-239">ブレークポイントを設定することができます、`StaticCache`クラスの`GetSuppliers()`メソッドをこの動作を確認します。</span><span class="sxs-lookup"><span data-stu-id="31fcb-239">You can set breakpoints in the `StaticCache` class s `GetSuppliers()` method to verify this behavior.</span></span>


<span data-ttu-id="31fcb-240">[![キャッシュの仕入先データが GridView に表示されます。](caching-data-at-application-startup-cs/_static/image16.png)](caching-data-at-application-startup-cs/_static/image15.png)</span><span class="sxs-lookup"><span data-stu-id="31fcb-240">[![The Cached Supplier Data is Displayed in a GridView](caching-data-at-application-startup-cs/_static/image16.png)](caching-data-at-application-startup-cs/_static/image15.png)</span></span>

<span data-ttu-id="31fcb-241">**図 7**: GridView で [仕入先データのキャッシュが表示されます ([フルサイズの画像を表示する] をクリックします](caching-data-at-application-startup-cs/_static/image17.png))。</span><span class="sxs-lookup"><span data-stu-id="31fcb-241">**Figure 7**: The Cached Supplier Data is Displayed in a GridView ([Click to view full-size image](caching-data-at-application-startup-cs/_static/image17.png))</span></span>


## <a name="summary"></a><span data-ttu-id="31fcb-242">まとめ</span><span class="sxs-lookup"><span data-stu-id="31fcb-242">Summary</span></span>

<span data-ttu-id="31fcb-243">すべてのほとんどのデータ モデルには、かなり静的データ、通常、ルックアップ テーブルの形式で実装にはが含まれています。</span><span class="sxs-lookup"><span data-stu-id="31fcb-243">Most every data model contains a fair amount of static data, usually implemented in the form of lookup tables.</span></span> <span data-ttu-id="31fcb-244">この情報は、静的であるため s がこの情報を表示する必要があるたびに、データベースを継続的にアクセスする理由。</span><span class="sxs-lookup"><span data-stu-id="31fcb-244">Since this information is static, there s no reason to continually access the database each time this information needs to be displayed.</span></span> <span data-ttu-id="31fcb-245">さらに、その静的な性質により、データをキャッシュする場合が s、有効期限の必要はありません。</span><span class="sxs-lookup"><span data-stu-id="31fcb-245">Furthermore, due to its static nature, when caching the data there s no need for an expiry.</span></span> <span data-ttu-id="31fcb-246">このチュートリアルでは、このようなデータを取得し、データ キャッシュ、アプリケーションの状態、および静的メンバー変数を介した、それをキャッシュする方法を説明しました。</span><span class="sxs-lookup"><span data-stu-id="31fcb-246">In this tutorial we saw how to take such data and cache it in the data cache, application state, and through a static member variable.</span></span> <span data-ttu-id="31fcb-247">この情報は、アプリケーションの起動時にキャッシュされはアプリケーションの有効期間全体でキャッシュに残ります。</span><span class="sxs-lookup"><span data-stu-id="31fcb-247">This information is cached at application startup and remains in the cache throughout the application s lifetime.</span></span>

<span data-ttu-id="31fcb-248">このチュートリアルで、過去の 2 つ ve アプリケーション秒の有効期間の間のデータのキャッシュと切れの時間ベースの使用について説明しました。</span><span class="sxs-lookup"><span data-stu-id="31fcb-248">In this tutorial and the past two, we ve looked at caching data for the duration of the application s lifetime as well as using time-based expiries.</span></span> <span data-ttu-id="31fcb-249">データベースのデータをキャッシュする場合、時間ベースの有効期限が遅くなりますあります。</span><span class="sxs-lookup"><span data-stu-id="31fcb-249">When caching database data, though, a time-based expiry may be less than ideal.</span></span> <span data-ttu-id="31fcb-250">キャッシュを定期的にフラッシュするではなく、基になるデータベースのデータが変更されたときにのみ、キャッシュされた項目を削除するのに最適があります。</span><span class="sxs-lookup"><span data-stu-id="31fcb-250">Rather than periodically flushing the cache, it would be optimal to only evict the cached item when the underlying database data is modified.</span></span> <span data-ttu-id="31fcb-251">この理想は、次のチュートリアルで取り上げる SQL キャッシュ依存関係を使用して可能です。</span><span class="sxs-lookup"><span data-stu-id="31fcb-251">This ideal is possible through the use of SQL cache dependencies, which we'll examine in our next tutorial.</span></span>

<span data-ttu-id="31fcb-252">満足のプログラミングです。</span><span class="sxs-lookup"><span data-stu-id="31fcb-252">Happy Programming!</span></span>

## <a name="about-the-author"></a><span data-ttu-id="31fcb-253">執筆者紹介</span><span class="sxs-lookup"><span data-stu-id="31fcb-253">About the Author</span></span>

<span data-ttu-id="31fcb-254">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml)、7 つ受け取りますブックおよびの創設者の著者[4GuysFromRolla.com](http://www.4guysfromrolla.com)、Microsoft Web テクノロジと 1998 年から携わっています。</span><span class="sxs-lookup"><span data-stu-id="31fcb-254">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="31fcb-255">Scott は、フリーのコンサルタント、トレーナー、およびライターとして動作します。</span><span class="sxs-lookup"><span data-stu-id="31fcb-255">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="31fcb-256">最新の著書は[ *Sams 教える自分で ASP.NET 2.0 24 時間以内に*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)します。</span><span class="sxs-lookup"><span data-stu-id="31fcb-256">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="31fcb-257">彼に到達できる[mitchell@4GuysFromRolla.comします。](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="31fcb-257">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span> <span data-ttu-id="31fcb-258">彼のブログにあるでまたは[ http://ScottOnWriting.NET](http://ScottOnWriting.NET)します。</span><span class="sxs-lookup"><span data-stu-id="31fcb-258">or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

## <a name="special-thanks-to"></a><span data-ttu-id="31fcb-259">特別なに感謝します。</span><span class="sxs-lookup"><span data-stu-id="31fcb-259">Special Thanks To</span></span>

<span data-ttu-id="31fcb-260">このチュートリアル シリーズは、多くの便利なレビュー担当者によってレビューされました。</span><span class="sxs-lookup"><span data-stu-id="31fcb-260">This tutorial series was reviewed by many helpful reviewers.</span></span> <span data-ttu-id="31fcb-261">このチュートリアルでは、潜在顧客レビュー担当者は、Teresa Murphy および Zack Jones でした。</span><span class="sxs-lookup"><span data-stu-id="31fcb-261">Lead reviewers for this tutorial were Teresa Murphy and Zack Jones.</span></span> <span data-ttu-id="31fcb-262">今後、MSDN の記事を確認したいですか。</span><span class="sxs-lookup"><span data-stu-id="31fcb-262">Interested in reviewing my upcoming MSDN articles?</span></span> <span data-ttu-id="31fcb-263">場合は、筆者に[mitchell@4GuysFromRolla.comします。](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="31fcb-263">If so, drop me a line at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="31fcb-264">[前へ](caching-data-in-the-architecture-cs.md)
> [次へ](using-sql-cache-dependencies-cs.md)</span><span class="sxs-lookup"><span data-stu-id="31fcb-264">[Previous](caching-data-in-the-architecture-cs.md)
[Next](using-sql-cache-dependencies-cs.md)</span></span>
