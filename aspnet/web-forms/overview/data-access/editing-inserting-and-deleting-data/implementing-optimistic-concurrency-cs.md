---
uid: web-forms/overview/data-access/editing-inserting-and-deleting-data/implementing-optimistic-concurrency-cs
title: オプティミスティック同時実行制御 (c#) を実装する |Microsoft Docs
author: rick-anderson
description: データを編集する複数のユーザーを許可する web アプリケーションの場合、2 人のユーザーは編集、同じデータと同時にリスクがあります。 この tutori にしています.
ms.author: aspnetcontent
manager: wpickett
ms.date: 07/17/2006
ms.topic: article
ms.assetid: 56e15b33-93b8-43ad-8e19-44c6647ea05c
ms.technology: dotnet-webforms
msc.legacyurl: /web-forms/overview/data-access/editing-inserting-and-deleting-data/implementing-optimistic-concurrency-cs
msc.type: authoredcontent
ms.openlocfilehash: 120fdca43b7e68127277f6889504f173938117e4
ms.sourcegitcommit: 953ff9ea4369f154d6fd0239599279ddd3280009
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 07/03/2018
ms.locfileid: "37397773"
---
<a name="implementing-optimistic-concurrency-c"></a><span data-ttu-id="ceda5-104">オプティミスティック同時実行制御 (c#) を実装します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-104">Implementing Optimistic Concurrency (C#)</span></span>
====================
<span data-ttu-id="ceda5-105">によって[Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="ceda5-105">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="ceda5-106">[サンプル アプリをダウンロード](http://download.microsoft.com/download/9/c/1/9c1d03ee-29ba-4d58-aa1a-f201dcc822ea/ASPNET_Data_Tutorial_21_CS.exe)または[PDF のダウンロード](implementing-optimistic-concurrency-cs/_static/datatutorial21cs1.pdf)</span><span class="sxs-lookup"><span data-stu-id="ceda5-106">[Download Sample App](http://download.microsoft.com/download/9/c/1/9c1d03ee-29ba-4d58-aa1a-f201dcc822ea/ASPNET_Data_Tutorial_21_CS.exe) or [Download PDF](implementing-optimistic-concurrency-cs/_static/datatutorial21cs1.pdf)</span></span>

> <span data-ttu-id="ceda5-107">データを編集する複数のユーザーを許可する web アプリケーションの場合、2 人のユーザーは編集、同じデータと同時にリスクがあります。</span><span class="sxs-lookup"><span data-stu-id="ceda5-107">For a web application that allows multiple users to edit data, there is the risk that two users may be editing the same data at the same time.</span></span> <span data-ttu-id="ceda5-108">このチュートリアルでは、このリスクを処理するために、オプティミスティック同時実行制御を実装します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-108">In this tutorial we'll implement optimistic concurrency control to handle this risk.</span></span>


## <a name="introduction"></a><span data-ttu-id="ceda5-109">はじめに</span><span class="sxs-lookup"><span data-stu-id="ceda5-109">Introduction</span></span>

<span data-ttu-id="ceda5-110">データを表示するユーザーのみを許可する web アプリケーション、またはデータを変更できるユーザー 1 人のユーザーのみが含まれているは、いずれかに別の変更を誤って上書きする 2 つの同時実行ユーザーの脅威はありません。</span><span class="sxs-lookup"><span data-stu-id="ceda5-110">For web applications that only allow users to view data, or for those that include only a single user who can modify data, there's no threat of two concurrent users accidentally overwriting one another's changes.</span></span> <span data-ttu-id="ceda5-111">複数のユーザー データを更新または削除を許可する web アプリケーション、ただし、可能性があるもう 1 つの同時ユーザーと競合する 1 つのユーザーの変更。</span><span class="sxs-lookup"><span data-stu-id="ceda5-111">For web applications that allow multiple users to update or delete data, however, there's the potential for one user's modifications to clash with another concurrent user's.</span></span> <span data-ttu-id="ceda5-112">せず、同時実行ポリシーを配置するには、2 人のユーザーが同時に 1 つのレコードを編集時にその変更をコミットしたユーザー最後が上書きされます最初によって行われた変更。</span><span class="sxs-lookup"><span data-stu-id="ceda5-112">Without any concurrency policy in place, when two users are simultaneously editing a single record, the user who commits her changes last will override the changes made by the first.</span></span>

<span data-ttu-id="ceda5-113">たとえば、こと Jisun と Sam、2 人のユーザーが両方ページにアクセスして、アプリケーションで更新および削除の GridView コントロールを使用して、製品への訪問者を許可されているとします。</span><span class="sxs-lookup"><span data-stu-id="ceda5-113">For example, imagine that two users, Jisun and Sam, were both visiting a page in our application that allowed visitors to update and delete the products through a GridView control.</span></span> <span data-ttu-id="ceda5-114">両方は、ほぼ同時に、gridview 編集ボタンをクリックします。</span><span class="sxs-lookup"><span data-stu-id="ceda5-114">Both click the Edit button in the GridView around the same time.</span></span> <span data-ttu-id="ceda5-115">Jisun では、製品名を「Chai 紅茶」に変更し、[更新] ボタンをクリックします。</span><span class="sxs-lookup"><span data-stu-id="ceda5-115">Jisun changes the product name to "Chai Tea" and clicks the Update button.</span></span> <span data-ttu-id="ceda5-116">最終的には、`UPDATE`を設定すると、データベースに送信されるステートメント*すべて*の製品の更新可能なフィールド (Jisun では、1 つのフィールドのみ更新される場合でも`ProductName`)。</span><span class="sxs-lookup"><span data-stu-id="ceda5-116">The net result is an `UPDATE` statement that is sent to the database, which sets *all* of the product's updateable fields (even though Jisun only updated one field, `ProductName`).</span></span> <span data-ttu-id="ceda5-117">この時点では、データベースは、「Chai 紅茶」、飲み物、供給業者の風変わりな液体は、この特定の製品のカテゴリの値がします。</span><span class="sxs-lookup"><span data-stu-id="ceda5-117">At this point in time, the database has the values "Chai Tea," the category Beverages, the supplier Exotic Liquids, and so on for this particular product.</span></span> <span data-ttu-id="ceda5-118">ただし、Sam の画面に GridView として表示されます、製品名の編集可能な GridView 行"Chai"。</span><span class="sxs-lookup"><span data-stu-id="ceda5-118">However, the GridView on Sam's screen still shows the product name in the editable GridView row as "Chai".</span></span> <span data-ttu-id="ceda5-119">Jisun の変更がコミットされた後、数秒 Sam は調味料にカテゴリを更新し、更新プログラムをクリックします。</span><span class="sxs-lookup"><span data-stu-id="ceda5-119">A few seconds after Jisun's changes have been committed, Sam updates the category to Condiments and clicks Update.</span></span> <span data-ttu-id="ceda5-120">これは、結果、 `UPDATE` "Chai"に、製品名を設定しているデータベースに送信されたステートメント、`CategoryID`対応する飲み物のカテゴリの ID、および具合にします。</span><span class="sxs-lookup"><span data-stu-id="ceda5-120">This results in an `UPDATE` statement sent to the database that sets the product name to "Chai," the `CategoryID` to the corresponding Beverages category ID, and so on.</span></span> <span data-ttu-id="ceda5-121">Jisun の製品名の変更が上書きされました。</span><span class="sxs-lookup"><span data-stu-id="ceda5-121">Jisun's changes to the product name have been overwritten.</span></span> <span data-ttu-id="ceda5-122">図 1 は、この一連のイベントをグラフィカルに示しています。</span><span class="sxs-lookup"><span data-stu-id="ceda5-122">Figure 1 graphically depicts this series of events.</span></span>


<span data-ttu-id="ceda5-123">[![2 人のユーザー レコードを同時に更新するときに、その他の s を上書きするがあります s の潜在的 1 人のユーザーの変更](implementing-optimistic-concurrency-cs/_static/image2.png)](implementing-optimistic-concurrency-cs/_static/image1.png)</span><span class="sxs-lookup"><span data-stu-id="ceda5-123">[![When Two Users Simultaneously Update a Record There s Potential for One User s Changes to Overwrite the Other s](implementing-optimistic-concurrency-cs/_static/image2.png)](implementing-optimistic-concurrency-cs/_static/image1.png)</span></span>

<span data-ttu-id="ceda5-124">**図 1**: ときに 2 つのユーザーに同時に更新プログラム、レコードが潜在的な 1 人のユーザーの変更を他を上書きするため ([フルサイズの画像を表示する をクリックします](implementing-optimistic-concurrency-cs/_static/image3.png))。</span><span class="sxs-lookup"><span data-stu-id="ceda5-124">**Figure 1**: When Two Users Simultaneously Update a Record There s Potential for One User s Changes to Overwrite the Other s ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image3.png))</span></span>


<span data-ttu-id="ceda5-125">同様に、2 人のユーザーは、ページにアクセスして、1 人のユーザーはレコードを更新する別のユーザーによって削除されるときに処理する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="ceda5-125">Similarly, when two users are visiting a page, one user might be in the midst of updating a record when it is deleted by another user.</span></span> <span data-ttu-id="ceda5-126">または、ユーザーがページを読み込むときと削除 ボタンをクリックするの別のユーザーが変更そのレコードの内容。</span><span class="sxs-lookup"><span data-stu-id="ceda5-126">Or, between when a user loads a page and when they click the Delete button, another user may have modified the contents of that record.</span></span>

<span data-ttu-id="ceda5-127">3 つ[同時実行制御](http://en.wikipedia.org/wiki/Concurrency_control)戦略を使用できます。</span><span class="sxs-lookup"><span data-stu-id="ceda5-127">There are three [concurrency control](http://en.wikipedia.org/wiki/Concurrency_control) strategies available:</span></span>

- <span data-ttu-id="ceda5-128">**何もしない**-同時実行ユーザーは、同じレコードを変更するは、(既定の動作) を獲得する最後のコミットをお知らせ</span><span class="sxs-lookup"><span data-stu-id="ceda5-128">**Do Nothing** -if concurrent users are modifying the same record, let the last commit win (the default behavior)</span></span>
- <span data-ttu-id="ceda5-129">[**オプティミスティック同時実行制御**](http://en.wikipedia.org/wiki/Optimistic_concurrency_control) -同時実行は、このような競合が発生しません時間の大半で競合し、ある可能性がありますそのため、場合は、競合が発生した場合、単に通知するユーザーを想定していますが、変更。別のユーザーには、同じデータが変更されたために、保存できません。</span><span class="sxs-lookup"><span data-stu-id="ceda5-129">[**Optimistic Concurrency**](http://en.wikipedia.org/wiki/Optimistic_concurrency_control) - assume that while there may be concurrency conflicts every now and then, the vast majority of the time such conflicts won't arise; therefore, if a conflict does arise, simply inform the user that their changes can't be saved because another user has modified the same data</span></span>
- <span data-ttu-id="ceda5-130">**ペシミスティック同時実行制御**-同時実行の競合は一般的であり別のユーザーの同時実行のアクティビティのための変更が保存されなかったとユーザーがいるを許容しないことを前提としていますそのため、1 つのユーザーは、レコードの更新を起動するときにロック。、他のユーザーを編集したり、ユーザーがその変更をコミットするまでそのレコードの削除を防ぐ</span><span class="sxs-lookup"><span data-stu-id="ceda5-130">**Pessimistic Concurrency** - assume that concurrency conflicts are commonplace and that users won't tolerate being told their changes weren't saved due to another user's concurrent activity; therefore, when one user starts updating a record, lock it, thereby preventing any other users from editing or deleting that record until the user commits their modifications</span></span>

<span data-ttu-id="ceda5-131">勝利の最後の書き込みを具体的には、お知らせした、すべて、チュートリアルのこれまでとして既定の同時実行の解決方法を使用が。</span><span class="sxs-lookup"><span data-stu-id="ceda5-131">All of our tutorials thus far have used the default concurrency resolution strategy - namely, we've let the last write win.</span></span> <span data-ttu-id="ceda5-132">このチュートリアルではオプティミスティック同時実行制御を実装する方法を説明します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-132">In this tutorial we'll examine how to implement optimistic concurrency control.</span></span>

> [!NOTE]
> <span data-ttu-id="ceda5-133">このチュートリアル シリーズでのペシミスティック同時実行制御の例に注目しません。</span><span class="sxs-lookup"><span data-stu-id="ceda5-133">We won't look at pessimistic concurrency examples in this tutorial series.</span></span> <span data-ttu-id="ceda5-134">ペシミスティック同時実行制御はなどのロックのため、ほとんど使用されていなければ正しく開放、他のユーザーがデータを更新するを防ぐことができます。</span><span class="sxs-lookup"><span data-stu-id="ceda5-134">Pessimistic concurrency is rarely used because such locks, if not properly relinquished, can prevent other users from updating data.</span></span> <span data-ttu-id="ceda5-135">たとえば、ユーザーを編集するためのレコードをロックし、そのロックを解除する前に、その日のまま場合は、その他のユーザーはありません、元のユーザーが指定値を返しの更新が完了するまで、そのレコードを更新できません。</span><span class="sxs-lookup"><span data-stu-id="ceda5-135">For example, if a user locks a record for editing and then leaves for the day before unlocking it, no other user will be able to update that record until the original user returns and completes his update.</span></span> <span data-ttu-id="ceda5-136">したがって、ペシミスティック同時実行制御が使用されている場合は通常、タイムアウトに達すると、ロックをキャンセルします。</span><span class="sxs-lookup"><span data-stu-id="ceda5-136">Therefore, in situations where pessimistic concurrency is used, there's typically a timeout that, if reached, cancels the lock.</span></span> <span data-ttu-id="ceda5-137">チケット販売 web サイト、短い期間の特定の席の場所をロックする、ユーザーが注文処理を完了するまで、ペシミスティック同時実行制御の例に示します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-137">Ticket sales websites, which lock a particular seating location for short period while the user completes the order process, is an example of pessimistic concurrency control.</span></span>


## <a name="step-1-looking-at-how-optimistic-concurrency-is-implemented"></a><span data-ttu-id="ceda5-138">手順 1: の実装はオプティミスティック同時実行制御方法を見る</span><span class="sxs-lookup"><span data-stu-id="ceda5-138">Step 1: Looking at How Optimistic Concurrency is Implemented</span></span>

<span data-ttu-id="ceda5-139">オプティミスティック同時実行制御は、更新または削除プロセスを開始するときと同様、更新または削除されるレコードが同じ値があることを確認することによって機能します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-139">Optimistic concurrency control works by ensuring that the record being updated or deleted has the same values as it did when the updating or deleting process started.</span></span> <span data-ttu-id="ceda5-140">たとえば、編集可能な GridView で [編集] ボタンをクリックすると、レコードの値はデータベースから読み取るありテキスト ボックスや他の Web コントロールに表示されます。</span><span class="sxs-lookup"><span data-stu-id="ceda5-140">For example, when clicking the Edit button in an editable GridView, the record's values are read from the database and displayed in TextBoxes and other Web controls.</span></span> <span data-ttu-id="ceda5-141">これらの元の値は、GridView で保存されます。</span><span class="sxs-lookup"><span data-stu-id="ceda5-141">These original values are saved by the GridView.</span></span> <span data-ttu-id="ceda5-142">後で、ユーザーは、自分の変更を行います、[更新] ボタンをクリックして、後に元の値と新しい値を送受信するビジネス ロジック層、し、データ アクセス層まで。</span><span class="sxs-lookup"><span data-stu-id="ceda5-142">Later, after the user makes her changes and clicks the Update button, the original values plus the new values are sent to the Business Logic Layer, and then down to the Data Access Layer.</span></span> <span data-ttu-id="ceda5-143">データ アクセス層は、ユーザーが編集を開始した元の値は、データベースに引き続き値と同じ場合のみ、レコードを更新する SQL ステートメントを実行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="ceda5-143">The Data Access Layer must issue a SQL statement that will only update the record if the original values that the user started editing are identical to the values still in the database.</span></span> <span data-ttu-id="ceda5-144">図 2 は、このイベントのシーケンスを示しています。</span><span class="sxs-lookup"><span data-stu-id="ceda5-144">Figure 2 depicts this sequence of events.</span></span>


<span data-ttu-id="ceda5-145">[![正常に更新または削除、元の値は現在のデータベースの値と等しくする必要があります。](implementing-optimistic-concurrency-cs/_static/image5.png)](implementing-optimistic-concurrency-cs/_static/image4.png)</span><span class="sxs-lookup"><span data-stu-id="ceda5-145">[![For the Update or Delete to Succeed, the Original Values Must Be Equal to the Current Database Values](implementing-optimistic-concurrency-cs/_static/image5.png)](implementing-optimistic-concurrency-cs/_static/image4.png)</span></span>

<span data-ttu-id="ceda5-146">**図 2**: For Update または成功を元の値必要がありますと等しいデータベースの現在の値を Delete ([フルサイズの画像を表示する をクリックします](implementing-optimistic-concurrency-cs/_static/image6.png))。</span><span class="sxs-lookup"><span data-stu-id="ceda5-146">**Figure 2**: For the Update or Delete to Succeed, the Original Values Must Be Equal to the Current Database Values ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image6.png))</span></span>


<span data-ttu-id="ceda5-147">オプティミスティック同時実行制御を実装するためのさまざまな方法はあります (を参照してください[Peter A. 作成](http://peterbromberg.net/)の[Optmistic 同時実行更新ロジック](http://www.eggheadcafe.com/articles/20050719.asp)のさまざまなオプションについて簡単に説明)。</span><span class="sxs-lookup"><span data-stu-id="ceda5-147">There are various approaches to implementing optimistic concurrency (see [Peter A. Bromberg](http://peterbromberg.net/)'s [Optmistic Concurrency Updating Logic](http://www.eggheadcafe.com/articles/20050719.asp) for a brief look at a number of options).</span></span> <span data-ttu-id="ceda5-148">ADO.NET 型指定されたデータセットは、チェック ボックスのチェック マークだけで構成できる 1 つの実装を提供します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-148">The ADO.NET Typed DataSet provides one implementation that can be configured with just the tick of a checkbox.</span></span> <span data-ttu-id="ceda5-149">型指定されたデータセット内に TableAdapter は、TableAdapter のオプティミスティック同時実行制御を有効にする`UPDATE`と`DELETE`のすべての元の値の比較を含めるようにステートメントを`WHERE`句。</span><span class="sxs-lookup"><span data-stu-id="ceda5-149">Enabling optimistic concurrency for a TableAdapter in the Typed DataSet augments the TableAdapter's `UPDATE` and `DELETE` statements to include a comparison of all of the original values in the `WHERE` clause.</span></span> <span data-ttu-id="ceda5-150">次`UPDATE`ステートメントでは、たとえば、更新プログラム名と製品の価格データベースの現在の値が、GridView でレコードを更新するときに取得された元の値に等しい場合のみです。</span><span class="sxs-lookup"><span data-stu-id="ceda5-150">The following `UPDATE` statement, for example, updates the name and price of a product only if the current database values are equal to the values that were originally retrieved when updating the record in the GridView.</span></span> <span data-ttu-id="ceda5-151">`@ProductName`と`@UnitPrice`パラメーターには、ユーザーが入力した新しい値が含まれて`@original_ProductName`と`@original_UnitPrice`編集ボタンがクリックされたときに、GridView に読み込まれた最初の値が含まれます。</span><span class="sxs-lookup"><span data-stu-id="ceda5-151">The `@ProductName` and `@UnitPrice` parameters contain the new values entered by the user, whereas `@original_ProductName` and `@original_UnitPrice` contain the values that were originally loaded into the GridView when the Edit button was clicked:</span></span>


[!code-sql[Main](implementing-optimistic-concurrency-cs/samples/sample1.sql)]

> [!NOTE]
> <span data-ttu-id="ceda5-152">これは、`UPDATE`読みやすくするため、ステートメントを簡素化されています。</span><span class="sxs-lookup"><span data-stu-id="ceda5-152">This `UPDATE` statement has been simplified for readability.</span></span> <span data-ttu-id="ceda5-153">実際には、`UnitPrice`チェックイン、`WHERE`句は、以降は複雑になります`UnitPrice`含めることができます`NULL`s と確認しているとき`NULL = NULL`常に False を返します (代わりに使用する必要があります`IS NULL`)。</span><span class="sxs-lookup"><span data-stu-id="ceda5-153">In practice, the `UnitPrice` check in the `WHERE` clause would be more involved since `UnitPrice` can contain `NULL` s and checking if `NULL = NULL` always returns False (instead you must use `IS NULL`).</span></span>


<span data-ttu-id="ceda5-154">さまざまな基になるだけでなく`UPDATE`ダイレクト メソッドのステートメントでは、オプティミスティック同時実行もその DB のシグネチャを変更して、TableAdapter を構成します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-154">In addition to using a different underlying `UPDATE` statement, configuring a TableAdapter to use optimistic concurrency also modifies the signature of its DB direct methods.</span></span> <span data-ttu-id="ceda5-155">最初のチュートリアルでは、メッセージの取り消し[*データ アクセス層を作成する*](../introduction/creating-a-data-access-layer-cs.md)、値の入力パラメーターとしての DB のダイレクト メソッドに、スカラーの一覧を受け取るものがあったこと (厳密に型指定された DataRow ではなくまたはDataTable インスタンスの場合)。</span><span class="sxs-lookup"><span data-stu-id="ceda5-155">Recall from our first tutorial, [*Creating a Data Access Layer*](../introduction/creating-a-data-access-layer-cs.md), that DB direct methods were those that accepts a list of scalar values as input parameters (rather than a strongly-typed DataRow or DataTable instance).</span></span> <span data-ttu-id="ceda5-156">オプティミスティック同時実行制御、直接の DB を使用する場合`Update()`と`Delete()`メソッドにも、元の値の入力パラメーターが含まれます。</span><span class="sxs-lookup"><span data-stu-id="ceda5-156">When using optimistic concurrency, the DB direct `Update()` and `Delete()` methods include input parameters for the original values as well.</span></span> <span data-ttu-id="ceda5-157">さらに、BLL バッチを使用するためのコードの更新パターン (、`Update()`をスカラー値ではなく、Datarow とデータ テーブルを受け取るメソッド オーバー ロード) も変更する必要があります。</span><span class="sxs-lookup"><span data-stu-id="ceda5-157">Moreover, the code in the BLL for using the batch update pattern (the `Update()` method overloads that accept DataRows and DataTables rather than scalar values) must be changed as well.</span></span>

<span data-ttu-id="ceda5-158">はなく、既存の拡張よりも DAL の Tableadapter みましょう (これに対応する BLL の変更が必要となる) オプティミスティック同時実行を使用する代わりに新しいデータセットを作成型指定された名前付き`NorthwindOptimisticConcurrency`に追加する`Products`TableAdapter をオプティミスティック同時実行制御を使用します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-158">Rather than extend our existing DAL's TableAdapters to use optimistic concurrency (which would necessitate changing the BLL to accommodate), let's instead create a new Typed DataSet named `NorthwindOptimisticConcurrency`, to which we'll add a `Products` TableAdapter that uses optimistic concurrency.</span></span> <span data-ttu-id="ceda5-159">次に、作成します、 `ProductsOptimisticConcurrencyBLL` DAL、オプティミスティック同時実行制御をサポートするために適切な変更が含まれているビジネス ロジック層のクラス。</span><span class="sxs-lookup"><span data-stu-id="ceda5-159">Following that, we'll create a `ProductsOptimisticConcurrencyBLL` Business Logic Layer class that has the appropriate modifications to support the optimistic concurrency DAL.</span></span> <span data-ttu-id="ceda5-160">用意した土台を構築すると ASP.NET ページを作成する準備になります。</span><span class="sxs-lookup"><span data-stu-id="ceda5-160">Once this groundwork has been laid, we'll be ready to create the ASP.NET page.</span></span>

## <a name="step-2-creating-a-data-access-layer-that-supports-optimistic-concurrency"></a><span data-ttu-id="ceda5-161">手順 2: は、オプティミスティック同時実行制御をサポートするデータ アクセス層を作成します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-161">Step 2: Creating a Data Access Layer That Supports Optimistic Concurrency</span></span>

<span data-ttu-id="ceda5-162">新しい型指定されたデータセットを作成するを右クリックし、`DAL`内のフォルダー、`App_Code`フォルダーという名前の新しいデータセットを追加および`NorthwindOptimisticConcurrency`します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-162">To create a new Typed DataSet, right-click on the `DAL` folder within the `App_Code` folder and add a new DataSet named `NorthwindOptimisticConcurrency`.</span></span> <span data-ttu-id="ceda5-163">最初のチュートリアルで説明したように行うのために追加されます新しい TableAdapter を TableAdapter 構成ウィザードを自動的に起動する、型指定されたデータセット。</span><span class="sxs-lookup"><span data-stu-id="ceda5-163">As we saw in the first tutorial, doing so will add a new TableAdapter to the Typed DataSet, automatically launching the TableAdapter Configuration Wizard.</span></span> <span data-ttu-id="ceda5-164">データベースへの接続 - を使用して Northwind データベースの同じ接続を指定するよう指示最初の画面で、`NORTHWNDConnectionString`設定から`Web.config`します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-164">In the first screen, we're prompted to specify the database to connect to - connect to the same Northwind database using the `NORTHWNDConnectionString` setting from `Web.config`.</span></span>


<span data-ttu-id="ceda5-165">[![同じ Northwind データベースへの接続します。](implementing-optimistic-concurrency-cs/_static/image8.png)](implementing-optimistic-concurrency-cs/_static/image7.png)</span><span class="sxs-lookup"><span data-stu-id="ceda5-165">[![Connect to the Same Northwind Database](implementing-optimistic-concurrency-cs/_static/image8.png)](implementing-optimistic-concurrency-cs/_static/image7.png)</span></span>

<span data-ttu-id="ceda5-166">**図 3**: 同じ Northwind データベースへの接続 ([フルサイズの画像を表示する をクリックします](implementing-optimistic-concurrency-cs/_static/image9.png))。</span><span class="sxs-lookup"><span data-stu-id="ceda5-166">**Figure 3**: Connect to the Same Northwind Database ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image9.png))</span></span>


<span data-ttu-id="ceda5-167">次に、データを照会する方法についてよう求められます。 アドホック SQL ステートメントでは、新しいストアド プロシージャ、または既存のストアド プロシージャ。</span><span class="sxs-lookup"><span data-stu-id="ceda5-167">Next, we are prompted as to how to query the data: through an ad-hoc SQL statement, a new stored procedure, or an existing stored procedure.</span></span> <span data-ttu-id="ceda5-168">元の DAL でアドホック SQL クエリを使用するとため、このオプションを使用ここでも。</span><span class="sxs-lookup"><span data-stu-id="ceda5-168">Since we used ad-hoc SQL queries in our original DAL, use this option here as well.</span></span>


<span data-ttu-id="ceda5-169">[![アドホック SQL ステートメントを使用して取得するデータを指定します。](implementing-optimistic-concurrency-cs/_static/image11.png)](implementing-optimistic-concurrency-cs/_static/image10.png)</span><span class="sxs-lookup"><span data-stu-id="ceda5-169">[![Specify the Data to Retrieve Using an Ad-Hoc SQL Statement](implementing-optimistic-concurrency-cs/_static/image11.png)](implementing-optimistic-concurrency-cs/_static/image10.png)</span></span>

<span data-ttu-id="ceda5-170">**図 4**: アドホック SQL ステートメントを使用して取得するデータを指定 ([フルサイズの画像を表示する をクリックします](implementing-optimistic-concurrency-cs/_static/image12.png))。</span><span class="sxs-lookup"><span data-stu-id="ceda5-170">**Figure 4**: Specify the Data to Retrieve Using an Ad-Hoc SQL Statement ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image12.png))</span></span>


<span data-ttu-id="ceda5-171">次の画面で、製品情報の取得に使用する SQL クエリを入力します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-171">On the following screen, enter the SQL query to use to retrieve the product information.</span></span> <span data-ttu-id="ceda5-172">使用する正確な同じ SQL クエリを使用しましょう、`Products`で TableAdapter を返しますのすべて、元の DAL、`Product`名、製品のサプライヤーとカテゴリ名と列。</span><span class="sxs-lookup"><span data-stu-id="ceda5-172">Let's use the exact same SQL query used for the `Products` TableAdapter from our original DAL, which returns all of the `Product` columns along with the product's supplier and category names:</span></span>


[!code-sql[Main](implementing-optimistic-concurrency-cs/samples/sample2.sql)]


<span data-ttu-id="ceda5-173">[![元の DAL で製品 TableAdapter から同じ SQL クエリを使用します。](implementing-optimistic-concurrency-cs/_static/image14.png)](implementing-optimistic-concurrency-cs/_static/image13.png)</span><span class="sxs-lookup"><span data-stu-id="ceda5-173">[![Use the Same SQL Query from the Products TableAdapter in the Original DAL](implementing-optimistic-concurrency-cs/_static/image14.png)](implementing-optimistic-concurrency-cs/_static/image13.png)</span></span>

<span data-ttu-id="ceda5-174">**図 5**: から、同じ SQL クエリを使用して、`Products`元の DAL の TableAdapter ([フルサイズの画像を表示する をクリックします](implementing-optimistic-concurrency-cs/_static/image15.png))。</span><span class="sxs-lookup"><span data-stu-id="ceda5-174">**Figure 5**: Use the Same SQL Query from the `Products` TableAdapter in the Original DAL ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image15.png))</span></span>


<span data-ttu-id="ceda5-175">次の画面上に移動すると、前に、詳細オプション ボタンをクリックします。</span><span class="sxs-lookup"><span data-stu-id="ceda5-175">Before moving onto the next screen, click the Advanced Options button.</span></span> <span data-ttu-id="ceda5-176">この TableAdapter 採用のオプティミスティック同時実行制御には、「オプティミスティック同時実行制御を使用して、」チェック ボックスにチェックします。</span><span class="sxs-lookup"><span data-stu-id="ceda5-176">To have this TableAdapter employ optimistic concurrency control, simply check the "Use optimistic concurrency" checkbox.</span></span>


<span data-ttu-id="ceda5-177">[![当座預金でオプティミスティック同時実行制御を有効にする、&quot;オプティミスティック同時実行制御を使用して、&quot;チェック ボックス](implementing-optimistic-concurrency-cs/_static/image17.png)](implementing-optimistic-concurrency-cs/_static/image16.png)</span><span class="sxs-lookup"><span data-stu-id="ceda5-177">[![Enable Optimistic Concurrency Control by Checking the &quot;Use optimistic concurrency&quot; CheckBox](implementing-optimistic-concurrency-cs/_static/image17.png)](implementing-optimistic-concurrency-cs/_static/image16.png)</span></span>

<span data-ttu-id="ceda5-178">**図 6**: オプティミスティック同時実行制御 [オプティミスティック同時実行制御を使用する] チェック ボックスをオンを有効にする ([フルサイズの画像を表示する をクリックします](implementing-optimistic-concurrency-cs/_static/image18.png))。</span><span class="sxs-lookup"><span data-stu-id="ceda5-178">**Figure 6**: Enable Optimistic Concurrency Control by Checking the "Use optimistic concurrency" CheckBox ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image18.png))</span></span>


<span data-ttu-id="ceda5-179">最後に、TableAdapter に datatable し、; DataTable を返すデータ アクセス パターンを使用することを示しますDB のダイレクト メソッドを作成することも示します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-179">Lastly, indicate that the TableAdapter should use the data access patterns that both fill a DataTable and return a DataTable; also indicate that the DB direct methods should be created.</span></span> <span data-ttu-id="ceda5-180">GetProducts に GetData の戻り値は、メソッド名 DataTable パターンを変更、名前付け規則をミラーリングするように、元の DAL で使用しています。</span><span class="sxs-lookup"><span data-stu-id="ceda5-180">Change the method name for the Return a DataTable pattern from GetData to GetProducts, so as to mirror the naming conventions we used in our original DAL.</span></span>


<span data-ttu-id="ceda5-181">[![すべてのデータ アクセス パターンを利用する TableAdapter があります。](implementing-optimistic-concurrency-cs/_static/image20.png)](implementing-optimistic-concurrency-cs/_static/image19.png)</span><span class="sxs-lookup"><span data-stu-id="ceda5-181">[![Have the TableAdapter Utilize All Data Access Patterns](implementing-optimistic-concurrency-cs/_static/image20.png)](implementing-optimistic-concurrency-cs/_static/image19.png)</span></span>

<span data-ttu-id="ceda5-182">**図 7**: TableAdapter 利用すべてのデータ アクセス パターンがある ([フルサイズの画像を表示する をクリックします](implementing-optimistic-concurrency-cs/_static/image21.png))。</span><span class="sxs-lookup"><span data-stu-id="ceda5-182">**Figure 7**: Have the TableAdapter Utilize All Data Access Patterns ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image21.png))</span></span>


<span data-ttu-id="ceda5-183">データセット デザイナー ウィザードを完了すると、厳密に型が含まれます`Products`DataTable および TableAdapter。</span><span class="sxs-lookup"><span data-stu-id="ceda5-183">After completing the wizard, the DataSet Designer will include a strongly-typed `Products` DataTable and TableAdapter.</span></span> <span data-ttu-id="ceda5-184">DataTable の名前を変更する少し`Products`に`ProductsOptimisticConcurrency`DataTable のタイトル バーを右クリックして、コンテキスト メニューから名前の変更を選択して行うことができます。</span><span class="sxs-lookup"><span data-stu-id="ceda5-184">Take a moment to rename the DataTable from `Products` to `ProductsOptimisticConcurrency`, which you can do by right-clicking on the DataTable's title bar and choosing Rename from the context menu.</span></span>


<span data-ttu-id="ceda5-185">[![型指定された DataSet に DataTable と TableAdapter が追加されました。](implementing-optimistic-concurrency-cs/_static/image23.png)](implementing-optimistic-concurrency-cs/_static/image22.png)</span><span class="sxs-lookup"><span data-stu-id="ceda5-185">[![A DataTable and TableAdapter Have Been Added to the Typed DataSet](implementing-optimistic-concurrency-cs/_static/image23.png)](implementing-optimistic-concurrency-cs/_static/image22.png)</span></span>

<span data-ttu-id="ceda5-186">**図 8**: A DataTable と型指定されたデータセットに追加された TableAdapter ([フルサイズの画像を表示する をクリックします](implementing-optimistic-concurrency-cs/_static/image24.png))。</span><span class="sxs-lookup"><span data-stu-id="ceda5-186">**Figure 8**: A DataTable and TableAdapter Have Been Added to the Typed DataSet ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image24.png))</span></span>


<span data-ttu-id="ceda5-187">間の相違点を確認する、`UPDATE`と`DELETE`間でクエリを実行、 `ProductsOptimisticConcurrency` TableAdapter (オプティミスティック同時実行制御を使用) して (これは) 製品の TableAdapter に TableAdapter をクリックし、[プロパティ] ウィンドウに移動します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-187">To see the differences between the `UPDATE` and `DELETE` queries between the `ProductsOptimisticConcurrency` TableAdapter (which uses optimistic concurrency) and the Products TableAdapter (which doesn't), click on the TableAdapter and go to the Properties window.</span></span> <span data-ttu-id="ceda5-188">`DeleteCommand`と`UpdateCommand`プロパティの`CommandText`サブプロパティ DAL の更新または削除に関連するメソッドが呼び出されたときに、データベースに送信される実際の SQL 構文を確認します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-188">In the `DeleteCommand` and `UpdateCommand` properties' `CommandText` subproperties you can see the actual SQL syntax that is sent to the database when the DAL's update or delete-related methods are invoked.</span></span> <span data-ttu-id="ceda5-189">`ProductsOptimisticConcurrency` TableAdapter、`DELETE`ステートメントを使用します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-189">For the `ProductsOptimisticConcurrency` TableAdapter the `DELETE` statement used is:</span></span>


[!code-sql[Main](implementing-optimistic-concurrency-cs/samples/sample3.sql)]

<span data-ttu-id="ceda5-190">一方、`DELETE`元の DAL の製品 TableAdapter のステートメントは、はるかに簡単です。</span><span class="sxs-lookup"><span data-stu-id="ceda5-190">Whereas the `DELETE` statement for the Product TableAdapter in our original DAL is the much simpler:</span></span>


[!code-sql[Main](implementing-optimistic-concurrency-cs/samples/sample4.sql)]

<span data-ttu-id="ceda5-191">ご覧のとおり、`WHERE`句、`DELETE`オプティミスティック同時実行制御を使用する TableAdapter のステートメントには間の比較が含まれています、`Product`テーブルの既存の列の値と元の値に、GridView や DetailsView (FormView) 最後に作成されました。</span><span class="sxs-lookup"><span data-stu-id="ceda5-191">As you can see, the `WHERE` clause in the `DELETE` statement for the TableAdapter that uses optimistic concurrency includes a comparison between each of the `Product` table's existing column values and the original values at the time the GridView (or DetailsView or FormView) was last populated.</span></span> <span data-ttu-id="ceda5-192">以外のすべてのフィールドから`ProductID`、`ProductName`と`Discontinued`が`NULL`値やその他のパラメーター チェックが正しく比較に含まれる`NULL`値、`WHERE`句。</span><span class="sxs-lookup"><span data-stu-id="ceda5-192">Since all fields other than `ProductID`, `ProductName`, and `Discontinued` can have `NULL` values, additional parameters and checks are included to correctly compare `NULL` values in the `WHERE` clause.</span></span>

<span data-ttu-id="ceda5-193">いますしませんが、追加のデータ テーブル オプティミスティック同時実行制御が有効なデータセットにこのチュートリアルでは、として追加、ASP.NET ページは、更新および製品情報の削除のみ提供します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-193">We won't be adding any additional DataTables to the optimistic concurrency-enabled DataSet for this tutorial, as our ASP.NET page will only provide updating and deleting product information.</span></span> <span data-ttu-id="ceda5-194">ただし、私たちを追加する必要は引き続き、`GetProductByProductID(productID)`メソッドを`ProductsOptimisticConcurrency`TableAdapter。</span><span class="sxs-lookup"><span data-stu-id="ceda5-194">However, we do still need to add the `GetProductByProductID(productID)` method to the `ProductsOptimisticConcurrency` TableAdapter.</span></span>

<span data-ttu-id="ceda5-195">これを行うには、TableAdapter のタイトル バーを右クリックし (領域権利、`Fill`と`GetProducts`メソッド名)、コンテキスト メニューから追加のクエリを選択します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-195">To accomplish this, right-click on the TableAdapter's title bar (the area right above the `Fill` and `GetProducts` method names) and choose Add Query from the context menu.</span></span> <span data-ttu-id="ceda5-196">これにより、TableAdapter クエリの構成ウィザードが起動します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-196">This will launch the TableAdapter Query Configuration Wizard.</span></span> <span data-ttu-id="ceda5-197">TableAdapter の初期構成では、作成することと、`GetProductByProductID(productID)`アドホック SQL ステートメントを使用するメソッド (図 4 参照)。</span><span class="sxs-lookup"><span data-stu-id="ceda5-197">As with our TableAdapter's initial configuration, opt to create the `GetProductByProductID(productID)` method using an ad-hoc SQL statement (see Figure 4).</span></span> <span data-ttu-id="ceda5-198">以降、`GetProductByProductID(productID)`メソッドは、特定の製品に関する情報を返します、このクエリがあることを示す、`SELECT`行を返す型のクエリを実行します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-198">Since the `GetProductByProductID(productID)` method returns information about a particular product, indicate that this query is a `SELECT` query type that returns rows.</span></span>


<span data-ttu-id="ceda5-199">[![クエリの型としてマークする&quot;を行を返す SELECT&quot;](implementing-optimistic-concurrency-cs/_static/image26.png)](implementing-optimistic-concurrency-cs/_static/image25.png)</span><span class="sxs-lookup"><span data-stu-id="ceda5-199">[![Mark the Query Type as a &quot;SELECT which returns rows&quot;](implementing-optimistic-concurrency-cs/_static/image26.png)](implementing-optimistic-concurrency-cs/_static/image25.png)</span></span>

<span data-ttu-id="ceda5-200">**図 9**: クエリの型としてマークする"`SELECT`行を返す"([フルサイズの画像を表示する をクリックします](implementing-optimistic-concurrency-cs/_static/image27.png))。</span><span class="sxs-lookup"><span data-stu-id="ceda5-200">**Figure 9**: Mark the Query Type as a "`SELECT` which returns rows" ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image27.png))</span></span>


<span data-ttu-id="ceda5-201">次の画面を事前に読み込まれた、TableAdapter の既定のクエリで、使用する SQL クエリ求められたら。</span><span class="sxs-lookup"><span data-stu-id="ceda5-201">On the next screen we're prompted for the SQL query to use, with the TableAdapter's default query pre-loaded.</span></span> <span data-ttu-id="ceda5-202">句に含める既存のクエリを補強`WHERE ProductID = @ProductID`図 10 に示すようにします。</span><span class="sxs-lookup"><span data-stu-id="ceda5-202">Augment the existing query to include the clause `WHERE ProductID = @ProductID`, as shown in Figure 10.</span></span>


<span data-ttu-id="ceda5-203">[![追加、WHERE 句を事前に読み込まれたクエリが特定の製品レコードを返す](implementing-optimistic-concurrency-cs/_static/image29.png)](implementing-optimistic-concurrency-cs/_static/image28.png)</span><span class="sxs-lookup"><span data-stu-id="ceda5-203">[![Add a WHERE Clause to the Pre-Loaded Query to Return a Specific Product Record](implementing-optimistic-concurrency-cs/_static/image29.png)](implementing-optimistic-concurrency-cs/_static/image28.png)</span></span>

<span data-ttu-id="ceda5-204">**図 10**: 追加、`WHERE`句を Pre-Loaded クエリが特定の製品レコードを返す ([フルサイズの画像を表示する をクリックします](implementing-optimistic-concurrency-cs/_static/image30.png))。</span><span class="sxs-lookup"><span data-stu-id="ceda5-204">**Figure 10**: Add a `WHERE` Clause to the Pre-Loaded Query to Return a Specific Product Record ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image30.png))</span></span>


<span data-ttu-id="ceda5-205">最後に、生成されたメソッド名を変更`FillByProductID`と`GetProductByProductID`します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-205">Finally, change the generated method names to `FillByProductID` and `GetProductByProductID`.</span></span>


<span data-ttu-id="ceda5-206">[![FillByProductID を GetProductByProductID メソッドの名前を変更します。](implementing-optimistic-concurrency-cs/_static/image32.png)](implementing-optimistic-concurrency-cs/_static/image31.png)</span><span class="sxs-lookup"><span data-stu-id="ceda5-206">[![Rename the Methods to FillByProductID and GetProductByProductID](implementing-optimistic-concurrency-cs/_static/image32.png)](implementing-optimistic-concurrency-cs/_static/image31.png)</span></span>

<span data-ttu-id="ceda5-207">**図 11**: メソッドの名前を変更`FillByProductID`と`GetProductByProductID`([フルサイズの画像を表示する をクリックします](implementing-optimistic-concurrency-cs/_static/image33.png))。</span><span class="sxs-lookup"><span data-stu-id="ceda5-207">**Figure 11**: Rename the Methods to `FillByProductID` and `GetProductByProductID` ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image33.png))</span></span>


<span data-ttu-id="ceda5-208">このウィザードは完了で TableAdapter にデータを取得するための 2 つのメソッド: `GetProducts()`、返された*すべて*製品; と`GetProductByProductID(productID)`、指定された製品が返されます。</span><span class="sxs-lookup"><span data-stu-id="ceda5-208">With this wizard complete, the TableAdapter now contains two methods for retrieving data: `GetProducts()`, which returns *all* products; and `GetProductByProductID(productID)`, which returns the specified product.</span></span>

## <a name="step-3-creating-a-business-logic-layer-for-the-optimistic-concurrency-enabled-dal"></a><span data-ttu-id="ceda5-209">手順 3: オプティミスティック同時実行制御が有効な DAL のビジネス ロジック層を作成します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-209">Step 3: Creating a Business Logic Layer for the Optimistic Concurrency-Enabled DAL</span></span>

<span data-ttu-id="ceda5-210">既存`ProductsBLL`クラスには、バッチ更新とダイレクト パターンの DB を使用しての例を示します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-210">Our existing `ProductsBLL` class has examples of using both the batch update and DB direct patterns.</span></span> <span data-ttu-id="ceda5-211">`AddProduct`メソッドと`UpdateProduct`両方オーバー ロードを渡して、バッチ更新パターンを使用して、 `ProductRow` TableAdapter の Update メソッドのインスタンス。</span><span class="sxs-lookup"><span data-stu-id="ceda5-211">The `AddProduct` method and `UpdateProduct` overloads both use the batch update pattern, passing in a `ProductRow` instance to the TableAdapter's Update method.</span></span> <span data-ttu-id="ceda5-212">`DeleteProduct`メソッドで呼び出す TableAdapter の DB 直接パターンが使用一方、`Delete(productID)`メソッド。</span><span class="sxs-lookup"><span data-stu-id="ceda5-212">The `DeleteProduct` method, on the other hand, uses the DB direct pattern, calling the TableAdapter's `Delete(productID)` method.</span></span>

<span data-ttu-id="ceda5-213">新しい`ProductsOptimisticConcurrency`TableAdapter、DB のダイレクト メソッドで元の値が渡すもする必要があるようになりました。</span><span class="sxs-lookup"><span data-stu-id="ceda5-213">With the new `ProductsOptimisticConcurrency` TableAdapter, the DB direct methods now require that the original values also be passed in.</span></span> <span data-ttu-id="ceda5-214">たとえば、`Delete`メソッドが 10 個の入力パラメーターが受け取るようになりました元`ProductID`、 `ProductName`、 `SupplierID`、 `CategoryID`、 `QuantityPerUnit`、 `UnitPrice`、 `UnitsInStock`、 `UnitsOnOrder`、 `ReorderLevel`、。`Discontinued`します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-214">For example, the `Delete` method now expects ten input parameters: the original `ProductID`, `ProductName`, `SupplierID`, `CategoryID`, `QuantityPerUnit`, `UnitPrice`, `UnitsInStock`, `UnitsOnOrder`, `ReorderLevel`, and `Discontinued`.</span></span> <span data-ttu-id="ceda5-215">これら追加入力パラメーターの値を使用して`WHERE`の句、`DELETE`ステートメントだけで指定されたレコードを削除するまで、元のデータベースの現在の値がマップに、データベースに送信します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-215">It uses these additional input parameters' values in `WHERE` clause of the `DELETE` statement sent to the database, only deleting the specified record if the database's current values map up to the original ones.</span></span>

<span data-ttu-id="ceda5-216">Tableadapter のメソッド シグネチャを while`Update`バッチ更新パターンで使用される方法が変更されていない、オリジナルと新しい値を記録するために必要なコードにします。</span><span class="sxs-lookup"><span data-stu-id="ceda5-216">While the method signature for the TableAdapter's `Update` method used in the batch update pattern hasn't changed, the code needed to record the original and new values has.</span></span> <span data-ttu-id="ceda5-217">そのため、当社の既存のオプティミスティック同時実行制御が有効な DAL を使用しようとするのではなく`ProductsBLL`クラスで、新しい DAL を操作するための新しいビジネス ロジック層クラスを作成しましょう。</span><span class="sxs-lookup"><span data-stu-id="ceda5-217">Therefore, rather than attempt to use the optimistic concurrency-enabled DAL with our existing `ProductsBLL` class, let's create a new Business Logic Layer class for working with our new DAL.</span></span>

<span data-ttu-id="ceda5-218">という名前のクラスを追加`ProductsOptimisticConcurrencyBLL`を`BLL`内のフォルダー、`App_Code`フォルダー。</span><span class="sxs-lookup"><span data-stu-id="ceda5-218">Add a class named `ProductsOptimisticConcurrencyBLL` to the `BLL` folder within the `App_Code` folder.</span></span>


![ProductsOptimisticConcurrencyBLL クラス BLL フォルダーを追加します。](implementing-optimistic-concurrency-cs/_static/image34.png)

<span data-ttu-id="ceda5-220">**図 12**: 追加、 `ProductsOptimisticConcurrencyBLL` BLL フォルダーにクラス</span><span class="sxs-lookup"><span data-stu-id="ceda5-220">**Figure 12**: Add the `ProductsOptimisticConcurrencyBLL` Class to the BLL Folder</span></span>


<span data-ttu-id="ceda5-221">次に、次のコードを追加、`ProductsOptimisticConcurrencyBLL`クラス。</span><span class="sxs-lookup"><span data-stu-id="ceda5-221">Next, add the following code to the `ProductsOptimisticConcurrencyBLL` class:</span></span>


[!code-csharp[Main](implementing-optimistic-concurrency-cs/samples/sample5.cs)]

<span data-ttu-id="ceda5-222">使用して、注意してください。`NorthwindOptimisticConcurrencyTableAdapters`クラス宣言の先頭上記のステートメント。</span><span class="sxs-lookup"><span data-stu-id="ceda5-222">Note the using `NorthwindOptimisticConcurrencyTableAdapters` statement above the start of the class declaration.</span></span> <span data-ttu-id="ceda5-223">`NorthwindOptimisticConcurrencyTableAdapters`名前空間が含まれています、`ProductsOptimisticConcurrencyTableAdapter`クラスで、DAL のメソッドを提供します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-223">The `NorthwindOptimisticConcurrencyTableAdapters` namespace contains the `ProductsOptimisticConcurrencyTableAdapter` class, which provides the DAL's methods.</span></span> <span data-ttu-id="ceda5-224">また、クラス宣言の前に見つかります、`System.ComponentModel.DataObject`属性には、Visual Studio、ObjectDataSource ウィザードのドロップダウン リストにこのクラスを含めるように指示します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-224">Also before the class declaration you'll find the `System.ComponentModel.DataObject` attribute, which instructs Visual Studio to include this class in the ObjectDataSource wizard's drop-down list.</span></span>

<span data-ttu-id="ceda5-225">`ProductsOptimisticConcurrencyBLL`の`Adapter`プロパティのインスタンスにクイック アクセスを提供、`ProductsOptimisticConcurrencyTableAdapter`クラスし、元の BLL クラスで使用されるパターンに従います (`ProductsBLL`、`CategoriesBLL`など)。</span><span class="sxs-lookup"><span data-stu-id="ceda5-225">The `ProductsOptimisticConcurrencyBLL`'s `Adapter` property provides quick access to an instance of the `ProductsOptimisticConcurrencyTableAdapter` class, and follows the pattern used in our original BLL classes (`ProductsBLL`, `CategoriesBLL`, and so on).</span></span> <span data-ttu-id="ceda5-226">最後に、`GetProducts()`メソッドを呼び出すだけです DAL の`GetProducts()`メソッドを返します、`ProductsOptimisticConcurrencyDataTable`オブジェクトを含む、`ProductsOptimisticConcurrencyRow`データベース内の各製品レコードのインスタンス。</span><span class="sxs-lookup"><span data-stu-id="ceda5-226">Finally, the `GetProducts()` method simply calls down into the DAL's `GetProducts()` method and returns a `ProductsOptimisticConcurrencyDataTable` object populated with a `ProductsOptimisticConcurrencyRow` instance for each product record in the database.</span></span>

## <a name="deleting-a-product-using-the-db-direct-pattern-with-optimistic-concurrency"></a><span data-ttu-id="ceda5-227">オプティミスティック同時実行制御で直接パターンの DB を使用して商品を削除します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-227">Deleting a Product Using the DB Direct Pattern with Optimistic Concurrency</span></span>

<span data-ttu-id="ceda5-228">オプティミスティック同時実行制御を使用する DAL に対して DB 直接パターンを使用する場合、メソッドが新しいと、元の値を渡される必要があります。</span><span class="sxs-lookup"><span data-stu-id="ceda5-228">When using the DB direct pattern against a DAL that uses optimistic concurrency, the methods must be passed the new and original values.</span></span> <span data-ttu-id="ceda5-229">削除するには、値がない新しい、ために元の値のみを渡す必要があります。</span><span class="sxs-lookup"><span data-stu-id="ceda5-229">For deleting, there are no new values, so only the original values need be passed in.</span></span> <span data-ttu-id="ceda5-230">当社の BLL にし、する必要がありますは受け付けてすべて元のパラメーターの入力パラメーターとして。</span><span class="sxs-lookup"><span data-stu-id="ceda5-230">In our BLL, then, we must accept all of the original parameters as input parameters.</span></span> <span data-ttu-id="ceda5-231">みましょうが、`DeleteProduct`メソッドで、`ProductsOptimisticConcurrencyBLL`クラスは、DB のダイレクト メソッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-231">Let's have the `DeleteProduct` method in the `ProductsOptimisticConcurrencyBLL` class use the DB direct method.</span></span> <span data-ttu-id="ceda5-232">これは、このメソッドは、すべての 10 個の製品データ フィールドの入力パラメーターとしてでは、次のコードに示すように、DAL に渡す必要があることを意味します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-232">This means that this method needs to take in all ten product data fields as input parameters, and pass these to the DAL, as shown in the following code:</span></span>


[!code-csharp[Main](implementing-optimistic-concurrency-cs/samples/sample6.cs)]

<span data-ttu-id="ceda5-233">削除ボタンをクリックしたときに、データベース内の値からの GridView、DetailsView、またはフォーム ビュー) に最後に読み込まれたこれらの値の元の値が異なる場合、`WHERE`句は、任意のデータベース レコードとレコード一致しません影響があります。</span><span class="sxs-lookup"><span data-stu-id="ceda5-233">If the original values - those values that were last loaded into the GridView (or DetailsView or FormView) - differ from the values in the database when the user clicks the Delete button the `WHERE` clause won't match up with any database record and no records will be affected.</span></span> <span data-ttu-id="ceda5-234">そのため、TableAdapter の`Delete`メソッドが返す`0`と BLL の`DeleteProduct`メソッドが返す`false`します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-234">Hence, the TableAdapter's `Delete` method will return `0` and the BLL's `DeleteProduct` method will return `false`.</span></span>

## <a name="updating-a-product-using-the-batch-update-pattern-with-optimistic-concurrency"></a><span data-ttu-id="ceda5-235">オプティミスティック同時実行制御でバッチ更新パターンを使用して製品の更新</span><span class="sxs-lookup"><span data-stu-id="ceda5-235">Updating a Product Using the Batch Update Pattern with Optimistic Concurrency</span></span>

<span data-ttu-id="ceda5-236">前に述べた、TableAdapter の`Update`バッチ更新パターンのメソッドがオプティミスティック同時実行制御が使用されているかどうかに関係なく同じメソッド シグネチャ。</span><span class="sxs-lookup"><span data-stu-id="ceda5-236">As noted earlier, the TableAdapter's `Update` method for the batch update pattern has the same method signature regardless of whether or not optimistic concurrency is employed.</span></span> <span data-ttu-id="ceda5-237">つまり、`Update`メソッドは、配列 Datarow、DataTable、または型指定されたデータセットの DataRow を想定します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-237">Namely, the `Update` method expects a DataRow, an array of DataRows, a DataTable, or a Typed DataSet.</span></span> <span data-ttu-id="ceda5-238">元の値を指定するための追加の入力パラメーターはありません。</span><span class="sxs-lookup"><span data-stu-id="ceda5-238">There are no additional input parameters for specifying the original values.</span></span> <span data-ttu-id="ceda5-239">DataTable の追跡元と変更された値をその DataRow(s) のため可能です。</span><span class="sxs-lookup"><span data-stu-id="ceda5-239">This is possible because the DataTable keeps track of the original and modified values for its DataRow(s).</span></span> <span data-ttu-id="ceda5-240">DAL を発行したとき、`UPDATE`ステートメント、`@original_ColumnName`一方、DataRow の元の値を持つパラメーターが設定されます、`@ColumnName`パラメーターには、DataRow の変更後の値が設定されます。</span><span class="sxs-lookup"><span data-stu-id="ceda5-240">When the DAL issues its `UPDATE` statement, the `@original_ColumnName` parameters are populated with the DataRow's original values, whereas the `@ColumnName` parameters are populated with the DataRow's modified values.</span></span>

<span data-ttu-id="ceda5-241">`ProductsBLL`クラス (、元の非オプティミスティック同時実行 DAL を使用) する場合は、バッチ更新パターンを使用して、コードでは、次の一連のイベントを実行します。 製品情報を更新する場合。</span><span class="sxs-lookup"><span data-stu-id="ceda5-241">In the `ProductsBLL` class (which uses our original, non-optimistic concurrency DAL), when using the batch update pattern to update product information our code performs the following sequence of events:</span></span>

1. <span data-ttu-id="ceda5-242">現在のデータベース製品情報を読み取り、 `ProductRow` TableAdapter を使用してインスタンス`GetProductByProductID(productID)`メソッド</span><span class="sxs-lookup"><span data-stu-id="ceda5-242">Read the current database product information into a `ProductRow` instance using the TableAdapter's `GetProductByProductID(productID)` method</span></span>
2. <span data-ttu-id="ceda5-243">新しい値を割り当てる、`ProductRow`手順 1. のインスタンス</span><span class="sxs-lookup"><span data-stu-id="ceda5-243">Assign the new values to the `ProductRow` instance from Step 1</span></span>
3. <span data-ttu-id="ceda5-244">呼び出す TableAdapter の`Update`に渡して、メソッド、`ProductRow`インスタンス</span><span class="sxs-lookup"><span data-stu-id="ceda5-244">Call the TableAdapter's `Update` method, passing in the `ProductRow` instance</span></span>

<span data-ttu-id="ceda5-245">この一連の手順、ただしはオプティミスティック同時実行制御をサポート正しくされなくなります、`ProductRow`で設定されますつまり、DataRow で使用される元の値に現在存在するものは、データベースから直接ステップ 1 が設定されます、。データベース、および編集のプロセスの開始時の GridView にバインドされていたものされません。</span><span class="sxs-lookup"><span data-stu-id="ceda5-245">This sequence of steps, however, won't correctly support optimistic concurrency because the `ProductRow` populated in Step 1 is populated directly from the database, meaning that the original values used by the DataRow are those that currently exist in the database, and not those that were bound to the GridView at the start of the editing process.</span></span> <span data-ttu-id="ceda5-246">代わりに、使用、オプティミスティック同時実行が有効な DAL、必要がありますを変更する、`UpdateProduct`次の手順を使用するメソッドのオーバー ロードします。</span><span class="sxs-lookup"><span data-stu-id="ceda5-246">Instead, when using an optimistic concurrency-enabled DAL, we need to alter the `UpdateProduct` method overloads to use the following steps:</span></span>

1. <span data-ttu-id="ceda5-247">現在のデータベース製品情報を読み取り、 `ProductsOptimisticConcurrencyRow` TableAdapter を使用してインスタンス`GetProductByProductID(productID)`メソッド</span><span class="sxs-lookup"><span data-stu-id="ceda5-247">Read the current database product information into a `ProductsOptimisticConcurrencyRow` instance using the TableAdapter's `GetProductByProductID(productID)` method</span></span>
2. <span data-ttu-id="ceda5-248">割り当てる、*元*値を`ProductsOptimisticConcurrencyRow`手順 1. のインスタンス</span><span class="sxs-lookup"><span data-stu-id="ceda5-248">Assign the *original* values to the `ProductsOptimisticConcurrencyRow` instance from Step 1</span></span>
3. <span data-ttu-id="ceda5-249">呼び出す、`ProductsOptimisticConcurrencyRow`インスタンスの`AcceptChanges()`メソッドは、現在の値が「元」の DataRow を指示します</span><span class="sxs-lookup"><span data-stu-id="ceda5-249">Call the `ProductsOptimisticConcurrencyRow` instance's `AcceptChanges()` method, which instructs the DataRow that its current values are the "original" ones</span></span>
4. <span data-ttu-id="ceda5-250">割り当てる、*新しい*値を`ProductsOptimisticConcurrencyRow`インスタンス</span><span class="sxs-lookup"><span data-stu-id="ceda5-250">Assign the *new* values to the `ProductsOptimisticConcurrencyRow` instance</span></span>
5. <span data-ttu-id="ceda5-251">呼び出す TableAdapter の`Update`に渡して、メソッド、`ProductsOptimisticConcurrencyRow`インスタンス</span><span class="sxs-lookup"><span data-stu-id="ceda5-251">Call the TableAdapter's `Update` method, passing in the `ProductsOptimisticConcurrencyRow` instance</span></span>

<span data-ttu-id="ceda5-252">すべてのデータベースの現在の値で指定された製品レコードの読み取りを手順 1。</span><span class="sxs-lookup"><span data-stu-id="ceda5-252">Step 1 reads in all of the current database values for the specified product record.</span></span> <span data-ttu-id="ceda5-253">この手順は不要、`UpdateProduct`を更新するオーバー ロード*すべて*製品列の (これらの値として、上書き手順 2. で)、列の値のサブセットのみとしてに渡される、これらのオーバー ロードに不可欠ですが、入力パラメーターです。</span><span class="sxs-lookup"><span data-stu-id="ceda5-253">This step is superfluous in the `UpdateProduct` overload that updates *all* of the product columns (as these values are overwritten in Step 2), but is essential for those overloads where only a subset of the column values are passed in as input parameters.</span></span> <span data-ttu-id="ceda5-254">元の値が割り当てられていると、`ProductsOptimisticConcurrencyRow`インスタンス、`AcceptChanges()`メソッドが呼び出された、DataRow の現在の値で使用される元の値としてマークする、`@original_ColumnName`内のパラメーター、`UPDATE`ステートメント。</span><span class="sxs-lookup"><span data-stu-id="ceda5-254">Once the original values have been assigned to the `ProductsOptimisticConcurrencyRow` instance, the `AcceptChanges()` method is called, which marks the current DataRow values as the original values to be used in the `@original_ColumnName` parameters in the `UPDATE` statement.</span></span> <span data-ttu-id="ceda5-255">新しいパラメーターの値が次に、割り当てられている、 `ProductsOptimisticConcurrencyRow` 、最後に、 `Update` DataRow を渡して、メソッドが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="ceda5-255">Next, the new parameter values are assigned to the `ProductsOptimisticConcurrencyRow` and, finally, the `Update` method is invoked, passing in the DataRow.</span></span>

<span data-ttu-id="ceda5-256">次のコードは、`UpdateProduct`を製品のすべてのデータを受け入れるオーバー ロードの入力パラメーターとしてのフィールドします。</span><span class="sxs-lookup"><span data-stu-id="ceda5-256">The following code shows the `UpdateProduct` overload that accepts all product data fields as input parameters.</span></span> <span data-ttu-id="ceda5-257">ここでは、表示しない、`ProductsOptimisticConcurrencyBLL`クラスにこのチュートリアルにも含まれています、ダウンロードに含まれる、`UpdateProduct`だけ、製品の名前と価格を入力パラメーターとして受け取るオーバー ロードします。</span><span class="sxs-lookup"><span data-stu-id="ceda5-257">While not shown here, the `ProductsOptimisticConcurrencyBLL` class included in the download for this tutorial also contains an `UpdateProduct` overload that accepts just the product's name and price as input parameters.</span></span>


[!code-csharp[Main](implementing-optimistic-concurrency-cs/samples/sample7.cs)]

## <a name="step-4-passing-the-original-and-new-values-from-the-aspnet-page-to-the-bll-methods"></a><span data-ttu-id="ceda5-258">手順 4: は、BLL メソッドに、ASP.NET ページから、元と新しい値を渡す</span><span class="sxs-lookup"><span data-stu-id="ceda5-258">Step 4: Passing the Original and New Values From the ASP.NET Page to the BLL Methods</span></span>

<span data-ttu-id="ceda5-259">DAL BLL 完了とは、システムに組み込まれているオプティミスティック同時実行制御ロジックを使用することができる ASP.NET ページを作成します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-259">With the DAL and BLL complete, all that remains is to create an ASP.NET page that can utilize the optimistic concurrency logic built in to the system.</span></span> <span data-ttu-id="ceda5-260">具体的には、データ Web コントロール (GridView、DetailsView、またはフォーム ビュー) では、元の値と ObjectDataSource にビジネス ロジック層の両方の値のセットを渡す必要がありますを忘れないでください。</span><span class="sxs-lookup"><span data-stu-id="ceda5-260">Specifically, the data Web control (the GridView, DetailsView, or FormView) must remember its original values and the ObjectDataSource must pass both sets of values to the Business Logic Layer.</span></span> <span data-ttu-id="ceda5-261">さらに、同時実行制御違反を適切に処理する ASP.NET ページを構成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="ceda5-261">Furthermore, the ASP.NET page must be configured to gracefully handle concurrency violations.</span></span>

<span data-ttu-id="ceda5-262">開いて開始、`OptimisticConcurrency.aspx`ページで、`EditInsertDelete`フォルダーと、デザイナーの設定への GridView の追加、`ID`プロパティを`ProductsGrid`します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-262">Start by opening the `OptimisticConcurrency.aspx` page in the `EditInsertDelete` folder and adding a GridView to the Designer, setting its `ID` property to `ProductsGrid`.</span></span> <span data-ttu-id="ceda5-263">という名前の新しい ObjectDataSource を作成することを選択、GridView のスマート タグから`ProductsOptimisticConcurrencyDataSource`します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-263">From the GridView's smart tag, opt to create a new ObjectDataSource named `ProductsOptimisticConcurrencyDataSource`.</span></span> <span data-ttu-id="ceda5-264">この ObjectDataSource オプティミスティック同時実行制御をサポートする DAL を使用するので、構成を使用するよう、`ProductsOptimisticConcurrencyBLL`オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="ceda5-264">Since we want this ObjectDataSource to use the DAL that supports optimistic concurrency, configure it to use the `ProductsOptimisticConcurrencyBLL` object.</span></span>


<span data-ttu-id="ceda5-265">[![ObjectDataSource 使用 ProductsOptimisticConcurrencyBLL オブジェクトがあります。](implementing-optimistic-concurrency-cs/_static/image36.png)](implementing-optimistic-concurrency-cs/_static/image35.png)</span><span class="sxs-lookup"><span data-stu-id="ceda5-265">[![Have the ObjectDataSource Use the ProductsOptimisticConcurrencyBLL Object](implementing-optimistic-concurrency-cs/_static/image36.png)](implementing-optimistic-concurrency-cs/_static/image35.png)</span></span>

<span data-ttu-id="ceda5-266">**図 13**: ObjectDataSource 使用している、`ProductsOptimisticConcurrencyBLL`オブジェクト ([フルサイズの画像を表示する をクリックします](implementing-optimistic-concurrency-cs/_static/image37.png))。</span><span class="sxs-lookup"><span data-stu-id="ceda5-266">**Figure 13**: Have the ObjectDataSource Use the `ProductsOptimisticConcurrencyBLL` Object ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image37.png))</span></span>


<span data-ttu-id="ceda5-267">選択、 `GetProducts`、 `UpdateProduct`、および`DeleteProduct`ウィザードで、ドロップダウン リストからメソッド。</span><span class="sxs-lookup"><span data-stu-id="ceda5-267">Choose the `GetProducts`, `UpdateProduct`, and `DeleteProduct` methods from drop-down lists in the wizard.</span></span> <span data-ttu-id="ceda5-268">UpdateProduct メソッドでは、すべての製品のデータ フィールドを受け入れるオーバー ロードを使用します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-268">For the UpdateProduct method, use the overload that accepts all of the product's data fields.</span></span>

## <a name="configuring-the-objectdatasource-controls-properties"></a><span data-ttu-id="ceda5-269">ObjectDataSource コントロールのプロパティを構成します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-269">Configuring the ObjectDataSource Control's Properties</span></span>

<span data-ttu-id="ceda5-270">ウィザードの完了後に、次のよう ObjectDataSource の宣言型マークアップになります。</span><span class="sxs-lookup"><span data-stu-id="ceda5-270">After completing the wizard, the ObjectDataSource's declarative markup should look like the following:</span></span>


[!code-aspx[Main](implementing-optimistic-concurrency-cs/samples/sample8.aspx)]

<span data-ttu-id="ceda5-271">ご覧のとおり、`DeleteParameters`コレクションに含まれる、`Parameter`で 10 個の入力パラメーターの各インスタンス、`ProductsOptimisticConcurrencyBLL`クラスの`DeleteProduct`メソッド。</span><span class="sxs-lookup"><span data-stu-id="ceda5-271">As you can see, the `DeleteParameters` collection contains a `Parameter` instance for each of the ten input parameters in the `ProductsOptimisticConcurrencyBLL` class's `DeleteProduct` method.</span></span> <span data-ttu-id="ceda5-272">同様に、`UpdateParameters`コレクションに含まれる、`Parameter`で入力パラメーターの各インスタンス`UpdateProduct`します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-272">Likewise, the `UpdateParameters` collection contains a `Parameter` instance for each of the input parameters in `UpdateProduct`.</span></span>

<span data-ttu-id="ceda5-273">ObjectDataSource を削除するところのデータの変更を関連するこれらの以前チュートリアル`OldValuesParameterFormatString`プロパティをこの時点であるため、このプロパティは、BLL メソッドが、古い (あるいは元) の値で渡されると、新しい値を期待していることを示します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-273">For those previous tutorials that involved data modification, we'd remove the ObjectDataSource's `OldValuesParameterFormatString` property at this point, since this property indicates that the BLL method expects the old (or original) values to be passed in as well as the new values.</span></span> <span data-ttu-id="ceda5-274">さらに、このプロパティの値では、元の値の入力パラメーターの名前を示します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-274">Furthermore, this property value indicates the input parameter names for the original values.</span></span> <span data-ttu-id="ceda5-275">BLL に元の値で渡される、ため*いない*このプロパティを削除します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-275">Since we are passing in the original values into the BLL, do *not* remove this property.</span></span>

> [!NOTE]
> <span data-ttu-id="ceda5-276">値、`OldValuesParameterFormatString`プロパティは、元の値を期待する BLL 内の入力パラメーター名にマップする必要があります。</span><span class="sxs-lookup"><span data-stu-id="ceda5-276">The value of the `OldValuesParameterFormatString` property must map to the input parameter names in the BLL that expect the original values.</span></span> <span data-ttu-id="ceda5-277">これらのパラメーターという名前であるため`original_productName`、`original_supplierID`で、おくことができます、`OldValuesParameterFormatString`プロパティの値として`original_{0}`。</span><span class="sxs-lookup"><span data-stu-id="ceda5-277">Since we named these parameters `original_productName`, `original_supplierID`, and so on, you can leave the `OldValuesParameterFormatString` property value as `original_{0}`.</span></span> <span data-ttu-id="ceda5-278">かどうか、ただし、BLL メソッドの入力パラメーターがのような名前`old_productName`、`old_supplierID`で、更新する必要があります、`OldValuesParameterFormatString`プロパティを`old_{0}`します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-278">If, however, the BLL methods' input parameters had names like `old_productName`, `old_supplierID`, and so on, you'd need to update the `OldValuesParameterFormatString` property to `old_{0}`.</span></span>


<span data-ttu-id="ceda5-279">BLL メソッドに元の値を正しく渡す ObjectDataSource の順序で実行する必要がある最後のプロパティ設定を 1 つがあります。</span><span class="sxs-lookup"><span data-stu-id="ceda5-279">There's one final property setting that needs to be made in order for the ObjectDataSource to correctly pass the original values to the BLL methods.</span></span> <span data-ttu-id="ceda5-280">ObjectDataSource は、 [ConflictDetection プロパティ](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.conflictdetection.aspx)に割り当てること[2 つの値のいずれかの](https://msdn.microsoft.com/library/system.web.ui.conflictoptions.aspx):</span><span class="sxs-lookup"><span data-stu-id="ceda5-280">The ObjectDataSource has a [ConflictDetection property](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.conflictdetection.aspx) that can be assigned to [one of two values](https://msdn.microsoft.com/library/system.web.ui.conflictoptions.aspx):</span></span>

- <span data-ttu-id="ceda5-281">`OverwriteChanges` -既定値です。BLL メソッドの元の入力パラメーターには、元の値を送信しません</span><span class="sxs-lookup"><span data-stu-id="ceda5-281">`OverwriteChanges` - the default value; does not send the original values to the BLL methods' original input parameters</span></span>
- <span data-ttu-id="ceda5-282">`CompareAllValues` は、BLL 方法; 元の値を送信オプティミスティック同時実行制御を使用する場合は、このオプションを選択します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-282">`CompareAllValues` - does send the original values to the BLL methods; choose this option when using optimistic concurrency</span></span>

<span data-ttu-id="ceda5-283">設定する少し、`ConflictDetection`プロパティを`CompareAllValues`します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-283">Take a moment to set the `ConflictDetection` property to `CompareAllValues`.</span></span>

## <a name="configuring-the-gridviews-properties-and-fields"></a><span data-ttu-id="ceda5-284">GridView のプロパティとパブリック フィールドを構成します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-284">Configuring the GridView's Properties and Fields</span></span>

<span data-ttu-id="ceda5-285">ObjectDataSource のプロパティが正しく構成されている、GridView の設定に注目してみましょう。</span><span class="sxs-lookup"><span data-stu-id="ceda5-285">With the ObjectDataSource's properties properly configured, let's turn our attention to setting up the GridView.</span></span> <span data-ttu-id="ceda5-286">最初に、編集および削除をサポートするために、GridView、たいので、GridView のスマート タグから、編集の有効化および削除を有効にするチェック ボックスをクリックします。</span><span class="sxs-lookup"><span data-stu-id="ceda5-286">First, since we want the GridView to support editing and deleting, click the Enable Editing and Enable Deleting checkboxes from the GridView's smart tag.</span></span> <span data-ttu-id="ceda5-287">これを [commandfield] が追加されますが`ShowEditButton`と`ShowDeleteButton`に設定されて`true`します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-287">This will add a CommandField whose `ShowEditButton` and `ShowDeleteButton` are both set to `true`.</span></span>

<span data-ttu-id="ceda5-288">バインドするとき、 `ProductsOptimisticConcurrencyDataSource` ObjectDataSource、GridView に各製品のデータ フィールドのフィールドが含まれています。</span><span class="sxs-lookup"><span data-stu-id="ceda5-288">When bound to the `ProductsOptimisticConcurrencyDataSource` ObjectDataSource, the GridView contains a field for each of the product's data fields.</span></span> <span data-ttu-id="ceda5-289">このような GridView を編集できますが、ユーザー エクスペリエンスが許容されるは。</span><span class="sxs-lookup"><span data-stu-id="ceda5-289">While such a GridView can be edited, the user experience is anything but acceptable.</span></span> <span data-ttu-id="ceda5-290">`CategoryID`と`SupplierID`BoundFields がテキスト ボックスとしてレンダリングされます ID 番号として、適切なカテゴリと仕入先を入力する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="ceda5-290">The `CategoryID` and `SupplierID` BoundFields will render as TextBoxes, requiring the user to enter the appropriate category and supplier as ID numbers.</span></span> <span data-ttu-id="ceda5-291">ありません、数値フィールドおよび製品の名前が指定されているし unit price、在庫数、順序、および並べ替えレベルの値の単位は両方の適切な数値とよりも大きいか等しいことを確認するには、いない検証コントロールの書式設定0 を返します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-291">There will be no formatting for the numeric fields and no validation controls to ensure that the product's name has been supplied and that the unit price, units in stock, units on order, and reorder level values are both proper numeric values and are greater than or equal to zero.</span></span>

<span data-ttu-id="ceda5-292">説明したように、*編集および挿入インターフェイスに検証コントロールを追加*と*データ変更インターフェイスをカスタマイズ*チュートリアルでは、ユーザー インターフェイスでカスタマイズできますTemplateFields、BoundFields で置き換えます。</span><span class="sxs-lookup"><span data-stu-id="ceda5-292">As we discussed in the *Adding Validation Controls to the Editing and Inserting Interfaces* and *Customizing the Data Modification Interface* tutorials, the user interface can be customized by replacing the BoundFields with TemplateFields.</span></span> <span data-ttu-id="ceda5-293">この GridView とその編集インターフェイスは次の方法で変更しました。</span><span class="sxs-lookup"><span data-stu-id="ceda5-293">I've modified this GridView and its editing interface in the following ways:</span></span>

- <span data-ttu-id="ceda5-294">削除、 `ProductID`、 `SupplierName`、および`CategoryName`BoundFields</span><span class="sxs-lookup"><span data-stu-id="ceda5-294">Removed the `ProductID`, `SupplierName`, and `CategoryName` BoundFields</span></span>
- <span data-ttu-id="ceda5-295">変換、 `ProductName` TemplateField に BoundField RequiredFieldValidation コントロールを追加します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-295">Converted the `ProductName` BoundField to a TemplateField and added a RequiredFieldValidation control.</span></span>
- <span data-ttu-id="ceda5-296">変換、`CategoryID`と`SupplierID`BoundFields TemplateFields に、テキスト ボックスではなく、Dropdownlist を使用して編集インターフェイスを調整します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-296">Converted the `CategoryID` and `SupplierID` BoundFields to TemplateFields, and adjusted the editing interface to use DropDownLists rather than TextBoxes.</span></span> <span data-ttu-id="ceda5-297">これらの TemplateFields' で`ItemTemplates`、`CategoryName`と`SupplierName`データ フィールドが表示されます。</span><span class="sxs-lookup"><span data-stu-id="ceda5-297">In these TemplateFields' `ItemTemplates`, the `CategoryName` and `SupplierName` data fields are displayed.</span></span>
- <span data-ttu-id="ceda5-298">変換、 `UnitPrice`、 `UnitsInStock`、 `UnitsOnOrder`、および`ReorderLevel`BoundFields TemplateFields を CompareValidator コントロールを追加します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-298">Converted the `UnitPrice`, `UnitsInStock`, `UnitsOnOrder`, and `ReorderLevel` BoundFields to TemplateFields and added CompareValidator controls.</span></span>

<span data-ttu-id="ceda5-299">前のチュートリアルでこれらのタスクを実行する方法をについて説明しました既に、ため最終的な宣言型構文を一覧表示し、プラクティスとして、実装のままにだけ行います。</span><span class="sxs-lookup"><span data-stu-id="ceda5-299">Since we've already examined how to accomplish these tasks in previous tutorials, I'll just list the final declarative syntax here and leave the implementation as practice.</span></span>


[!code-aspx[Main](implementing-optimistic-concurrency-cs/samples/sample9.aspx)]

<span data-ttu-id="ceda5-300">私たちは非常にも完全に実際の例の近くにします。</span><span class="sxs-lookup"><span data-stu-id="ceda5-300">We're very close to having a fully-working example.</span></span> <span data-ttu-id="ceda5-301">ただし、いくつかの微妙な襲ってくると、問題が発生があります。</span><span class="sxs-lookup"><span data-stu-id="ceda5-301">However, there are a few subtleties that will creep up and cause us problems.</span></span> <span data-ttu-id="ceda5-302">さらに、いくつかのインターフェイスを同時実行制御違反が発生したときに、ユーザーに警告する必要があります。</span><span class="sxs-lookup"><span data-stu-id="ceda5-302">Additionally, we still need some interface that alerts the user when a concurrency violation has occurred.</span></span>

> [!NOTE]
> <span data-ttu-id="ceda5-303">データ Web コントロールで (これは、BLL に渡されますが)、ObjectDataSource に元の値を正しく渡すには、ことが重要ですが、GridView の`EnableViewState`プロパティに設定されて`true`(既定値)。</span><span class="sxs-lookup"><span data-stu-id="ceda5-303">In order for a data Web control to correctly pass the original values to the ObjectDataSource (which are then passed to the BLL), it's vital that the GridView's `EnableViewState` property is set to `true` (the default).</span></span> <span data-ttu-id="ceda5-304">ビュー ステートを無効にした場合は、ポストバック時に元の値は失われます。</span><span class="sxs-lookup"><span data-stu-id="ceda5-304">If you disable view state, the original values are lost on postback.</span></span>


## <a name="passing-the-correct-original-values-to-the-objectdatasource"></a><span data-ttu-id="ceda5-305">ObjectDataSource に適切な元の値を渡す</span><span class="sxs-lookup"><span data-stu-id="ceda5-305">Passing the Correct Original Values to the ObjectDataSource</span></span>

<span data-ttu-id="ceda5-306">いくつかの GridView が構成されている方法で問題があります。</span><span class="sxs-lookup"><span data-stu-id="ceda5-306">There are a couple of problems with the way the GridView has been configured.</span></span> <span data-ttu-id="ceda5-307">場合 ObjectDataSource の`ConflictDetection`プロパティに設定されて`CompareAllValues`(としては渡しませんよ)、ObjectDataSource の`Update()`または`Delete()`メソッドは、GridView、DetailsView、または FormView) によって呼び出される、ObjectDataSource がコピーしようとした場合、GridView の元の値に適切な`Parameter`インスタンス。</span><span class="sxs-lookup"><span data-stu-id="ceda5-307">If the ObjectDataSource's `ConflictDetection` property is set to `CompareAllValues` (as is ours), when the ObjectDataSource's `Update()` or `Delete()` methods are invoked by the GridView (or DetailsView or FormView), the ObjectDataSource attempts to copy the GridView's original values into its appropriate `Parameter` instances.</span></span> <span data-ttu-id="ceda5-308">このプロセスのグラフィカル表現を図 2 を戻す参照します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-308">Refer back to Figure 2 for a graphical representation of this process.</span></span>

<span data-ttu-id="ceda5-309">具体的には、GridView の元の値には、毎回、データが GridView にバインドが双方向データ バインド ステートメント内の値が割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="ceda5-309">Specifically, the GridView's original values are assigned the values in the two-way databinding statements each time the data is bound to the GridView.</span></span> <span data-ttu-id="ceda5-310">そのため、双方向データ バインドを使用してすべての必要な元の値がキャプチャされる変換できる形式で提供されることを不可欠です。</span><span class="sxs-lookup"><span data-stu-id="ceda5-310">Therefore, it's essential that the required original values all are captured via two-way databinding and that they are provided in a convertible format.</span></span>

<span data-ttu-id="ceda5-311">これが重要な理由を表示するには、ブラウザーでページを参照するのにはしばらくかかります。</span><span class="sxs-lookup"><span data-stu-id="ceda5-311">To see why this is important, take a moment to visit our page in a browser.</span></span> <span data-ttu-id="ceda5-312">予想どおり、GridView には、左端の列で、編集、削除ボタンでは、各製品が一覧表示します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-312">As expected, the GridView lists each product with an Edit and Delete button in the leftmost column.</span></span>


<span data-ttu-id="ceda5-313">[![製品を GridView に表示されます。](implementing-optimistic-concurrency-cs/_static/image39.png)](implementing-optimistic-concurrency-cs/_static/image38.png)</span><span class="sxs-lookup"><span data-stu-id="ceda5-313">[![The Products are Listed in a GridView](implementing-optimistic-concurrency-cs/_static/image39.png)](implementing-optimistic-concurrency-cs/_static/image38.png)</span></span>

<span data-ttu-id="ceda5-314">**図 14**:、製品を GridView に表示される ([フルサイズの画像を表示する をクリックします](implementing-optimistic-concurrency-cs/_static/image40.png))。</span><span class="sxs-lookup"><span data-stu-id="ceda5-314">**Figure 14**: The Products are Listed in a GridView ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image40.png))</span></span>


<span data-ttu-id="ceda5-315">任意の製品の削除 ボタンをクリックした場合、`FormatException`がスローされます。</span><span class="sxs-lookup"><span data-stu-id="ceda5-315">If you click the Delete button for any product, a `FormatException` is thrown.</span></span>


<span data-ttu-id="ceda5-316">[![FormatException で、製品の結果を削除しようとしています。](implementing-optimistic-concurrency-cs/_static/image42.png)](implementing-optimistic-concurrency-cs/_static/image41.png)</span><span class="sxs-lookup"><span data-stu-id="ceda5-316">[![Attempting to Delete Any Product Results in a FormatException](implementing-optimistic-concurrency-cs/_static/image42.png)](implementing-optimistic-concurrency-cs/_static/image41.png)</span></span>

<span data-ttu-id="ceda5-317">**図 15**: で、製品の結果を削除しようとして、 `FormatException` ([フルサイズの画像を表示する をクリックします](implementing-optimistic-concurrency-cs/_static/image43.png))。</span><span class="sxs-lookup"><span data-stu-id="ceda5-317">**Figure 15**: Attempting to Delete Any Product Results in a `FormatException` ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image43.png))</span></span>


<span data-ttu-id="ceda5-318">`FormatException` ObjectDataSource が元の読み取りしようとしたときに発生`UnitPrice`値。</span><span class="sxs-lookup"><span data-stu-id="ceda5-318">The `FormatException` is raised when the ObjectDataSource attempts to read in the original `UnitPrice` value.</span></span> <span data-ttu-id="ceda5-319">以降、`ItemTemplate`が、`UnitPrice`を通貨として書式設定 (`<%# Bind("UnitPrice", "{0:C}") %>`) のような 19.95 ドルの通貨記号が含まれています。</span><span class="sxs-lookup"><span data-stu-id="ceda5-319">Since the `ItemTemplate` has the `UnitPrice` formatted as a currency (`<%# Bind("UnitPrice", "{0:C}") %>`), it includes a currency symbol, like $19.95.</span></span> <span data-ttu-id="ceda5-320">`FormatException` ObjectDataSource が、この文字列に変換しようとしています。 ときに発生する`decimal`します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-320">The `FormatException` occurs as the ObjectDataSource attempts to convert this string into a `decimal`.</span></span> <span data-ttu-id="ceda5-321">この問題を回避するためには、さまざまなオプションがあります。</span><span class="sxs-lookup"><span data-stu-id="ceda5-321">To circumvent this problem, we have a number of options:</span></span>

- <span data-ttu-id="ceda5-322">通貨の書式設定の削除、`ItemTemplate`します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-322">Remove the currency formatting from the `ItemTemplate`.</span></span> <span data-ttu-id="ceda5-323">つまり、使用する代わりに`<%# Bind("UnitPrice", "{0:C}") %>`、使用するだけで`<%# Bind("UnitPrice") %>`。</span><span class="sxs-lookup"><span data-stu-id="ceda5-323">That is, instead of using `<%# Bind("UnitPrice", "{0:C}") %>`, simply use `<%# Bind("UnitPrice") %>`.</span></span> <span data-ttu-id="ceda5-324">これの欠点は、価格の形式が不要になったことです。</span><span class="sxs-lookup"><span data-stu-id="ceda5-324">The downside of this is that the price is no longer formatted.</span></span>
- <span data-ttu-id="ceda5-325">表示、`UnitPrice`の通貨として書式設定、`ItemTemplate`が使用して、`Eval`これを実現するキーワード。</span><span class="sxs-lookup"><span data-stu-id="ceda5-325">Display the `UnitPrice` formatted as a currency in the `ItemTemplate`, but use the `Eval` keyword to accomplish this.</span></span> <span data-ttu-id="ceda5-326">いることを思い出してください`Eval`一方向のデータ バインドを実行します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-326">Recall that `Eval` performs one-way databinding.</span></span> <span data-ttu-id="ceda5-327">提供する必要があります、`UnitPrice`で双方向データ バインド ステートメントが必要も、元の値の値、 `ItemTemplate`、これに配置できるラベル Web コントロールを持つが、`Visible`プロパティに設定されて`false`します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-327">We still need to provide the `UnitPrice` value for the original values, so we'll still need a two-way databinding statement in the `ItemTemplate`, but this can be placed in a Label Web control whose `Visible` property is set to `false`.</span></span> <span data-ttu-id="ceda5-328">次のマークアップを ItemTemplate に使用できます。</span><span class="sxs-lookup"><span data-stu-id="ceda5-328">We could use the following markup in the ItemTemplate:</span></span>


[!code-aspx[Main](implementing-optimistic-concurrency-cs/samples/sample10.aspx)]

- <span data-ttu-id="ceda5-329">通貨の書式設定の削除、`ItemTemplate`を使用して、`<%# Bind("UnitPrice") %>`します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-329">Remove the currency formatting from the `ItemTemplate`, using `<%# Bind("UnitPrice") %>`.</span></span> <span data-ttu-id="ceda5-330">Gridview の`RowDataBound`ラベル Web コントロールを内のイベント ハンドラー、プログラムでアクセス、`UnitPrice`値が表示され、設定、`Text`プロパティを書式設定されたバージョン。</span><span class="sxs-lookup"><span data-stu-id="ceda5-330">In the GridView's `RowDataBound` event handler, programmatically access the Label Web control within which the `UnitPrice` value is displayed and set its `Text` property to the formatted version.</span></span>
- <span data-ttu-id="ceda5-331">ままに、`UnitPrice`を通貨として書式設定します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-331">Leave the `UnitPrice` formatted as a currency.</span></span> <span data-ttu-id="ceda5-332">Gridview の`RowDeleting`イベント ハンドラーでは、元の既存の置換`UnitPrice`値 (19.95 ドル) を使用して、実際の 10 進値で`Decimal.Parse`します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-332">In the GridView's `RowDeleting` event handler, replace the existing original `UnitPrice` value ($19.95) with an actual decimal value using `Decimal.Parse`.</span></span> <span data-ttu-id="ceda5-333">ようなものを実現する方法を説明しました、`RowUpdating`内のイベント ハンドラー、 [*処理 BLL - と DAL レベルの例外で、ASP.NET ページ*](handling-bll-and-dal-level-exceptions-in-an-asp-net-page-cs.md)チュートリアル。</span><span class="sxs-lookup"><span data-stu-id="ceda5-333">We saw how to accomplish something similar in the `RowUpdating` event handler in the [*Handling BLL- and DAL-Level Exceptions in an ASP.NET Page*](handling-bll-and-dal-level-exceptions-in-an-asp-net-page-cs.md) tutorial.</span></span>

<span data-ttu-id="ceda5-334">2 番目のアプローチを使用した例いるラベル Web を非表示を追加するコントロール`Text`プロパティは、書式設定されていないにバインドされた双方向データ`UnitPrice`値。</span><span class="sxs-lookup"><span data-stu-id="ceda5-334">For my example I chose to go with the second approach, adding a hidden Label Web control whose `Text` property is two-way data bound to the unformatted `UnitPrice` value.</span></span>

<span data-ttu-id="ceda5-335">この問題を解決するには、製品の削除 ボタンをもう一度クリックしてください。</span><span class="sxs-lookup"><span data-stu-id="ceda5-335">After solving this problem, try clicking the Delete button for any product again.</span></span> <span data-ttu-id="ceda5-336">この時間が表示されます、 `InvalidOperationException` ObjectDataSource が BLL の呼び出しを試行するときに`UpdateProduct`メソッド。</span><span class="sxs-lookup"><span data-stu-id="ceda5-336">This time you'll get an `InvalidOperationException` when the ObjectDataSource attempts to invoke the BLL's `UpdateProduct` method.</span></span>


<span data-ttu-id="ceda5-337">[![ObjectDataSource は、送信する入力パラメーターを持つメソッドを見つけることができません。](implementing-optimistic-concurrency-cs/_static/image45.png)](implementing-optimistic-concurrency-cs/_static/image44.png)</span><span class="sxs-lookup"><span data-stu-id="ceda5-337">[![The ObjectDataSource Cannot Find a Method with the Input Parameters it Wants to Send](implementing-optimistic-concurrency-cs/_static/image45.png)](implementing-optimistic-concurrency-cs/_static/image44.png)</span></span>

<span data-ttu-id="ceda5-338">**図 16**: ObjectDataSource は、送信する入力パラメーターを持つメソッドを見つけることができません ([フルサイズの画像を表示する をクリックします](implementing-optimistic-concurrency-cs/_static/image46.png))。</span><span class="sxs-lookup"><span data-stu-id="ceda5-338">**Figure 16**: The ObjectDataSource Cannot Find a Method with the Input Parameters it Wants to Send ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image46.png))</span></span>


<span data-ttu-id="ceda5-339">例外のメッセージを見ると、明確では、ObjectDataSource、BLL を起動する必要のある`DeleteProduct`メソッドが含まれる`original_CategoryName`と`original_SupplierName`パラメーターを入力します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-339">Looking at the exception's message, it's clear that the ObjectDataSource wants to invoke a BLL `DeleteProduct` method that includes `original_CategoryName` and `original_SupplierName` input parameters.</span></span> <span data-ttu-id="ceda5-340">これは、ため、`ItemTemplate`の`CategoryID`と`SupplierID`TemplateFields が現在の双方向のバインド ステートメントを含めることが、`CategoryName`と`SupplierName`データ フィールド。</span><span class="sxs-lookup"><span data-stu-id="ceda5-340">This is because the `ItemTemplate` s for the `CategoryID` and `SupplierID` TemplateFields currently contain two-way Bind statements with the `CategoryName` and `SupplierName` data fields.</span></span> <span data-ttu-id="ceda5-341">代わりに、含める必要があります`Bind`ステートメントと、`CategoryID`と`SupplierID`データ フィールド。</span><span class="sxs-lookup"><span data-stu-id="ceda5-341">Instead, we need to include `Bind` statements with the `CategoryID` and `SupplierID` data fields.</span></span> <span data-ttu-id="ceda5-342">これを実現するには、既存のバインド ステートメントを置き換えます`Eval`ステートメントを追加し、非表示のラベル コントロールが`Text`プロパティにバインドされます、`CategoryID`と`SupplierID`に示すように、双方向データ バインドを使用してデータ フィールド以下に：</span><span class="sxs-lookup"><span data-stu-id="ceda5-342">To accomplish this, replace the existing Bind statements with `Eval` statements, and then add hidden Label controls whose `Text` properties are bound to the `CategoryID` and `SupplierID` data fields using two-way databinding, as shown below:</span></span>


[!code-aspx[Main](implementing-optimistic-concurrency-cs/samples/sample11.aspx)]

<span data-ttu-id="ceda5-343">これらの変更が正常に削除し、製品情報を編集することがようになりました。</span><span class="sxs-lookup"><span data-stu-id="ceda5-343">With these changes, we are now able to successfully delete and edit product information!</span></span> <span data-ttu-id="ceda5-344">手順 5 では、同時実行制御違反が検出されていることを確認する方法を紹介します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-344">In Step 5 we'll look at how to verify that concurrency violations are being detected.</span></span> <span data-ttu-id="ceda5-345">ここでは、数分を更新してみてくださいいて、期待どおりに動作を更新して、1 人のユーザーを削除することを確認するいくつかのレコードを削除しています。</span><span class="sxs-lookup"><span data-stu-id="ceda5-345">But for now, take a few minutes to try updating and deleting a few records to ensure that updating and deleting for a single user works as expected.</span></span>

## <a name="step-5-testing-the-optimistic-concurrency-support"></a><span data-ttu-id="ceda5-346">手順 5: オプティミスティック同時実行制御のサポートをテストします。</span><span class="sxs-lookup"><span data-stu-id="ceda5-346">Step 5: Testing the Optimistic Concurrency Support</span></span>

<span data-ttu-id="ceda5-347">同時実行制御違反が検出された (なく無条件に上書きされないデータの結果として得られる) されていることを確認するためには、このページに 2 つのブラウザー ウィンドウを開く必要があります。</span><span class="sxs-lookup"><span data-stu-id="ceda5-347">In order to verify that concurrency violations are being detected (rather than resulting in data being blindly overwritten), we need to open two browser windows to this page.</span></span> <span data-ttu-id="ceda5-348">両方のブラウザー インスタンス Chai の編集 ボタンをクリックします。</span><span class="sxs-lookup"><span data-stu-id="ceda5-348">In both browser instances, click on the Edit button for Chai.</span></span> <span data-ttu-id="ceda5-349">だけのいずれかで、ブラウザー、「Chai 紅茶」に名前を変更し、[更新] をクリックします。</span><span class="sxs-lookup"><span data-stu-id="ceda5-349">Then, in just one of the browsers, change the name to "Chai Tea" and click Update.</span></span> <span data-ttu-id="ceda5-350">更新プログラムが成功し、GridView を新しい製品名として「Chai 紅茶」で、編集済み状態に戻す必要があります。</span><span class="sxs-lookup"><span data-stu-id="ceda5-350">The update should succeed and return the GridView to its pre-editing state, with "Chai Tea" as the new product name.</span></span>

<span data-ttu-id="ceda5-351">その他のブラウザー ウィンドウ インスタンスでただし、製品名 TextBox であっても、"Chai"。</span><span class="sxs-lookup"><span data-stu-id="ceda5-351">In the other browser window instance, however, the product name TextBox still shows "Chai".</span></span> <span data-ttu-id="ceda5-352">この 2 番目のブラウザー ウィンドウでは、更新、`UnitPrice`に`25.00`します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-352">In this second browser window, update the `UnitPrice` to `25.00`.</span></span> <span data-ttu-id="ceda5-353">オプティミスティック同時実行制御のサポートがない場合、2 番目のブラウザー インスタンスでの更新 をクリックしては、製品名を変更"Chai"、最初のブラウザー インスタンスによって行われた変更が上書きされます。</span><span class="sxs-lookup"><span data-stu-id="ceda5-353">Without optimistic concurrency support, clicking update in the second browser instance would change the product name back to "Chai", thereby overwriting the changes made by the first browser instance.</span></span> <span data-ttu-id="ceda5-354">採用されているオプティミスティック同時実行制御、ただし、2 番目のブラウザー インスタンスでの更新ボタンをクリックすると結果を[DBConcurrencyException](https://msdn.microsoft.com/library/system.data.dbconcurrencyexception.aspx)します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-354">With optimistic concurrency employed, however, clicking the Update button in the second browser instance results in a [DBConcurrencyException](https://msdn.microsoft.com/library/system.data.dbconcurrencyexception.aspx).</span></span>


<span data-ttu-id="ceda5-355">[![同時実行制御違反が検出されると、DBConcurrencyException がスローされます。](implementing-optimistic-concurrency-cs/_static/image48.png)](implementing-optimistic-concurrency-cs/_static/image47.png)</span><span class="sxs-lookup"><span data-stu-id="ceda5-355">[![When a Concurrency Violation is Detected, a DBConcurrencyException is Thrown](implementing-optimistic-concurrency-cs/_static/image48.png)](implementing-optimistic-concurrency-cs/_static/image47.png)</span></span>

<span data-ttu-id="ceda5-356">**図 17**: ときの同時実行制御違反が検出されると、`DBConcurrencyException`がスローされます ([フルサイズの画像を表示する をクリックします](implementing-optimistic-concurrency-cs/_static/image49.png))。</span><span class="sxs-lookup"><span data-stu-id="ceda5-356">**Figure 17**: When a Concurrency Violation is Detected, a `DBConcurrencyException` is Thrown ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image49.png))</span></span>


<span data-ttu-id="ceda5-357">`DBConcurrencyException` DAL のバッチ更新パターンを利用する際にのみスローされます。</span><span class="sxs-lookup"><span data-stu-id="ceda5-357">The `DBConcurrencyException` is only thrown when the DAL's batch update pattern is utilized.</span></span> <span data-ttu-id="ceda5-358">DB 直接パターンが例外を発生させない、影響を受けた行がないことだけを示します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-358">The DB direct pattern does not raise an exception, it merely indicates that no rows were affected.</span></span> <span data-ttu-id="ceda5-359">これを示すためには、編集済みの状態に両方のブラウザー インスタンスの GridView を返します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-359">To illustrate this, return both browser instances' GridView to their pre-editing state.</span></span> <span data-ttu-id="ceda5-360">次に、最初のブラウザー インスタンスで編集ボタンをクリックし、"Chai"には、「Chai 紅茶」から製品名を変更する更新をクリックします。</span><span class="sxs-lookup"><span data-stu-id="ceda5-360">Next, in the first browser instance, click the Edit button and change the product name from "Chai Tea" back to "Chai" and click Update.</span></span> <span data-ttu-id="ceda5-361">2 番目のブラウザー ウィンドウでは、Chai の削除 ボタンをクリックします。</span><span class="sxs-lookup"><span data-stu-id="ceda5-361">In the second browser window, click the Delete button for Chai.</span></span>

<span data-ttu-id="ceda5-362">削除をクリックすると、ページがポストバック、GridView 呼び出す ObjectDataSource の`Delete()`メソッド、および、ObjectDataSource 呼び出して、`ProductsOptimisticConcurrencyBLL`クラスの`DeleteProduct`メソッド、元の値を渡します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-362">Upon clicking Delete, the page posts back, the GridView invokes the ObjectDataSource's `Delete()` method, and the ObjectDataSource calls down into the `ProductsOptimisticConcurrencyBLL` class's `DeleteProduct` method, passing along the original values.</span></span> <span data-ttu-id="ceda5-363">元の`ProductName`「Chai 紅茶」現在と一致しません。 これは、2 番目のブラウザー インスタンスを値`ProductName`データベース内の値。</span><span class="sxs-lookup"><span data-stu-id="ceda5-363">The original `ProductName` value for the second browser instance is "Chai Tea", which doesn't match up with the current `ProductName` value in the database.</span></span> <span data-ttu-id="ceda5-364">そのため、`DELETE`データベースにレコードがないため、データベースへの発行ステートメントが 0 の行に影響する、`WHERE`句を満たします。</span><span class="sxs-lookup"><span data-stu-id="ceda5-364">Therefore the `DELETE` statement issued to the database affects zero rows since there's no record in the database that the `WHERE` clause satisfies.</span></span> <span data-ttu-id="ceda5-365">`DeleteProduct`メソッドを返します。 `false` ObjectDataSource のデータが GridView にバインドするとします。</span><span class="sxs-lookup"><span data-stu-id="ceda5-365">The `DeleteProduct` method returns `false` and the ObjectDataSource's data is rebound to the GridView.</span></span>

<span data-ttu-id="ceda5-366">エンドユーザーの観点からフラッシュをスクリーンの原因と 2 番目のブラウザー ウィンドウで Chai 紅茶の削除 ボタンをクリックするとに戻るには、製品は問題がないが、"Chai"(製品名行われた変更が最初のブラウザーでとして記載されているようになりましたインスタンスの場合)。</span><span class="sxs-lookup"><span data-stu-id="ceda5-366">From the end user's perspective, clicking on the Delete button for Chai Tea in the second browser window caused the screen to flash and, upon coming back, the product is still there, although now it's listed as "Chai" (the product name change made by the first browser instance).</span></span> <span data-ttu-id="ceda5-367">ユーザーでは、もう一度削除 ボタンがクリックした場合、削除は成功、GridView の元として`ProductName`値 ("Chai") ようになりましたが一致する、データベース内の値。</span><span class="sxs-lookup"><span data-stu-id="ceda5-367">If the user clicks the Delete button again, the Delete will succeed, as the GridView's original `ProductName` value ("Chai") now matches up with the value in the database.</span></span>

<span data-ttu-id="ceda5-368">どちらのこのような場合、ユーザー操作は理想から遠く離れたです。</span><span class="sxs-lookup"><span data-stu-id="ceda5-368">In both of these cases, the user experience is far from ideal.</span></span> <span data-ttu-id="ceda5-369">ユーザーの具体的な説明を表示する明らかにしたくない、`DBConcurrencyException`バッチ更新パターンを使用する場合は例外です。</span><span class="sxs-lookup"><span data-stu-id="ceda5-369">We clearly don't want to show the user the nitty-gritty details of the `DBConcurrencyException` exception when using the batch update pattern.</span></span> <span data-ttu-id="ceda5-370">ユーザー コマンドが失敗しましたが、正確な理由を示す値がありませんでした。 は、DB 直接パターンを使用するときの動作は少し紛らわしいです。</span><span class="sxs-lookup"><span data-stu-id="ceda5-370">And the behavior when using the DB direct pattern is somewhat confusing as the users command failed, but there was no precise indication of why.</span></span>

<span data-ttu-id="ceda5-371">これら 2 つの問題を解決するには、更新または削除の失敗理由を説明するページ ラベル Web コントロールを作成できます。</span><span class="sxs-lookup"><span data-stu-id="ceda5-371">To remedy these two issues, we can create Label Web controls on the page that provide an explanation to why an update or delete failed.</span></span> <span data-ttu-id="ceda5-372">バッチ更新パターンを確認できるかどうかを`DBConcurrencyException`必要に応じて、警告のラベルを表示する GridView の後のレベルのイベント ハンドラーで例外が発生しました。</span><span class="sxs-lookup"><span data-stu-id="ceda5-372">For the batch update pattern, we can determine whether or not a `DBConcurrencyException` exception occurred in the GridView's post-level event handler, displaying the warning label as needed.</span></span> <span data-ttu-id="ceda5-373">DB のダイレクト メソッドは、BLL メソッドの戻り値を確認できます (これは`true`1 つの行が影響を受ける場合`false`それ以外の場合) し、必要に応じて情報メッセージを表示します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-373">For the DB direct method, we can examine the return value of the BLL method (which is `true` if one row was affected, `false` otherwise) and display an informational message as needed.</span></span>

## <a name="step-6-adding-informational-messages-and-displaying-them-in-the-face-of-a-concurrency-violation"></a><span data-ttu-id="ceda5-374">手順 6: は情報メッセージを追加して、同時実行制御違反が発生した場合に表示する方法</span><span class="sxs-lookup"><span data-stu-id="ceda5-374">Step 6: Adding Informational Messages and Displaying Them in the Face of a Concurrency Violation</span></span>

<span data-ttu-id="ceda5-375">同時実行制御違反が発生したときに発生した現象は、DAL のバッチ更新または DB 直接パターンが使用されるかどうかに依存します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-375">When a concurrency violation occurs, the behavior exhibited depends on whether the DAL's batch update or DB direct pattern was used.</span></span> <span data-ttu-id="ceda5-376">このチュートリアルでは、更新および削除するために使用される DB 直接パターンで使用されているバッチ更新パターンでは、両方のパターンを使用します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-376">Our tutorial uses both patterns, with the batch update pattern being used for updating and the DB direct pattern used for deleting.</span></span> <span data-ttu-id="ceda5-377">開始するには、削除、またはデータを更新しようとしてください。 同時実行制御違反が発生したことを説明するページに 2 つのラベルの Web コントロールを追加してみましょう。</span><span class="sxs-lookup"><span data-stu-id="ceda5-377">To get started, let's add two Label Web controls to our page that explain that a concurrency violation occurred when attempting to delete or update data.</span></span> <span data-ttu-id="ceda5-378">ラベル コントロールの設定`Visible`と`EnableViewState`プロパティ`false`; これにより、それらの特定のページにアクセス where 点を除いて、各ページのアクセス時に非表示にする、`Visible`プロパティ プログラムで`true`します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-378">Set the Label control's `Visible` and `EnableViewState` properties to `false`; this will cause them to be hidden on each page visit except for those particular page visits where their `Visible` property is programmatically set to `true`.</span></span>


[!code-aspx[Main](implementing-optimistic-concurrency-cs/samples/sample12.aspx)]

<span data-ttu-id="ceda5-379">設定だけでなく、 `Visible`、`EnabledViewState`と`Text`プロパティも設定した、`CssClass`プロパティを`Warning`、大規模な赤、斜体、太字のフォントで表示されるのラベルを停止します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-379">In addition to setting their `Visible`, `EnabledViewState`, and `Text` properties, I've also set the `CssClass` property to `Warning`, which causes the Label's to be displayed in a large, red, italic, bold font.</span></span> <span data-ttu-id="ceda5-380">この CSS`Warning`クラスが定義され、Styles.css に追加されたに戻り、 *、イベントに関連付けられている挿入、更新、および削除の確認*チュートリアル。</span><span class="sxs-lookup"><span data-stu-id="ceda5-380">This CSS `Warning` class was defined and added to Styles.css back in the *Examining the Events Associated with Inserting, Updating, and Deleting* tutorial.</span></span>

<span data-ttu-id="ceda5-381">これらのラベルを追加すると、Visual Studio のデザイナーがこのよう図 18 になります。</span><span class="sxs-lookup"><span data-stu-id="ceda5-381">After adding these Labels, the Designer in Visual Studio should look similar to Figure 18.</span></span>


<span data-ttu-id="ceda5-382">[![2 つのラベル コントロールがページに追加されました](implementing-optimistic-concurrency-cs/_static/image51.png)](implementing-optimistic-concurrency-cs/_static/image50.png)</span><span class="sxs-lookup"><span data-stu-id="ceda5-382">[![Two Label Controls Have Been Added to the Page](implementing-optimistic-concurrency-cs/_static/image51.png)](implementing-optimistic-concurrency-cs/_static/image50.png)</span></span>

<span data-ttu-id="ceda5-383">**図 18**: 2 つのラベル コントロールに追加されたページ ([フルサイズの画像を表示する をクリックします](implementing-optimistic-concurrency-cs/_static/image52.png))。</span><span class="sxs-lookup"><span data-stu-id="ceda5-383">**Figure 18**: Two Label Controls Have Been Added to the Page ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image52.png))</span></span>


<span data-ttu-id="ceda5-384">場所でこれらのラベルの Web コントロール、私たちは同時実行制御違反が発生した場合、ポイントの適切なラベルの位置を決定する方法を詳しく調べる準備が`Visible`にプロパティを設定することができます`true`、情報メッセージを表示します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-384">With these Label Web controls in place, we're ready to examine how to determine when a concurrency violation has occurred, at which point the appropriate Label's `Visible` property can be set to `true`, displaying the informational message.</span></span>

## <a name="handling-concurrency-violations-when-updating"></a><span data-ttu-id="ceda5-385">更新するときに、同時実行制御違反を処理</span><span class="sxs-lookup"><span data-stu-id="ceda5-385">Handling Concurrency Violations When Updating</span></span>

<span data-ttu-id="ceda5-386">まず、バッチ更新パターンを使用する場合は、同時実行制御違反を処理する方法を見てみましょう。</span><span class="sxs-lookup"><span data-stu-id="ceda5-386">Let's first look at how to handle concurrency violations when using the batch update pattern.</span></span> <span data-ttu-id="ceda5-387">バッチには、このような違反のパターンの原因を更新するため、`DBConcurrencyException`例外がスローされる、ASP.NET ページを決定するコードを追加する必要があるかどうかを`DBConcurrencyException`更新プロセス中に例外が発生しました。</span><span class="sxs-lookup"><span data-stu-id="ceda5-387">Since such violations with the batch update pattern cause a `DBConcurrencyException` exception to be thrown, we need to add code to our ASP.NET page to determine whether a `DBConcurrencyException` exception occurred during the update process.</span></span> <span data-ttu-id="ceda5-388">そのため、レコードの編集を開始するときに、別のユーザーの間で同じデータが変更するため、その変更は保存されませんでしたが説明するユーザーにメッセージを表示する必要があり、それらの更新ボタンがクリックされたときにします。</span><span class="sxs-lookup"><span data-stu-id="ceda5-388">If so, we should display a message to the user explaining that their changes were not saved because another user had modified the same data between when they started editing the record and when they clicked the Update button.</span></span>

<span data-ttu-id="ceda5-389">説明したように、*処理 BLL - と DAL レベルの例外で、ASP.NET ページ*チュートリアルで、このような例外を検出およびデータ Web コントロールの後のレベルのイベント ハンドラーで抑制できます。</span><span class="sxs-lookup"><span data-stu-id="ceda5-389">As we saw in the *Handling BLL- and DAL-Level Exceptions in an ASP.NET Page* tutorial, such exceptions can be detected and suppressed in the data Web control's post-level event handlers.</span></span> <span data-ttu-id="ceda5-390">そのため、GridView のイベント ハンドラーを作成する必要があります`RowUpdated`場合にチェックするイベントを`DBConcurrencyException`例外がスローされました。</span><span class="sxs-lookup"><span data-stu-id="ceda5-390">Therefore, we need to create an event handler for the GridView's `RowUpdated` event that checks if a `DBConcurrencyException` exception has been thrown.</span></span> <span data-ttu-id="ceda5-391">このイベント ハンドラーには、イベント ハンドラーは、以下のコードに示すように更新の処理中に発生したすべての例外への参照が渡されます。</span><span class="sxs-lookup"><span data-stu-id="ceda5-391">This event handler is passed a reference to any exception that was raised during the updating process, as shown in the event handler code below:</span></span>


[!code-csharp[Main](implementing-optimistic-concurrency-cs/samples/sample13.cs)]

<span data-ttu-id="ceda5-392">`DBConcurrencyException`例外では、このイベント ハンドラーの表示、`UpdateConflictMessage`コントロールのラベルし、例外が処理されたことを示します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-392">In the face of a `DBConcurrencyException` exception, this event handler displays the `UpdateConflictMessage` Label control and indicates that the exception has been handled.</span></span> <span data-ttu-id="ceda5-393">場所でこのコードでは、レコードを更新するときに、同時実行制御違反が発生した場合、ユーザーの変更は失われます、ため、同時に別のユーザーの変更が上書きされるとします。</span><span class="sxs-lookup"><span data-stu-id="ceda5-393">With this code in place, when a concurrency violation occurs when updating a record, the user's changes are lost, since they would have overwritten another user's modifications at the same time.</span></span> <span data-ttu-id="ceda5-394">具体的には、GridView が編集済みの状態に返され、現在のデータベースのデータにバインドします。</span><span class="sxs-lookup"><span data-stu-id="ceda5-394">In particular, the GridView is returned to its pre-editing state and bound to the current database data.</span></span> <span data-ttu-id="ceda5-395">これにより、他のユーザーの変更により、以前は表示されませんでした、GridView の行が更新されます。</span><span class="sxs-lookup"><span data-stu-id="ceda5-395">This will update the GridView row with the other user's changes, which were previously not visible.</span></span> <span data-ttu-id="ceda5-396">さらに、`UpdateConflictMessage`ラベル コントロールをユーザーに説明が発生します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-396">Additionally, the `UpdateConflictMessage` Label control will explain to the user what just happened.</span></span> <span data-ttu-id="ceda5-397">このイベントのシーケンス図 19 の詳細を示します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-397">This sequence of events is detailed in Figure 19.</span></span>


<span data-ttu-id="ceda5-398">[![ユーザーの更新プログラムは、同時実行制御違反の表面に失われます](implementing-optimistic-concurrency-cs/_static/image54.png)](implementing-optimistic-concurrency-cs/_static/image53.png)</span><span class="sxs-lookup"><span data-stu-id="ceda5-398">[![A User s Updates are Lost in the Face of a Concurrency Violation](implementing-optimistic-concurrency-cs/_static/image54.png)](implementing-optimistic-concurrency-cs/_static/image53.png)</span></span>

<span data-ttu-id="ceda5-399">**図 19**: A のユーザーの更新プログラムは、同時実行制御違反の表面に失われます ([フルサイズの画像を表示する をクリックします](implementing-optimistic-concurrency-cs/_static/image55.png))。</span><span class="sxs-lookup"><span data-stu-id="ceda5-399">**Figure 19**: A User s Updates are Lost in the Face of a Concurrency Violation ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image55.png))</span></span>


> [!NOTE]
> <span data-ttu-id="ceda5-400">または、GridView 編集済みの状態に返すときではなく残る可能性があります、GridView の編集状態で設定して、`KeepInEditMode`プロパティの渡されたで`GridViewUpdatedEventArgs`オブジェクトを true にします。</span><span class="sxs-lookup"><span data-stu-id="ceda5-400">Alternatively, rather than returning the GridView to the pre-editing state, we could leave the GridView in its editing state by setting the `KeepInEditMode` property of the passed-in `GridViewUpdatedEventArgs` object to true.</span></span> <span data-ttu-id="ceda5-401">この方法で実行する場合、必ず GridView にデータを再バインドする (呼び出すことによってその`DataBind()`メソッド)、その他のユーザーの値が編集インターフェイスに読み込まれるようにします。</span><span class="sxs-lookup"><span data-stu-id="ceda5-401">If you take this approach, however, be certain to rebind the data to the GridView (by invoking its `DataBind()` method) so that the other user's values are loaded into the editing interface.</span></span> <span data-ttu-id="ceda5-402">このチュートリアルでダウンロード可能なコードが次の 2 行のコードの`RowUpdated`イベント ハンドラーがコメント アウトされています。 同時実行制御違反の後に、次の行のコードに、GridView が編集モードのままのコメントを解除だけです。</span><span class="sxs-lookup"><span data-stu-id="ceda5-402">The code available for download with this tutorial has these two lines of code in the `RowUpdated` event handler commented out; simply uncomment these lines of code to have the GridView remain in edit mode after a concurrency violation.</span></span>


## <a name="responding-to-concurrency-violations-when-deleting"></a><span data-ttu-id="ceda5-403">削除するときに、同時実行制御違反への応答</span><span class="sxs-lookup"><span data-stu-id="ceda5-403">Responding to Concurrency Violations When Deleting</span></span>

<span data-ttu-id="ceda5-404">DB の直接パターンでは、同時実行制御違反が発生した場合に発生する例外はありません。</span><span class="sxs-lookup"><span data-stu-id="ceda5-404">With the DB direct pattern, there is no exception raised in the face of a concurrency violation.</span></span> <span data-ttu-id="ceda5-405">代わりに、データベース ステートメントだけが影響を受けないレコードを WHERE 句は、任意のレコードと一致しません。</span><span class="sxs-lookup"><span data-stu-id="ceda5-405">Instead, the database statement simply affects no records, as the WHERE clause does not match with any record.</span></span> <span data-ttu-id="ceda5-406">BLL で作成したデータ変更メソッドのすべては、正確に 1 つのレコードが影響を受けるかどうかを示すブール値を返すように設計されています。</span><span class="sxs-lookup"><span data-stu-id="ceda5-406">All of the data modification methods created in the BLL have been designed such that they return a Boolean value indicating whether or not they affected precisely one record.</span></span> <span data-ttu-id="ceda5-407">そのため、レコードを削除するときに、同時実行制御違反が発生したかどうかを判断することができますを考察 BLL の戻り値`DeleteProduct`メソッド。</span><span class="sxs-lookup"><span data-stu-id="ceda5-407">Therefore, to determine if a concurrency violation occurred when deleting a record, we can examine the return value of the BLL's `DeleteProduct` method.</span></span>

<span data-ttu-id="ceda5-408">BLL メソッドの戻り値を通じて ObjectDataSource の後のレベルのイベント ハンドラーで調べることができます、`ReturnValue`のプロパティ、`ObjectDataSourceStatusEventArgs`イベント ハンドラーに渡されるオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="ceda5-408">The return value for a BLL method can be examined in the ObjectDataSource's post-level event handlers through the `ReturnValue` property of the `ObjectDataSourceStatusEventArgs` object passed into the event handler.</span></span> <span data-ttu-id="ceda5-409">戻り値を決定する必要があるので、`DeleteProduct`メソッド、ObjectDataSource のイベント ハンドラーを作成する必要があります`Deleted`イベント。</span><span class="sxs-lookup"><span data-stu-id="ceda5-409">Since we are interested in determining the return value from the `DeleteProduct` method, we need to create an event handler for the ObjectDataSource's `Deleted` event.</span></span> <span data-ttu-id="ceda5-410">`ReturnValue`プロパティの型は`object`でき、`null`例外が発生したかどうかと、値を返す前に、メソッドは中断されました。</span><span class="sxs-lookup"><span data-stu-id="ceda5-410">The `ReturnValue` property is of type `object` and can be `null` if an exception was raised and the method was interrupted before it could return a value.</span></span> <span data-ttu-id="ceda5-411">そのため、私たちが最初いることを確認、`ReturnValue`プロパティは`null`ブール値です。</span><span class="sxs-lookup"><span data-stu-id="ceda5-411">Therefore, we should first ensure that the `ReturnValue` property is not `null` and is a Boolean value.</span></span> <span data-ttu-id="ceda5-412">このチェックに合格紹介と仮定すると、`DeleteConflictMessage`ラベル コントロールの場合、`ReturnValue`は`false`します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-412">Assuming this check passes, we show the `DeleteConflictMessage` Label control if the `ReturnValue` is `false`.</span></span> <span data-ttu-id="ceda5-413">これは、次のコードを使用して実行できます。</span><span class="sxs-lookup"><span data-stu-id="ceda5-413">This can be accomplished by using the following code:</span></span>


[!code-csharp[Main](implementing-optimistic-concurrency-cs/samples/sample14.cs)]

<span data-ttu-id="ceda5-414">同時実行違反が発生した場合、ユーザーの削除要求が取り消されました。</span><span class="sxs-lookup"><span data-stu-id="ceda5-414">In the face of a concurrency violation, the user's delete request is canceled.</span></span> <span data-ttu-id="ceda5-415">ページと Delete ボタンをクリックしたときに彼に読み込まれるまでの間には、そのレコードのユーザーに発生した変更を示す GridView が更新されます。</span><span class="sxs-lookup"><span data-stu-id="ceda5-415">The GridView is refreshed, showing the changes that occurred for that record between the time the user loaded the page and when he clicked the Delete button.</span></span> <span data-ttu-id="ceda5-416">このような違反には、ときに、`DeleteConflictMessage`ラベルが表示されるだけです (図 20 を参照してください) の変更点について説明します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-416">When such a violation transpires, the `DeleteConflictMessage` Label is shown, explaining what just happened (see Figure 20).</span></span>


<span data-ttu-id="ceda5-417">[![同時実行制御違反が発生した場合、ユーザーの削除が取り消されました](implementing-optimistic-concurrency-cs/_static/image57.png)](implementing-optimistic-concurrency-cs/_static/image56.png)</span><span class="sxs-lookup"><span data-stu-id="ceda5-417">[![A User s Delete is Canceled in the Face of a Concurrency Violation](implementing-optimistic-concurrency-cs/_static/image57.png)](implementing-optimistic-concurrency-cs/_static/image56.png)</span></span>

<span data-ttu-id="ceda5-418">**図 20**: 同時実行制御違反が発生した場合に削除が取り消されたユーザー s ([フルサイズの画像を表示する をクリックします](implementing-optimistic-concurrency-cs/_static/image58.png))。</span><span class="sxs-lookup"><span data-stu-id="ceda5-418">**Figure 20**: A User s Delete is Canceled in the Face of a Concurrency Violation ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image58.png))</span></span>


## <a name="summary"></a><span data-ttu-id="ceda5-419">まとめ</span><span class="sxs-lookup"><span data-stu-id="ceda5-419">Summary</span></span>

<span data-ttu-id="ceda5-420">同時実行制御違反の営業案件の存在により、複数の場合、すべてのアプリケーションで同時実行ユーザー データを更新または削除します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-420">Opportunities for concurrency violations exist in every application that allows multiple, concurrent users to update or delete data.</span></span> <span data-ttu-id="ceda5-421">場合の 2 人のユーザーは、最終書き込み"wins"で取得したユーザーと同じデータを同時に更新、ときに、変更内容を変更、他のユーザーの上書き、このような違反は考慮されません。</span><span class="sxs-lookup"><span data-stu-id="ceda5-421">If such violations are not accounted for, when two users simultaneously update the same data whoever gets in the last write "wins," overwriting the other user's changes changes.</span></span> <span data-ttu-id="ceda5-422">また、開発者は、オプティミスティックおよびペシミスティック同時実行制御を実装できます。</span><span class="sxs-lookup"><span data-stu-id="ceda5-422">Alternatively, developers can implement either optimistic or pessimistic concurrency control.</span></span> <span data-ttu-id="ceda5-423">オプティミスティック同時実行制御は、こと同時実行制御違反が低くてもと単に更新プログラムを禁止または削除コマンドは、同時実行制御違反を構成すると仮定します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-423">Optimistic concurrency control assumes that concurrency violations are infrequent and simply disallows an update or delete command that would constitute a concurrency violation.</span></span> <span data-ttu-id="ceda5-424">ペシミスティック同時実行制御では、違反は多くの場合、更新または削除コマンドの 1 つのユーザーの拒否するには、同時実行が許容されないと仮定します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-424">Pessimistic concurrency control assumes that concurrency violations are frequent and simply rejecting one user's update or delete command is not acceptable.</span></span> <span data-ttu-id="ceda5-425">ペシミスティック同時実行制御でレコードを更新するはその他のユーザーを変更またはロックされているレコードの削除を防ぐ、ロックがあります。</span><span class="sxs-lookup"><span data-stu-id="ceda5-425">With pessimistic concurrency control, updating a record involves locking it, thereby preventing any other users from modifying or deleting the record while it is locked.</span></span>

<span data-ttu-id="ceda5-426">.NET で型指定されたデータセットは、オプティミスティック同時実行制御をサポートするための機能を提供します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-426">The Typed DataSet in .NET provides functionality for supporting optimistic concurrency control.</span></span> <span data-ttu-id="ceda5-427">具体的には、`UPDATE`と`DELETE`データベースへの発行ステートメントは、すべてのテーブルの列を含む、ときに、update または delete がのみ発生する場合は、ユーザーの元のデータと一致するレコードの現在のデータを積み重ねない必要があります。update または delete を実行します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-427">In particular, the `UPDATE` and `DELETE` statements issued to the database include all of the table's columns, thereby ensuring that the update or delete will only occur if the record's current data matches with the original data the user had when performing their update or delete.</span></span> <span data-ttu-id="ceda5-428">オプティミスティック同時実行制御をサポートするために DAL を構成すると、BLL メソッドを更新する必要があります。</span><span class="sxs-lookup"><span data-stu-id="ceda5-428">Once the DAL has been configured to support optimistic concurrency, the BLL methods need to be updated.</span></span> <span data-ttu-id="ceda5-429">さらに、ObjectDataSource データ Web コントロールから元の値を取得して BLL に渡しますように BLL 呼び出す ASP.NET ページを構成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="ceda5-429">Additionally, the ASP.NET page that calls down into the BLL must be configured such that the ObjectDataSource retrieves the original values from its data Web control and passes them down into the BLL.</span></span>

<span data-ttu-id="ceda5-430">このチュートリアルで説明したようには ASP.NET web アプリケーションでオプティミスティック同時実行制御を実装する DAL と BLL を更新して、ASP.NET ページのサポートを追加することがあります。</span><span class="sxs-lookup"><span data-stu-id="ceda5-430">As we saw in this tutorial, implementing optimistic concurrency control in an ASP.NET web application involves updating the DAL and BLL and adding support in the ASP.NET page.</span></span> <span data-ttu-id="ceda5-431">この追加作業が、時間と労力を賢明に投資収益率がかどうかは、アプリケーションによって異なります。</span><span class="sxs-lookup"><span data-stu-id="ceda5-431">Whether or not this added work is a wise investment of your time and effort depends on your application.</span></span> <span data-ttu-id="ceda5-432">同時実行ユーザーが、データの更新がある頻度の低い、または更新して、データが異なることから、その同時実行制御はできません、重要な問題。</span><span class="sxs-lookup"><span data-stu-id="ceda5-432">If you infrequently have concurrent users updating data, or the data they are updating is different from one another, then concurrency control is not a key issue.</span></span> <span data-ttu-id="ceda5-433">あれば、ただし、日常的に複数のユーザーのサイトの動作と同じデータで、同時実行制御は無意識の上書きから 1 つのユーザーの更新や削除を防ぐのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="ceda5-433">If, however, you routinely have multiple users on your site working with the same data, concurrency control can help prevent one user's updates or deletes from unwittingly overwriting another's.</span></span>

<span data-ttu-id="ceda5-434">満足のプログラミングです。</span><span class="sxs-lookup"><span data-stu-id="ceda5-434">Happy Programming!</span></span>

## <a name="about-the-author"></a><span data-ttu-id="ceda5-435">執筆者紹介</span><span class="sxs-lookup"><span data-stu-id="ceda5-435">About the Author</span></span>

<span data-ttu-id="ceda5-436">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml)、7 つ受け取りますブックおよびの創設者の著者[4GuysFromRolla.com](http://www.4guysfromrolla.com)、Microsoft Web テクノロジと 1998 年から携わっています。</span><span class="sxs-lookup"><span data-stu-id="ceda5-436">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="ceda5-437">Scott は、フリーのコンサルタント、トレーナー、およびライターとして動作します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-437">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="ceda5-438">最新の著書は[ *Sams 教える自分で ASP.NET 2.0 24 時間以内に*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-438">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="ceda5-439">彼に到達できる[mitchell@4GuysFromRolla.comします。](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="ceda5-439">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span> <span data-ttu-id="ceda5-440">彼のブログにあるでまたは[ http://ScottOnWriting.NET](http://ScottOnWriting.NET)します。</span><span class="sxs-lookup"><span data-stu-id="ceda5-440">or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="ceda5-441">[前へ](customizing-the-data-modification-interface-cs.md)
> [次へ](adding-client-side-confirmation-when-deleting-cs.md)</span><span class="sxs-lookup"><span data-stu-id="ceda5-441">[Previous](customizing-the-data-modification-interface-cs.md)
[Next](adding-client-side-confirmation-when-deleting-cs.md)</span></span>
