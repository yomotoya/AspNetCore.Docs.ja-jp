---
uid: web-forms/overview/data-access/paging-and-sorting/efficiently-paging-through-large-amounts-of-data-vb
title: 大量のデータ (VB) を効率的にページング |Microsoft Docs
author: rick-anderson
description: データ プレゼンテーション コントロールの既定ページング オプションは、大量のデータは、その基になるデータ ソース コントロール retriev として使用する場合に適していません.
ms.author: aspnetcontent
manager: wpickett
ms.date: 08/15/2006
ms.topic: article
ms.assetid: 3e20e64a-8808-4b49-88d6-014e2629d56f
ms.technology: dotnet-webforms
msc.legacyurl: /web-forms/overview/data-access/paging-and-sorting/efficiently-paging-through-large-amounts-of-data-vb
msc.type: authoredcontent
ms.openlocfilehash: 7d3b9f816e8e940d3ba109aeaf6055616f38d12a
ms.sourcegitcommit: 953ff9ea4369f154d6fd0239599279ddd3280009
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 07/03/2018
ms.locfileid: "37382680"
---
<a name="efficiently-paging-through-large-amounts-of-data-vb"></a><span data-ttu-id="8ea05-103">効率的にページングする大量のデータ (VB)</span><span class="sxs-lookup"><span data-stu-id="8ea05-103">Efficiently Paging Through Large Amounts of Data (VB)</span></span>
====================
<span data-ttu-id="8ea05-104">によって[Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="8ea05-104">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="8ea05-105">[サンプル アプリをダウンロード](http://download.microsoft.com/download/9/c/1/9c1d03ee-29ba-4d58-aa1a-f201dcc822ea/ASPNET_Data_Tutorial_25_VB.exe)または[PDF のダウンロード](efficiently-paging-through-large-amounts-of-data-vb/_static/datatutorial25vb1.pdf)</span><span class="sxs-lookup"><span data-stu-id="8ea05-105">[Download Sample App](http://download.microsoft.com/download/9/c/1/9c1d03ee-29ba-4d58-aa1a-f201dcc822ea/ASPNET_Data_Tutorial_25_VB.exe) or [Download PDF](efficiently-paging-through-large-amounts-of-data-vb/_static/datatutorial25vb1.pdf)</span></span>

> <span data-ttu-id="8ea05-106">データ プレゼンテーション コントロールの既定のページング オプションは適していません大量のデータを使用する場合、データのサブセットのみが表示される場合でも、その基になるデータ ソース コントロールが、すべてのレコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="8ea05-106">The default paging option of a data presentation control is unsuitable when working with large amounts of data, as its underlying data source control retrieves all records, even though only a subset of data is displayed.</span></span> <span data-ttu-id="8ea05-107">このような状況では、する必要がありますにカスタムにページングします。</span><span class="sxs-lookup"><span data-stu-id="8ea05-107">In such circumstances, we must turn to custom paging.</span></span>


## <a name="introduction"></a><span data-ttu-id="8ea05-108">はじめに</span><span class="sxs-lookup"><span data-stu-id="8ea05-108">Introduction</span></span>

<span data-ttu-id="8ea05-109">上記のチュートリアルで説明したように、2 つの方法のいずれかでページングを実装できます。</span><span class="sxs-lookup"><span data-stu-id="8ea05-109">As we discussed in the preceding tutorial, paging can be implemented in one of two ways:</span></span>

- <span data-ttu-id="8ea05-110">**既定のページング**ページングを有効にするオプションをチェックするだけで実装できるデータ Web コントロールのスマート タグただし、データのページを表示するたびに、ObjectDataSource が取得します。*すべて*であっても、レコードの。ただし ページで、それらのサブセットのみが表示されます。</span><span class="sxs-lookup"><span data-stu-id="8ea05-110">**Default Paging** can be implemented by simply checking the Enable Paging option in the data Web control s smart tag; however, whenever viewing a page of data, the ObjectDataSource retrieves *all* of the records, even though only a subset of them are displayed in the page</span></span>
- <span data-ttu-id="8ea05-111">**カスタム ページング**既定のパフォーマンスが向上、ユーザーから要求されたデータの特定のページに表示する必要のあるデータベースからレコードのみを取得することによってページングしかし、カスタム ページングは、少しの労力を実装するには既定のページングより</span><span class="sxs-lookup"><span data-stu-id="8ea05-111">**Custom Paging** improves the performance of default paging by retrieving only those records from the database that need to be displayed for the particular page of data requested by the user; however, custom paging involves a bit more effort to implement than default paging</span></span>

<span data-ttu-id="8ea05-112">実装だけチェックのチェック ボックスがあり、re 容易さが原因で終了です。</span><span class="sxs-lookup"><span data-stu-id="8ea05-112">Due to the ease of implementation just check a checkbox and you re done!</span></span> <span data-ttu-id="8ea05-113">既定のページングは、魅力的なオプションです。</span><span class="sxs-lookup"><span data-stu-id="8ea05-113">default paging is an attractive option.</span></span> <span data-ttu-id="8ea05-114">その na ve アプローチのすべてのレコードを取得する際では、ことは信じがたいの選択した多数の同時ユーザーに十分な大きさの金額またはサイトのデータをページングするとき。</span><span class="sxs-lookup"><span data-stu-id="8ea05-114">Its na�ve approach in retrieving all of the records, though, makes it an implausible choice when paging through sufficiently large amounts of data or for sites with many concurrent users.</span></span> <span data-ttu-id="8ea05-115">このような状況では、カスタムに応答性の高いシステムを提供するためにページングにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="8ea05-115">In such circumstances, we must turn to custom paging in order to provide a responsive system.</span></span>

<span data-ttu-id="8ea05-116">カスタム ページングの課題は、正確なデータの特定のページに必要なレコード セットを返すクエリを記述できることです。</span><span class="sxs-lookup"><span data-stu-id="8ea05-116">The challenge of custom paging is being able to write a query that returns the precise set of records needed for a particular page of data.</span></span> <span data-ttu-id="8ea05-117">さいわい、Microsoft SQL Server 2005 を提供します新しいキーワードの順位付けの結果をレコードの適切なサブセットを取得できる効率的にクエリを記述できます。</span><span class="sxs-lookup"><span data-stu-id="8ea05-117">Fortunately, Microsoft SQL Server 2005 provides a new keyword for ranking results, which enables us to write a query that can efficiently retrieve the proper subset of records.</span></span> <span data-ttu-id="8ea05-118">このチュートリアルでは、この新しい SQL Server 2005 のキーワードを使用して、GridView コントロールにカスタム ページングを実装する方法がわかります。</span><span class="sxs-lookup"><span data-stu-id="8ea05-118">In this tutorial we'll see how to use this new SQL Server 2005 keyword to implement custom paging in a GridView control.</span></span> <span data-ttu-id="8ea05-119">カスタム ページングのユーザー インターフェイスが既定のページング、1 つのページから、[次へ] を使用するステップ インと同じですが、カスタム ページングでは既定のページングよりも高速の桁数を指定できます。</span><span class="sxs-lookup"><span data-stu-id="8ea05-119">While the user interface for custom paging is identical to that for default paging, stepping from one page to the next using custom paging can be several orders of magnitude faster than default paging.</span></span>

> [!NOTE]
> <span data-ttu-id="8ea05-120">カスタム ページングが発生した正確なパフォーマンスの向上は、レコードをポケットベル通知とデータベース サーバー上に配置されている負荷の合計数によって異なります。</span><span class="sxs-lookup"><span data-stu-id="8ea05-120">The exact performance gain exhibited by custom paging depends on the total number of records being paged through and the load being placed on the database server.</span></span> <span data-ttu-id="8ea05-121">このチュートリアルの最後には、カスタム ページング経由で取得したパフォーマンスの利点を紹介するいくつかの大まかなメトリックも取り上げます。</span><span class="sxs-lookup"><span data-stu-id="8ea05-121">At the end of this tutorial we'll look at some rough metrics that showcase the benefits in performance obtained through custom paging.</span></span>


## <a name="step-1-understanding-the-custom-paging-process"></a><span data-ttu-id="8ea05-122">手順 1: カスタム ページング プロセスを理解します。</span><span class="sxs-lookup"><span data-stu-id="8ea05-122">Step 1: Understanding the Custom Paging Process</span></span>

<span data-ttu-id="8ea05-123">データのページング、ときに、ページに表示される正確なレコードは、要求されているデータのページとページあたりに表示されるレコードの数によって異なります。</span><span class="sxs-lookup"><span data-stu-id="8ea05-123">When paging through data, the precise records displayed in a page depend upon the page of data being requested and the number of records displayed per page.</span></span> <span data-ttu-id="8ea05-124">たとえば、ことたい 81 の製品内でページを 1 ページあたり 10 個の製品を表示するとします。</span><span class="sxs-lookup"><span data-stu-id="8ea05-124">For example, imagine that we wanted to page through the 81 products, displaying 10 products per page.</span></span> <span data-ttu-id="8ea05-125">最初のページを表示するときに d する製品の 1 ~ 10 です。2 番目のページを表示するときに d 予定 11 から 20 の製品で対象です。</span><span class="sxs-lookup"><span data-stu-id="8ea05-125">When viewing the first page, we d want products 1 through 10; when viewing the second page we d be interested in products 11 through 20, and so on.</span></span>

<span data-ttu-id="8ea05-126">取得する必要があるレコードとページング インターフェイスを表示する方法を指定する 3 つの変数です。</span><span class="sxs-lookup"><span data-stu-id="8ea05-126">There are three variables that dictate what records need to be retrieved and how the paging interface should be rendered:</span></span>

- <span data-ttu-id="8ea05-127">**開始行インデックス** ページで表示するデータの最初の行のインデックスはページのインデックスを 1 ページに表示するレコードに乗算と 1 つを追加することによって計算このインデックスを作成できます。</span><span class="sxs-lookup"><span data-stu-id="8ea05-127">**Start Row Index** the index of the first row in the page of data to display; this index can be calculated by multiplying the page index by the records to display per page and adding one.</span></span> <span data-ttu-id="8ea05-128">たとえば、最初のページ (ページ インデックスが 0) を一度にレコード 10 のページングしているとき、に、開始行インデックスは 0 \* 10 + 1、または 1; 2 番目のページ (ページ インデックスは 1) の行の開始インデックスが 1 \* 10 + 1、または 11。</span><span class="sxs-lookup"><span data-stu-id="8ea05-128">For example, when paging through records 10 at a time, for the first page (whose page index is 0), the Start Row Index is 0 \* 10 + 1, or 1; for the second page (whose page index is 1), the Start Row Index is 1 \* 10 + 1, or 11.</span></span>
- <span data-ttu-id="8ea05-129">**最大行数は**1 ページに表示するレコードの最大数。</span><span class="sxs-lookup"><span data-stu-id="8ea05-129">**Maximum Rows** the maximum number of records to display per page.</span></span> <span data-ttu-id="8ea05-130">この変数は、最後のページのページ サイズよりも返されるレコードの少ない場合があるため最大行数として呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="8ea05-130">This variable is referred to as maximum rows since for the last page there may be fewer records returned than the page size.</span></span> <span data-ttu-id="8ea05-131">たとえば、1 ページあたり 10 81 の製品レコード間のページング、ときに、9 番目と最後のページは 1 つのレコードがあります。</span><span class="sxs-lookup"><span data-stu-id="8ea05-131">For example, when paging through the 81 products 10 records per page, the ninth and final page will have just one record.</span></span> <span data-ttu-id="8ea05-132">ページで、ただしは表示されません行の最大値よりも多くのレコード。</span><span class="sxs-lookup"><span data-stu-id="8ea05-132">No page, though, will show more records than the Maximum Rows value.</span></span>
- <span data-ttu-id="8ea05-133">**合計レコード数**を介してページングされるレコードの合計数。</span><span class="sxs-lookup"><span data-stu-id="8ea05-133">**Total Record Count** the total number of records being paged through.</span></span> <span data-ttu-id="8ea05-134">この変数は t の特定のページを取得するレコードを決定する必要があるときに、ページング インターフェイスによって決まります。</span><span class="sxs-lookup"><span data-stu-id="8ea05-134">While this variable isn t needed to determine what records to retrieve for a given page, it does dictate the paging interface.</span></span> <span data-ttu-id="8ea05-135">たとえば、ポケットベル通知を 81 の製品がある場合は、ページング UI に 9 つのページ番号を表示するページング インターフェイスが認識しています。</span><span class="sxs-lookup"><span data-stu-id="8ea05-135">For example, if there are 81 products being paged through, the paging interface knows to display nine page numbers in the paging UI.</span></span>

<span data-ttu-id="8ea05-136">既定のページングを使用した開始行インデックス行の最大数はページ サイズでは単にページのインデックスとページ サイズを 1 つの積として計算されます。</span><span class="sxs-lookup"><span data-stu-id="8ea05-136">With default paging, the Start Row Index is computed as the product of the page index and the page size plus one, whereas the Maximum Rows is simply the page size.</span></span> <span data-ttu-id="8ea05-137">既定のページングには、すべてからレコードを取得するためことにより、簡単な作業の開始行インデックス行への移行データを行ごとにインデックスの任意のページを表示するときに、データベースが呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="8ea05-137">Since default paging retrieves all of the records from the database when rendering any page of data, the index for each row is known, thereby making moving to Start Row Index row a trivial task.</span></span> <span data-ttu-id="8ea05-138">さらに、レコードの総数はので、すぐに使用できる s DataTable (または任意のオブジェクトがデータベースの結果を保持するために使用されている) 内のレコードの数だけです。</span><span class="sxs-lookup"><span data-stu-id="8ea05-138">Moreover, the Total Record Count is readily available, as it s simply the number of records in the DataTable (or whatever object is being used to hold the database results).</span></span>

<span data-ttu-id="8ea05-139">開始行のインデックスと行の最大数の変数を指定するには、カスタム ページングの実装ではその後の行の開始インデックス位置にあると、レコード数の最大行数は最大の開始レコードの正確なサブセットを返すこと必要がありますのみです。</span><span class="sxs-lookup"><span data-stu-id="8ea05-139">Given the Start Row Index and Maximum Rows variables, a custom paging implementation must only return the precise subset of records starting at the Start Row Index and up to Maximum Rows number of records after that.</span></span> <span data-ttu-id="8ea05-140">カスタム ページングでは、2 つの課題を提供します。</span><span class="sxs-lookup"><span data-stu-id="8ea05-140">Custom paging provides two challenges:</span></span>

- <span data-ttu-id="8ea05-141">行のインデックスに各行を指定した開始行インデックス位置にあるレコードを返すを開始するためにページングされるデータ全体で効率的に関連付けることができる必要があります。</span><span class="sxs-lookup"><span data-stu-id="8ea05-141">We must be able to efficiently associate a row index with each row in the entire data being paged through so that we can start returning records at the specified Start Row Index</span></span>
- <span data-ttu-id="8ea05-142">ポケットベル通知でレコードの合計数を提供する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8ea05-142">We need to provide the total number of records being paged through</span></span>

<span data-ttu-id="8ea05-143">次の 2 つの手順では、これら 2 つの課題に応答するために必要な SQL スクリプトを考察します。</span><span class="sxs-lookup"><span data-stu-id="8ea05-143">In the next two steps we'll examine the SQL script needed to respond to these two challenges.</span></span> <span data-ttu-id="8ea05-144">SQL スクリプトだけでなくも DAL と BLL にメソッドを実装する必要あります。</span><span class="sxs-lookup"><span data-stu-id="8ea05-144">In addition to the SQL script, we'll also need to implement methods in the DAL and BLL.</span></span>

## <a name="step-2-returning-the-total-number-of-records-being-paged-through"></a><span data-ttu-id="8ea05-145">手順 2: ポケットベル通知でレコードの合計数を返す</span><span class="sxs-lookup"><span data-stu-id="8ea05-145">Step 2: Returning the Total Number of Records Being Paged Through</span></span>

<span data-ttu-id="8ea05-146">表示されているページのレコードの正確なサブセットを取得する方法を調べる前に、最初からページングされるレコードの合計数を返す方法を見て s を使用できます。</span><span class="sxs-lookup"><span data-stu-id="8ea05-146">Before we examine how to retrieve the precise subset of records for the page being displayed, let s first look at how to return the total number of records being paged through.</span></span> <span data-ttu-id="8ea05-147">この情報は、ページングのユーザー インターフェイスを適切に構成するために必要です。</span><span class="sxs-lookup"><span data-stu-id="8ea05-147">This information is needed in order to properly configure the paging user interface.</span></span> <span data-ttu-id="8ea05-148">使用して、特定の SQL クエリによって返されるレコードの合計数を取得できます、 [ `COUNT`集計関数](https://msdn.microsoft.com/library/ms175997.aspx)します。</span><span class="sxs-lookup"><span data-stu-id="8ea05-148">The total number of records returned by a particular SQL query can be obtained by using the [`COUNT` aggregate function](https://msdn.microsoft.com/library/ms175997.aspx).</span></span> <span data-ttu-id="8ea05-149">たとえば、内のレコードの合計数を決定するため、`Products`テーブル、次のクエリを使用できます。</span><span class="sxs-lookup"><span data-stu-id="8ea05-149">For example, to determine the total number of records in the `Products` table, we can use the following query:</span></span>


[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample1.sql)]

<span data-ttu-id="8ea05-150">この情報を返す、DAL にメソッドを追加して使用できます。</span><span class="sxs-lookup"><span data-stu-id="8ea05-150">Let s add a method to our DAL that returns this information.</span></span> <span data-ttu-id="8ea05-151">具体的には、DAL メソッドを作成します`TotalNumberOfProducts()`を実行する、`SELECT`前に示したステートメント。</span><span class="sxs-lookup"><span data-stu-id="8ea05-151">In particular, we'll create a DAL method called `TotalNumberOfProducts()` that executes the `SELECT` statement shown above.</span></span>

<span data-ttu-id="8ea05-152">開いて開始、`Northwind.xsd`でデータセットの型指定されたファイル、`App_Code/DAL`フォルダー。</span><span class="sxs-lookup"><span data-stu-id="8ea05-152">Start by opening the `Northwind.xsd` Typed DataSet file in the `App_Code/DAL` folder.</span></span> <span data-ttu-id="8ea05-153">次に、右クリックし、`ProductsTableAdapter`デザイナーでクエリの追加を選択します。</span><span class="sxs-lookup"><span data-stu-id="8ea05-153">Next, right-click on the `ProductsTableAdapter` in the Designer and choose Add Query.</span></span> <span data-ttu-id="8ea05-154">として前のチュートリアルで確認したところこれは、DAL に新しいメソッドを追加することにより、呼び出されると、特定の SQL ステートメントまたはストアド プロシージャを実行します。</span><span class="sxs-lookup"><span data-stu-id="8ea05-154">As we ve seen in previous tutorials, this will allow us to add a new method to the DAL that, when invoked, will execute a particular SQL statement or stored procedure.</span></span> <span data-ttu-id="8ea05-155">同様に、TableAdapter には、前のチュートリアルでのメソッドが、このいずれかのアドホック SQL ステートメントを使用するを選択します。</span><span class="sxs-lookup"><span data-stu-id="8ea05-155">As with our TableAdapter methods in previous tutorials, for this one opt to use an ad-hoc SQL statement.</span></span>


![アドホック SQL ステートメントを使用します。](efficiently-paging-through-large-amounts-of-data-vb/_static/image1.png)

<span data-ttu-id="8ea05-157">**図 1**: アドホック SQL ステートメントを使用</span><span class="sxs-lookup"><span data-stu-id="8ea05-157">**Figure 1**: Use an Ad-Hoc SQL Statement</span></span>


<span data-ttu-id="8ea05-158">次の画面を作成するクエリの種類を指定できます。</span><span class="sxs-lookup"><span data-stu-id="8ea05-158">On the next screen we can specify what type of query to create.</span></span> <span data-ttu-id="8ea05-159">このクエリは内のレコードの合計数に 1 つのスカラー値に返すため、`Products`テーブルの選択、`SELECT`単一の値のオプションが返されます。</span><span class="sxs-lookup"><span data-stu-id="8ea05-159">Since this query will return a single, scalar value the total number of records in the `Products` table choose the `SELECT` which returns a singe value option.</span></span>


![1 つの値を返す SELECT ステートメントを使用するクエリを構成します。](efficiently-paging-through-large-amounts-of-data-vb/_static/image2.png)

<span data-ttu-id="8ea05-161">**図 2**: 単一の値を返す SELECT ステートメントを使用するクエリの構成</span><span class="sxs-lookup"><span data-stu-id="8ea05-161">**Figure 2**: Configure the Query to Use a SELECT Statement that Returns a Single Value</span></span>


<span data-ttu-id="8ea05-162">使用するクエリの種類を示す後、は、次に、クエリを指定します必要があります。</span><span class="sxs-lookup"><span data-stu-id="8ea05-162">After indicating the type of query to use, we must next specify the query.</span></span>


![製品のクエリから選択 COUNT(\*) を使用します。](efficiently-paging-through-large-amounts-of-data-vb/_static/image3.png)

<span data-ttu-id="8ea05-164">**図 3**: SELECT Count (\*) FROM 製品クエリ</span><span class="sxs-lookup"><span data-stu-id="8ea05-164">**Figure 3**: Use the SELECT COUNT(\*) FROM Products Query</span></span>


<span data-ttu-id="8ea05-165">最後に、メソッドの名前を指定します。</span><span class="sxs-lookup"><span data-stu-id="8ea05-165">Finally, specify the name for the method.</span></span> <span data-ttu-id="8ea05-166">使用して、前述の s として`TotalNumberOfProducts`します。</span><span class="sxs-lookup"><span data-stu-id="8ea05-166">As aforementioned, let s use `TotalNumberOfProducts`.</span></span>


![DAL メソッド TotalNumberOfProducts を名前します。](efficiently-paging-through-large-amounts-of-data-vb/_static/image4.png)

<span data-ttu-id="8ea05-168">**図 4**: DAL メソッド TotalNumberOfProducts の名前</span><span class="sxs-lookup"><span data-stu-id="8ea05-168">**Figure 4**: Name the DAL Method TotalNumberOfProducts</span></span>


<span data-ttu-id="8ea05-169">[完了] をクリックした後、ウィザードが追加されます、 `TotalNumberOfProducts` DAL に対するメソッド。</span><span class="sxs-lookup"><span data-stu-id="8ea05-169">After clicking Finish, the wizard will add the `TotalNumberOfProducts` method to the DAL.</span></span> <span data-ttu-id="8ea05-170">場合に、SQL クエリの結果、DAL で返すスカラーのメソッドが null 許容型を返す`NULL`します。</span><span class="sxs-lookup"><span data-stu-id="8ea05-170">The scalar returning methods in the DAL return nullable types, in case the result from the SQL query is `NULL`.</span></span> <span data-ttu-id="8ea05-171">この`COUNT`、ただし、常に返されます以外`NULL`値; に関係なく、DAL メソッドが null 許容の整数を返します。</span><span class="sxs-lookup"><span data-stu-id="8ea05-171">Our `COUNT` query, however, will always return a non-`NULL` value; regardless, the DAL method returns a nullable integer.</span></span>

<span data-ttu-id="8ea05-172">DAL メソッドだけでなく、BLL のメソッドも必要です。</span><span class="sxs-lookup"><span data-stu-id="8ea05-172">In addition to the DAL method, we also need a method in the BLL.</span></span> <span data-ttu-id="8ea05-173">開く、`ProductsBLL`クラス ファイルを追加、 `TotalNumberOfProducts` DAL s 単に呼び出すメソッドを`TotalNumberOfProducts`メソッド。</span><span class="sxs-lookup"><span data-stu-id="8ea05-173">Open the `ProductsBLL` class file and add a `TotalNumberOfProducts` method that simply calls down to the DAL s `TotalNumberOfProducts` method:</span></span>


[!code-vb[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample2.vb)]

<span data-ttu-id="8ea05-174">DAL s`TotalNumberOfProducts`メソッドは null 許容の整数を返します。 ただし、私たちを作成しました、`ProductsBLL`クラス s`TotalNumberOfProducts`メソッドの標準的な整数を返すようにします。</span><span class="sxs-lookup"><span data-stu-id="8ea05-174">The DAL s `TotalNumberOfProducts` method returns a nullable integer; however, we ve created the `ProductsBLL` class s `TotalNumberOfProducts` method so that it returns a standard integer.</span></span> <span data-ttu-id="8ea05-175">そのため、私たちがする必要があります、`ProductsBLL`クラス s`TotalNumberOfProducts`メソッドは、DAL s によって返される null 許容の整数の値の部分を返す`TotalNumberOfProducts`メソッド。</span><span class="sxs-lookup"><span data-stu-id="8ea05-175">Therefore, we need to have the `ProductsBLL` class s `TotalNumberOfProducts` method return the value portion of the nullable integer returned by the DAL s `TotalNumberOfProducts` method.</span></span> <span data-ttu-id="8ea05-176">呼び出し`GetValueOrDefault()`場合は null 許容の整数が存在する場合、null 許容の整数の値を返します`null`、ただし、既定の整数値は 0 を返します。</span><span class="sxs-lookup"><span data-stu-id="8ea05-176">The call to `GetValueOrDefault()` returns the value of the nullable integer, if it exists; if the nullable integer is `null`, however, it returns the default integer value, 0.</span></span>

## <a name="step-3-returning-the-precise-subset-of-records"></a><span data-ttu-id="8ea05-177">手順 3: レコードの正確なサブセットを返す</span><span class="sxs-lookup"><span data-stu-id="8ea05-177">Step 3: Returning the Precise Subset of Records</span></span>

<span data-ttu-id="8ea05-178">DAL で BLL 開始行インデックスをそのまま使用するメソッドを作成する、次のタスクでは、最大行数は変数の前に説明したし、適切なレコードが返されます。</span><span class="sxs-lookup"><span data-stu-id="8ea05-178">Our next task is to create methods in the DAL and BLL that accept the Start Row Index and Maximum Rows variables discussed earlier and return the appropriate records.</span></span> <span data-ttu-id="8ea05-179">その前に let s は、最初に必要な SQL スクリプトを見ています。</span><span class="sxs-lookup"><span data-stu-id="8ea05-179">Before we do that, let s first look at the needed SQL script.</span></span> <span data-ttu-id="8ea05-180">私たちが直面する課題は、行の開始インデックス位置にある (およびレコードの最大レコード数まで) を開始するには、これらのレコードを返すことができるように、を介してページングされる全体の結果内の各行にインデックスを効率的に割り当てるにさせていただく必要があります。</span><span class="sxs-lookup"><span data-stu-id="8ea05-180">The challenge facing us is that we must be able to efficiently assign an index to each row in the entire results being paged through so that we can return just those records starting at the Start Row Index (and up to the Maximum Records number of records).</span></span>

<span data-ttu-id="8ea05-181">行のインデックスとして機能するデータベース テーブルの列は既に場合でもこれは、チャレンジではありません。</span><span class="sxs-lookup"><span data-stu-id="8ea05-181">This is not a challenge if there is already a column in the database table that serves as a row index.</span></span> <span data-ttu-id="8ea05-182">一見考えることも、`Products`テーブル s`ProductID`フィールドはで十分な最初の製品が`ProductID`1、2、2 番目のなど。</span><span class="sxs-lookup"><span data-stu-id="8ea05-182">At first glance we might think that the `Products` table s `ProductID` field would suffice, as the first product has `ProductID` of 1, the second a 2, and so on.</span></span> <span data-ttu-id="8ea05-183">ただし、商品を削除するには、このアプローチを戻して、シーケンスは、ギャップが残されます。</span><span class="sxs-lookup"><span data-stu-id="8ea05-183">However, deleting a product leaves a gap in the sequence, nullifying this approach.</span></span>

<span data-ttu-id="8ea05-184">2 つ一般的な手法、改ページするデータを効率的に行のインデックスを関連付けるために使用できるように取得するレコードの正確なサブセットがあります。</span><span class="sxs-lookup"><span data-stu-id="8ea05-184">There are two general techniques used to efficiently associate a row index with the data to page through, thereby enabling the precise subset of records to be retrieved:</span></span>

- <span data-ttu-id="8ea05-185">**SQL Server 2005 の s を使用して`ROW_NUMBER()`キーワード**から SQL Server 2005 では、新しい、`ROW_NUMBER()`キーワードは、何らかの順序に基づいて返される各レコードを順位付けを関連付けます。</span><span class="sxs-lookup"><span data-stu-id="8ea05-185">**Using SQL Server 2005 s `ROW_NUMBER()` Keyword** new to SQL Server 2005, the `ROW_NUMBER()` keyword associates a ranking with each returned record based on some ordering.</span></span> <span data-ttu-id="8ea05-186">この順位付けは、各行の行のインデックスとして使用できます。</span><span class="sxs-lookup"><span data-stu-id="8ea05-186">This ranking can be used as a row index for each row.</span></span>
- <span data-ttu-id="8ea05-187">**テーブル変数を使用し、 `SET ROWCOUNT`**  SQL server [ `SET ROWCOUNT`ステートメント](https://msdn.microsoft.com/library/ms188774.aspx)数の合計レコード終了する前にクエリを処理する必要がありますを指定するために使用できます。[テーブル変数](http://www.sqlteam.com/item.asp?ItemID=9454)akin を表形式のデータを保持できるローカルの T-SQL 変数[一時テーブル](http://www.sqlteam.com/item.asp?ItemID=2029)します。</span><span class="sxs-lookup"><span data-stu-id="8ea05-187">**Using a Table Variable and `SET ROWCOUNT`** SQL Server s [`SET ROWCOUNT` statement](https://msdn.microsoft.com/library/ms188774.aspx) can be used to specify how many total records a query should process before terminating; [table variables](http://www.sqlteam.com/item.asp?ItemID=9454) are local T-SQL variables that can hold tabular data, akin to [temporary tables](http://www.sqlteam.com/item.asp?ItemID=2029).</span></span> <span data-ttu-id="8ea05-188">このアプローチは均等に Microsoft SQL Server 2005 および SQL Server 2000 の両方 (一方、`ROW_NUMBER()`アプローチは、SQL Server 2005 でのみ動作)。</span><span class="sxs-lookup"><span data-stu-id="8ea05-188">This approach works equally well with both Microsoft SQL Server 2005 and SQL Server 2000 (whereas the `ROW_NUMBER()` approach only works with SQL Server 2005).</span></span>  
  
  <span data-ttu-id="8ea05-189">持つテーブル変数を作成するという考え方です、`IDENTITY`列とデータを介してページングされるテーブルの主キーの列。</span><span class="sxs-lookup"><span data-stu-id="8ea05-189">The idea here is to create a table variable that has an `IDENTITY` column and columns for the primary keys of the table whose data is being paged through.</span></span> <span data-ttu-id="8ea05-190">テーブル変数は、連続する行のインデックスを関連付けるために、データを介してページングされるテーブルの内容をダンプする次に、(を使用して、`IDENTITY`列)、テーブル内の各レコード。</span><span class="sxs-lookup"><span data-stu-id="8ea05-190">Next, the contents of the table whose data is being paged through is dumped into the table variable, thereby associating a sequential row index (via the `IDENTITY` column) for each record in the table.</span></span> <span data-ttu-id="8ea05-191">テーブル変数を設定すると後、`SELECT`のステートメントでテーブル変数では、特定のレコードを取得する基になるテーブルと結合してを実行できます。</span><span class="sxs-lookup"><span data-stu-id="8ea05-191">Once the table variable has been populated, a `SELECT` statement on the table variable, joined with the underlying table, can be executed to pull out the particular records.</span></span> <span data-ttu-id="8ea05-192">`SET ROWCOUNT`インテリジェントにテーブル変数にダンプする必要があるレコードの数を制限するステートメントを使用します。</span><span class="sxs-lookup"><span data-stu-id="8ea05-192">The `SET ROWCOUNT` statement is used to intelligently limit the number of records that need to be dumped into the table variable.</span></span>  
  
  <span data-ttu-id="8ea05-193">このアプローチの効率性が要求されているページ数に基づいてとして、`SET ROWCOUNT`値には、開始行インデックスと行の最大数の値が割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="8ea05-193">This approach s efficiency is based on the page number being requested, as the `SET ROWCOUNT` value is assigned the value of Start Row Index plus the Maximum Rows.</span></span> <span data-ttu-id="8ea05-194">最初のなどのページの最小番号をいくつかのページのデータをページングするとき、この方法は非常に効率的です。</span><span class="sxs-lookup"><span data-stu-id="8ea05-194">When paging through low-numbered pages such as the first few pages of data this approach is very efficient.</span></span> <span data-ttu-id="8ea05-195">ただし、末尾付近のページを取得するときに、既定のページングのようなパフォーマンスが発生します。</span><span class="sxs-lookup"><span data-stu-id="8ea05-195">However, it exhibits default paging-like performance when retrieving a page near the end.</span></span>

<span data-ttu-id="8ea05-196">このチュートリアルでは、カスタム ページングを使用して実装する、`ROW_NUMBER()`キーワード。</span><span class="sxs-lookup"><span data-stu-id="8ea05-196">This tutorial implements custom paging using the `ROW_NUMBER()` keyword.</span></span> <span data-ttu-id="8ea05-197">テーブル変数を使用しての詳細については、`SET ROWCOUNT`方法を参照してください[A 詳細の効率的な方法の大きな結果セットからページング](http://www.4guysfromrolla.com/webtech/042606-1.shtml)します。</span><span class="sxs-lookup"><span data-stu-id="8ea05-197">For more information on using the table variable and `SET ROWCOUNT` technique, see [A More Efficient Method for Paging Through Large Result Sets](http://www.4guysfromrolla.com/webtech/042606-1.shtml).</span></span>

<span data-ttu-id="8ea05-198">`ROW_NUMBER()`キーワードでは、次の構文を使用して特定の順序で返された各レコードに順位付けが関連付けられています。</span><span class="sxs-lookup"><span data-stu-id="8ea05-198">The `ROW_NUMBER()` keyword associated a ranking with each record returned over a particular ordering using the following syntax:</span></span>


[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample3.sql)]

<span data-ttu-id="8ea05-199">`ROW_NUMBER()` 指定された順序に関しては、各レコードのランクを指定する数値を返します。</span><span class="sxs-lookup"><span data-stu-id="8ea05-199">`ROW_NUMBER()` returns a numerical value that specifies the rank for each record with regards to the indicated ordering.</span></span> <span data-ttu-id="8ea05-200">たとえば、製品ごとの多い順にランクを表示する、最小コストの高い使えば、次のクエリ。</span><span class="sxs-lookup"><span data-stu-id="8ea05-200">For example, to see the rank for each product, ordered from the most expensive to the least, we could use the following query:</span></span>


[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample4.sql)]

<span data-ttu-id="8ea05-201">図 5 は、このクエリに Visual Studio で [クエリ] ウィンドウから実行したときに、秒の結果を示します。</span><span class="sxs-lookup"><span data-stu-id="8ea05-201">Figure 5 shows this query s results when run through the query window in Visual Studio.</span></span> <span data-ttu-id="8ea05-202">製品は行ごとの価格のランクとの価格で並べ替えられますことに注意してください。</span><span class="sxs-lookup"><span data-stu-id="8ea05-202">Note that the products are ordered by price, along with a price rank for each row.</span></span>


![価格のランクが含まれている各返されるレコード](efficiently-paging-through-large-amounts-of-data-vb/_static/image5.png)

<span data-ttu-id="8ea05-204">**図 5**: の 価格のランクが含まれている各返されるレコード</span><span class="sxs-lookup"><span data-stu-id="8ea05-204">**Figure 5**: The Price Rank is Included for Each Returned Record</span></span>


> [!NOTE]
> <span data-ttu-id="8ea05-205">`ROW_NUMBER()` 多くの新しい順位付け関数の 1 つは SQL Server 2005 で使用できます。</span><span class="sxs-lookup"><span data-stu-id="8ea05-205">`ROW_NUMBER()` is just one of the many new ranking functions available in SQL Server 2005.</span></span> <span data-ttu-id="8ea05-206">詳細については詳しい`ROW_NUMBER()`、読み取り、その他の順位付け関数と共に[Microsoft SQL Server 2005 でランク付けされた結果を返す](http://www.4guysfromrolla.com/webtech/010406-1.shtml)します。</span><span class="sxs-lookup"><span data-stu-id="8ea05-206">For a more thorough discussion of `ROW_NUMBER()`, along with the other ranking functions, read [Returning Ranked Results with Microsoft SQL Server 2005](http://www.4guysfromrolla.com/webtech/010406-1.shtml).</span></span>


<span data-ttu-id="8ea05-207">指定した結果を順位付けと`ORDER BY`内の列、`OVER`句 (`UnitPrice`、上の例では)、SQL Server は、結果を並べ替える必要があります。</span><span class="sxs-lookup"><span data-stu-id="8ea05-207">When ranking the results by the specified `ORDER BY` column in the `OVER` clause (`UnitPrice`, in the above example), SQL Server must sort the results.</span></span> <span data-ttu-id="8ea05-208">これは、結果には、順序付けられる列経由でクラスター化インデックスがある場合は、クイック操作またはカバリングがあるかどうか、インデックスしますが、それ以外の場合コストが高くすることができます。</span><span class="sxs-lookup"><span data-stu-id="8ea05-208">This is a quick operation if there is a clustered index over the column(s) the results are being ordered by, or if there is a covering index, but can be more costly otherwise.</span></span> <span data-ttu-id="8ea05-209">十分な大きさのクエリのパフォーマンスを向上させるで使用される結果が順序付けられた列の非クラスター化インデックスを追加することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="8ea05-209">To help improve performance for sufficiently large queries, consider adding a non-clustered index for the column by which the results are ordered by.</span></span> <span data-ttu-id="8ea05-210">参照してください[順位付け関数と SQL Server 2005 のパフォーマンス](http://www.sql-server-performance.com/ak_ranking_functions.asp)用にパフォーマンスに関する考慮事項について詳しく説明します。</span><span class="sxs-lookup"><span data-stu-id="8ea05-210">See [Ranking Functions and Performance in SQL Server 2005](http://www.sql-server-performance.com/ak_ranking_functions.asp) for a more detailed look at the performance considerations.</span></span>

<span data-ttu-id="8ea05-211">によって返されるランク付け情報`ROW_NUMBER()`で直接使用することはできません、`WHERE`句。</span><span class="sxs-lookup"><span data-stu-id="8ea05-211">The ranking information returned by `ROW_NUMBER()` cannot directly be used in the `WHERE` clause.</span></span> <span data-ttu-id="8ea05-212">派生テーブルを使用して、返される、`ROW_NUMBER()`で表示できますし、結果、`WHERE`句。</span><span class="sxs-lookup"><span data-stu-id="8ea05-212">However, a derived table can be used to return the `ROW_NUMBER()` result, which can then appear in the `WHERE` clause.</span></span> <span data-ttu-id="8ea05-213">次のクエリは派生テーブルを使用して、と共に、ProductName および [単価] 列を返すなど、`ROW_NUMBER()`結果、および、使用、`WHERE`句をのみこれらの製品価格ランクを返すの 11 ~ 20。</span><span class="sxs-lookup"><span data-stu-id="8ea05-213">For example, the following query uses a derived table to return the ProductName and UnitPrice columns, along with the `ROW_NUMBER()` result, and then uses a `WHERE` clause to only return those products whose price rank is between 11 and 20:</span></span>


[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample5.sql)]

<span data-ttu-id="8ea05-214">少しさらに、この概念を拡張するには、目的の行の開始インデックスと行の最大数の値を指定されたデータの特定のページを取得するには、この方法を利用できます。</span><span class="sxs-lookup"><span data-stu-id="8ea05-214">Extending this concept a bit further, we can utilize this approach to retrieve a specific page of data given the desired Start Row Index and Maximum Rows values:</span></span>


[!code-html[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample6.html)]

> [!NOTE]
> <span data-ttu-id="8ea05-215">このチュートリアルで後でわかりますが、 *`StartRowIndex`* によって提供される ObjectDataSource のインデックスは、0 から始まる一方、 `ROW_NUMBER()` SQL Server 2005 によって返される値は 1 から始まるインデックスします。</span><span class="sxs-lookup"><span data-stu-id="8ea05-215">As we will see later on in this tutorial, the *`StartRowIndex`* supplied by the ObjectDataSource is indexed starting at zero, whereas the `ROW_NUMBER()` value returned by SQL Server 2005 is indexed starting at 1.</span></span> <span data-ttu-id="8ea05-216">そのため、`WHERE`句は、これらのレコードを返します場所`PriceRank`より厳密に大きい*`StartRowIndex`* 以下と等しい、 *`StartRowIndex`*  + *`MaximumRows`*.</span><span class="sxs-lookup"><span data-stu-id="8ea05-216">Therefore, the `WHERE` clause returns those records where `PriceRank` is strictly greater than *`StartRowIndex`* and less than or equal to *`StartRowIndex`* + *`MaximumRows`*.</span></span>


<span data-ttu-id="8ea05-217">これまで方法を説明してきた`ROW_NUMBER()`できる、開始行インデックスと行の最大数の値を指定されたデータの特定のページを取得するため、今すぐ必要があります DAL BLL 内のメソッドとしてこのロジックを実装します。</span><span class="sxs-lookup"><span data-stu-id="8ea05-217">Now that we ve discussed how `ROW_NUMBER()` can be used to retrieve a particular page of data given the Start Row Index and Maximum Rows values, we now need to implement this logic as methods in the DAL and BLL.</span></span>

<span data-ttu-id="8ea05-218">順序を決定しなければ、このクエリを作成するときに、結果が順位付けします。s、製品の名前がアルファベット順で並べ替えることができます。</span><span class="sxs-lookup"><span data-stu-id="8ea05-218">When creating this query we must decide the ordering by which the results will be ranked; let s sort the products by their name in alphabetical order.</span></span> <span data-ttu-id="8ea05-219">つまり、このチュートリアルではカスタム ページングの実装ではできませんを並べ替えることができますもよりも、カスタム ページ分けしたレポートを作成できません。</span><span class="sxs-lookup"><span data-stu-id="8ea05-219">This means that with the custom paging implementation in this tutorial we will not be able to create a custom paged report than can also be sorted.</span></span> <span data-ttu-id="8ea05-220">次のチュートリアルでは、見ていく方法、このような機能を提供できます。</span><span class="sxs-lookup"><span data-stu-id="8ea05-220">In the next tutorial, though, we'll see how such functionality can be provided.</span></span>

<span data-ttu-id="8ea05-221">前のセクションでは、アドホック SQL ステートメントとして DAL メソッドを作成しました。</span><span class="sxs-lookup"><span data-stu-id="8ea05-221">In the previous section we created the DAL method as an ad-hoc SQL statement.</span></span> <span data-ttu-id="8ea05-222">残念ながら、T-SQL パーサーのように TableAdapter ウィザードは t によって使用される Visual Studio で、`OVER`で使用される構文、`ROW_NUMBER()`関数。</span><span class="sxs-lookup"><span data-stu-id="8ea05-222">Unfortunately, the T-SQL parser in Visual Studio used by the TableAdapter wizard doesn t like the `OVER` syntax used by the `ROW_NUMBER()` function.</span></span> <span data-ttu-id="8ea05-223">そのため、ストアド プロシージャとしてこの DAL メソッドを作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8ea05-223">Therefore, we must create this DAL method as a stored procedure.</span></span> <span data-ttu-id="8ea05-224">[表示] メニュー (またはヒット Ctrl + Alt + S) からサーバー エクスプ ローラーを選択し、展開、`NORTHWND.MDF`ノード。</span><span class="sxs-lookup"><span data-stu-id="8ea05-224">Select the Server Explorer from the View menu (or hit Ctrl+Alt+S) and expand the `NORTHWND.MDF` node.</span></span> <span data-ttu-id="8ea05-225">新しいストアド プロシージャを追加するストアド プロシージャ ノードを右クリックし、新しいストアド プロシージャの追加を選択 (図 6 参照)。</span><span class="sxs-lookup"><span data-stu-id="8ea05-225">To add a new stored procedure, right-click on the Stored Procedures node and choose Add a New Stored Procedure (see Figure 6).</span></span>


![新しいストアド プロシージャを製品を使用するページングの追加します。](efficiently-paging-through-large-amounts-of-data-vb/_static/image6.png)

<span data-ttu-id="8ea05-227">**図 6**: 製品のページングの新しいストアド プロシージャを追加</span><span class="sxs-lookup"><span data-stu-id="8ea05-227">**Figure 6**: Add a New Stored Procedure for Paging Through the Products</span></span>


<span data-ttu-id="8ea05-228">このストアド プロシージャは、2 つの整数の入力パラメーター - を受け入れる必要があります`@startRowIndex`と`@maximumRows`を使用して、`ROW_NUMBER()`関数に並べ、`ProductName`フィールドに、指定したより大きい行のみを返す`@startRowIndex`と未満または等しい`@startRowIndex`  +  `@maximumRow`秒。</span><span class="sxs-lookup"><span data-stu-id="8ea05-228">This stored procedure should accept two integer input parameters - `@startRowIndex` and `@maximumRows` and use the `ROW_NUMBER()` function ordered by the `ProductName` field, returning only those rows greater than the specified `@startRowIndex` and less than or equal to `@startRowIndex` + `@maximumRow` s.</span></span> <span data-ttu-id="8ea05-229">新しいストアド プロシージャに次のスクリプトを入力し、データベースにストアド プロシージャを追加する [保存] アイコンをクリックします。</span><span class="sxs-lookup"><span data-stu-id="8ea05-229">Enter the following script into the new stored procedure and then click the Save icon to add the stored procedure to the database.</span></span>


[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample7.sql)]

<span data-ttu-id="8ea05-230">ストアド プロシージャを作成すると、少しテストしてみましょう。右クリックし、`GetProductsPaged`ストアド プロシージャのサーバー エクスプ ローラーでの名前および Execute オプションを選択します。</span><span class="sxs-lookup"><span data-stu-id="8ea05-230">After creating the stored procedure, take a moment to test it out. Right-click on the `GetProductsPaged` stored procedure name in the Server Explorer and choose the Execute option.</span></span> <span data-ttu-id="8ea05-231">Visual Studio から求められます、入力パラメーターの`@startRowIndex`と`@maximumRow`s (図 7 を参照してください)。</span><span class="sxs-lookup"><span data-stu-id="8ea05-231">Visual Studio will then prompt you for the input parameters, `@startRowIndex` and `@maximumRow` s (see Figure 7).</span></span> <span data-ttu-id="8ea05-232">値を変化し、結果を確認します。</span><span class="sxs-lookup"><span data-stu-id="8ea05-232">Try different values and examine the results.</span></span>


![値を入力、@startRowIndexと@maximumRowsパラメーター](efficiently-paging-through-large-amounts-of-data-vb/_static/image7.png)

<span data-ttu-id="8ea05-234"><strong>図 7</strong>: の値を入力、@startRowIndexと@maximumRowsパラメーター</span><span class="sxs-lookup"><span data-stu-id="8ea05-234"><strong>Figure 7</strong>: Enter a Value for the @startRowIndex and @maximumRows Parameters</span></span>


<span data-ttu-id="8ea05-235">後のパラメーターの値を入力してこれらの選択、結果を出力ウィンドウが表示されます。</span><span class="sxs-lookup"><span data-stu-id="8ea05-235">After choosing these input parameters values, the Output window will show the results.</span></span> <span data-ttu-id="8ea05-236">図 8 は、10 の両方を渡すときに結果を示しています、`@startRowIndex`と`@maximumRows`パラメーター。</span><span class="sxs-lookup"><span data-stu-id="8ea05-236">Figure 8 shows the results when passing in 10 for both the `@startRowIndex` and `@maximumRows` parameters.</span></span>


<span data-ttu-id="8ea05-237">[![レコードに含まれる 2 番目のページ データが返されます](efficiently-paging-through-large-amounts-of-data-vb/_static/image9.png)](efficiently-paging-through-large-amounts-of-data-vb/_static/image8.png)</span><span class="sxs-lookup"><span data-stu-id="8ea05-237">[![The Records That Would Appear in the Second Page of Data are Returned](efficiently-paging-through-large-amounts-of-data-vb/_static/image9.png)](efficiently-paging-through-large-amounts-of-data-vb/_static/image8.png)</span></span>

<span data-ttu-id="8ea05-238">**図 8**:、レコードに含まれる 2 番目のページ データが返されます ([フルサイズの画像を表示する をクリックします](efficiently-paging-through-large-amounts-of-data-vb/_static/image10.png))。</span><span class="sxs-lookup"><span data-stu-id="8ea05-238">**Figure 8**: The Records That Would Appear in the Second Page of Data are Returned ([Click to view full-size image](efficiently-paging-through-large-amounts-of-data-vb/_static/image10.png))</span></span>


<span data-ttu-id="8ea05-239">これで作成されるストアド プロシージャを作成する準備ができたら、`ProductsTableAdapter`メソッド。</span><span class="sxs-lookup"><span data-stu-id="8ea05-239">With this stored procedure created, we re ready to create the `ProductsTableAdapter` method.</span></span> <span data-ttu-id="8ea05-240">開く、`Northwind.xsd`で右クリックして、型指定されたデータセット、`ProductsTableAdapter`クエリの追加オプションを選択します。</span><span class="sxs-lookup"><span data-stu-id="8ea05-240">Open the `Northwind.xsd` Typed DataSet, right-click in the `ProductsTableAdapter`, and choose the Add Query option.</span></span> <span data-ttu-id="8ea05-241">アドホック SQL ステートメントを使用してクエリを作成する代わりには、既存のストアド プロシージャを使用してそれを作成します。</span><span class="sxs-lookup"><span data-stu-id="8ea05-241">Instead of creating the query using an ad-hoc SQL statement, create it using an existing stored procedure.</span></span>


![既存のストアド プロシージャを使用して、DAL メソッドの作成します。](efficiently-paging-through-large-amounts-of-data-vb/_static/image11.png)

<span data-ttu-id="8ea05-243">**図 9**: 既存のストアド プロシージャを使用して、DAL メソッドの作成</span><span class="sxs-lookup"><span data-stu-id="8ea05-243">**Figure 9**: Create the DAL Method Using an Existing Stored Procedure</span></span>


<span data-ttu-id="8ea05-244">次に、呼び出すストアド プロシージャを選択するように求められます。</span><span class="sxs-lookup"><span data-stu-id="8ea05-244">Next, we are prompted to select the stored procedure to invoke.</span></span> <span data-ttu-id="8ea05-245">選択、`GetProductsPaged`ストアド プロシージャをドロップダウン リストから。</span><span class="sxs-lookup"><span data-stu-id="8ea05-245">Pick the `GetProductsPaged` stored procedure from the drop-down list.</span></span>


![選択、GetProductsPaged ストアド プロシージャをドロップダウン リストから](efficiently-paging-through-large-amounts-of-data-vb/_static/image12.png)

<span data-ttu-id="8ea05-247">**図 10**: 選択、GetProductsPaged ストアド プロシージャをドロップダウン リストから</span><span class="sxs-lookup"><span data-stu-id="8ea05-247">**Figure 10**: Choose the GetProductsPaged Stored Procedure from the Drop-Down List</span></span>


<span data-ttu-id="8ea05-248">次の画面で、要求するデータの種類は、ストアド プロシージャによって返される: 表形式のデータ、1 つの値または値はありません。</span><span class="sxs-lookup"><span data-stu-id="8ea05-248">The next screen then asks you what kind of data is returned by the stored procedure: tabular data, a single value, or no value.</span></span> <span data-ttu-id="8ea05-249">以降、`GetProductsPaged`ストアド プロシージャが複数のレコードが返される、表形式のデータを返すことを示します。</span><span class="sxs-lookup"><span data-stu-id="8ea05-249">Since the `GetProductsPaged` stored procedure can return multiple records, indicate that it returns tabular data.</span></span>


![ストアド プロシージャが表形式のデータを返すことを示します](efficiently-paging-through-large-amounts-of-data-vb/_static/image13.png)

<span data-ttu-id="8ea05-251">**図 11**: ストアド プロシージャが表形式のデータを返すことを示します</span><span class="sxs-lookup"><span data-stu-id="8ea05-251">**Figure 11**: Indicate that the Stored Procedure Returns Tabular Data</span></span>


<span data-ttu-id="8ea05-252">最後に、作成するメソッドの名前を指定します。</span><span class="sxs-lookup"><span data-stu-id="8ea05-252">Finally, indicate the names of the methods you want to have created.</span></span> <span data-ttu-id="8ea05-253">前のチュートリアルとしてください DataTable を返すメソッドの両方の塗りつぶしを使用して DataTable を作成します。</span><span class="sxs-lookup"><span data-stu-id="8ea05-253">As with our previous tutorials, go ahead and create methods using both the Fill a DataTable and Return a DataTable.</span></span> <span data-ttu-id="8ea05-254">最初のメソッドの名前を付けます`FillPaged`、もう 1 つ`GetProductsPaged`します。</span><span class="sxs-lookup"><span data-stu-id="8ea05-254">Name the first method `FillPaged` and the second `GetProductsPaged`.</span></span>


![名前のメソッド FillPaged と GetProductsPaged](efficiently-paging-through-large-amounts-of-data-vb/_static/image14.png)

<span data-ttu-id="8ea05-256">**図 12**: 名メソッド FillPaged と GetProductsPaged</span><span class="sxs-lookup"><span data-stu-id="8ea05-256">**Figure 12**: Name the Methods FillPaged and GetProductsPaged</span></span>


<span data-ttu-id="8ea05-257">さらに、製品の特定のページを返す DAL メソッドを作成する必要もあります BLL にこのような機能を提供します。</span><span class="sxs-lookup"><span data-stu-id="8ea05-257">In addition to created a DAL method to return a particular page of products, we also need to provide such functionality in the BLL.</span></span> <span data-ttu-id="8ea05-258">DAL のメソッドと同様 BLL の GetProductsPaged メソッドは、開始行インデックスと行の最大数を指定するための 2 つの整数入力を受け入れる必要があり、指定した範囲内にあるレコードだけを返す必要があります。</span><span class="sxs-lookup"><span data-stu-id="8ea05-258">Like the DAL method, the BLL s GetProductsPaged method must accept two integer inputs for specifying the Start Row Index and Maximum Rows, and must return just those records that fall within the specified range.</span></span> <span data-ttu-id="8ea05-259">DAL の GetProductsPaged メソッドにダウン呼び出しだけでそのように ProductsBLL クラスで BLL のメソッドを作成します。</span><span class="sxs-lookup"><span data-stu-id="8ea05-259">Create such a BLL method in the ProductsBLL class that merely calls down into the DAL s GetProductsPaged method, like so:</span></span>


[!code-vb[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample8.vb)]

<span data-ttu-id="8ea05-260">任意の名前を使用する BLL メソッドの入力パラメーターは、使用する選択が、まもなく、わかります`startRowIndex`と`maximumRows`余分なから起きなくのこのメソッドを使用して、ObjectDataSource を構成するときに作業します。</span><span class="sxs-lookup"><span data-stu-id="8ea05-260">You can use any name for the BLL method s input parameters, but, as we will see shortly, choosing to use `startRowIndex` and `maximumRows` saves us from an extra bit of work when configuring an ObjectDataSource to use this method.</span></span>

## <a name="step-4-configuring-the-objectdatasource-to-use-custom-paging"></a><span data-ttu-id="8ea05-261">手順 4: カスタム ページングを使用して ObjectDataSource を構成します。</span><span class="sxs-lookup"><span data-stu-id="8ea05-261">Step 4: Configuring the ObjectDataSource to Use Custom Paging</span></span>

<span data-ttu-id="8ea05-262">完全なレコードの特定のサブセットにアクセスするための BLL と DAL メソッドを使ってカスタム ページングを使用して、基になるレコードからそのページを制御 GridView を作成する準備が整いました。</span><span class="sxs-lookup"><span data-stu-id="8ea05-262">With the BLL and DAL methods for accessing a particular subset of records complete, we re ready to create a GridView control that pages through its underlying records using custom paging.</span></span> <span data-ttu-id="8ea05-263">開いて開始、`EfficientPaging.aspx`ページで、`PagingAndSorting`フォルダーは、ページに GridView を追加し、新しい ObjectDataSource コントロールを使用するように構成します。</span><span class="sxs-lookup"><span data-stu-id="8ea05-263">Start by opening the `EfficientPaging.aspx` page in the `PagingAndSorting` folder, add a GridView to the page, and configure it to use a new ObjectDataSource control.</span></span> <span data-ttu-id="8ea05-264">過去のチュートリアルでは、多くの場合がありました ObjectDataSource を使用するように構成、`ProductsBLL`クラスの`GetProducts`メソッド。</span><span class="sxs-lookup"><span data-stu-id="8ea05-264">In our past tutorials, we often had the ObjectDataSource configured to use the `ProductsBLL` class s `GetProducts` method.</span></span> <span data-ttu-id="8ea05-265">今回は、ただし、使用する、`GetProductsPaged`メソッド代わりに、以降、`GetProducts`メソッドを返します。*すべて*データベースでは、製品の一方`GetProductsPaged`レコードの特定のサブセットだけを返します。</span><span class="sxs-lookup"><span data-stu-id="8ea05-265">This time, however, we want to use the `GetProductsPaged` method instead, since the `GetProducts` method returns *all* of the products in the database whereas `GetProductsPaged` returns just a particular subset of records.</span></span>


![ObjectDataSource ProductsBLL クラスの GetProductsPaged メソッドを使用して構成します。](efficiently-paging-through-large-amounts-of-data-vb/_static/image15.png)

<span data-ttu-id="8ea05-267">**図 13**: ProductsBLL クラスの GetProductsPaged メソッドを使用して ObjectDataSource を構成します。</span><span class="sxs-lookup"><span data-stu-id="8ea05-267">**Figure 13**: Configure the ObjectDataSource to Use the ProductsBLL Class s GetProductsPaged Method</span></span>


<span data-ttu-id="8ea05-268">以降再読み取り専用の GridView を作成するには、INSERT、UPDATE でメソッドのドロップダウン リストを設定する少しし、(None) にタブを削除します。</span><span class="sxs-lookup"><span data-stu-id="8ea05-268">Since we re creating a read-only GridView, take a moment to set the method drop-down list in the INSERT, UPDATE, and DELETE tabs to (None).</span></span>

<span data-ttu-id="8ea05-269">次のソースの ObjectDataSource ウィザード要求私たち、`GetProductsPaged`メソッド s`startRowIndex`と`maximumRows`パラメーターの値を入力します。</span><span class="sxs-lookup"><span data-stu-id="8ea05-269">Next, the ObjectDataSource wizard prompts us for the sources of the `GetProductsPaged` method s `startRowIndex` and `maximumRows` input parameters values.</span></span> <span data-ttu-id="8ea05-270">これらの入力パラメーターは、GridView で、自動的には設定実際には、単純に [なし] に、元のまま、[完了] をクリックします。</span><span class="sxs-lookup"><span data-stu-id="8ea05-270">These input parameters will actually be set by the GridView automatically, so simply leave the source set to None and click Finish.</span></span>


![入力パラメーターのソースを None のままにします](efficiently-paging-through-large-amounts-of-data-vb/_static/image16.png)

<span data-ttu-id="8ea05-272">**図 14**: 入力パラメーターのソースを None のままにします</span><span class="sxs-lookup"><span data-stu-id="8ea05-272">**Figure 14**: Leave the Input Parameter Sources as None</span></span>


<span data-ttu-id="8ea05-273">ObjectDataSource ウィザードの完了後は、GridView は各製品のデータ フィールドのも、BoundField または CheckBoxField に含まれます。</span><span class="sxs-lookup"><span data-stu-id="8ea05-273">After completing the ObjectDataSource wizard, the GridView will contain a BoundField or CheckBoxField for each of the product data fields.</span></span> <span data-ttu-id="8ea05-274">自由に、必要に応じて、GridView の外観を調整できます。</span><span class="sxs-lookup"><span data-stu-id="8ea05-274">Feel free to tailor the GridView s appearance as you see fit.</span></span> <span data-ttu-id="8ea05-275">のみを表示することを選択したら、 `ProductName`、 `CategoryName`、 `SupplierName`、 `QuantityPerUnit`、および`UnitPrice`BoundFields します。</span><span class="sxs-lookup"><span data-stu-id="8ea05-275">I ve opted to display only the `ProductName`, `CategoryName`, `SupplierName`, `QuantityPerUnit`, and `UnitPrice` BoundFields.</span></span> <span data-ttu-id="8ea05-276">また、そのスマート タグでページングを有効にするチェック ボックスをオンにページングをサポートするために、GridView を構成します。</span><span class="sxs-lookup"><span data-stu-id="8ea05-276">Also, configure the GridView to support paging by checking the Enable Paging checkbox in its smart tag.</span></span> <span data-ttu-id="8ea05-277">これらの変更後に GridView コントロールと ObjectDataSource 宣言型マークアップを次のようになります。</span><span class="sxs-lookup"><span data-stu-id="8ea05-277">After these changes, the GridView and ObjectDataSource declarative markup should look similar to the following:</span></span>


[!code-aspx[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample9.aspx)]

<span data-ttu-id="8ea05-278">ブラウザーを使用してページを閲覧する場合、GridView はありません場所を検索します。</span><span class="sxs-lookup"><span data-stu-id="8ea05-278">If you visit the page through a browser, however, the GridView is no where to be found.</span></span>


![GridView は表示されません。](efficiently-paging-through-large-amounts-of-data-vb/_static/image17.png)

<span data-ttu-id="8ea05-280">**図 15**: GridView は表示されません</span><span class="sxs-lookup"><span data-stu-id="8ea05-280">**Figure 15**: The GridView is Not Displayed</span></span>


<span data-ttu-id="8ea05-281">ObjectDataSource は両方の値として 0 を現在使用されているので、GridView が不足しているが、 `GetProductsPaged` `startRowIndex`と`maximumRows`パラメーターを入力します。</span><span class="sxs-lookup"><span data-stu-id="8ea05-281">The GridView is missing because the ObjectDataSource is currently using 0 as the values for both of the `GetProductsPaged` `startRowIndex` and `maximumRows` input parameters.</span></span> <span data-ttu-id="8ea05-282">そのため、SQL クエリの結果は、レコードを返さないされ、したがって、GridView は表示されません。</span><span class="sxs-lookup"><span data-stu-id="8ea05-282">Hence, the resulting SQL query is returning no records and therefore the GridView is not displayed.</span></span>

<span data-ttu-id="8ea05-283">これを解決するには、カスタム ページングを使用して ObjectDataSource を構成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8ea05-283">To remedy this, we need to configure the ObjectDataSource to use custom paging.</span></span> <span data-ttu-id="8ea05-284">これは、次の手順で実行できます。</span><span class="sxs-lookup"><span data-stu-id="8ea05-284">This can be accomplished in the following steps:</span></span>

1. <span data-ttu-id="8ea05-285">**ObjectDataSource s 設定`EnablePaging`プロパティを`true`** に渡す必要があります、ObjectDataSource にこれを示します、 `SelectMethod` 2 つのパラメーター: 開始行インデックスを指定する 1 つ ([ `StartRowIndexParameterName` ](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.startrowindexparametername.aspx))、行の最大数を指定する 1 つ ([`MaximumRowsParameterName`](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.maximumrowsparametername.aspx))。</span><span class="sxs-lookup"><span data-stu-id="8ea05-285">**Set the ObjectDataSource s `EnablePaging` property to `true`** this indicates to the ObjectDataSource that it must pass to the `SelectMethod` two additional parameters: one to specify the Start Row Index ([`StartRowIndexParameterName`](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.startrowindexparametername.aspx)), and one to specify the Maximum Rows ([`MaximumRowsParameterName`](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.maximumrowsparametername.aspx)).</span></span>
2. <span data-ttu-id="8ea05-286">**ObjectDataSource s を設定`StartRowIndexParameterName`と`MaximumRowsParameterName`プロパティに応じて**、`StartRowIndexParameterName`と`MaximumRowsParameterName`プロパティに渡される入力パラメーターの名前を示すため、`SelectMethod`用カスタム ページングします。</span><span class="sxs-lookup"><span data-stu-id="8ea05-286">**Set the ObjectDataSource s `StartRowIndexParameterName` and `MaximumRowsParameterName` Properties Accordingly** the `StartRowIndexParameterName` and `MaximumRowsParameterName` properties indicate the names of the input parameters passed into the `SelectMethod` for custom paging purposes.</span></span> <span data-ttu-id="8ea05-287">これらのパラメーター名では既定では、`startIndexRow`と`maximumRows`、これは、理由を作成するとき、`GetProductsPaged`メソッドで BLL は、入力パラメーターのこれらの値を使用しました。</span><span class="sxs-lookup"><span data-stu-id="8ea05-287">By default, these parameter names are `startIndexRow` and `maximumRows`, which is why, when creating the `GetProductsPaged` method in the BLL, I used these values for the input parameters.</span></span> <span data-ttu-id="8ea05-288">BLL s のさまざまなパラメーター名を使用する場合`GetProductsPaged`などのメソッド`startIndex`と`maxRows`しなければならなくなります例 ObjectDataSource s の設定、`StartRowIndexParameterName`と`MaximumRowsParameterName`プロパティに応じて (などの startIndex`StartRowIndexParameterName`およびの maxRows `MaximumRowsParameterName`)。</span><span class="sxs-lookup"><span data-stu-id="8ea05-288">If you chose to use different parameter names for the BLL s `GetProductsPaged` method such as `startIndex` and `maxRows`, for example you would need to set the ObjectDataSource s `StartRowIndexParameterName` and `MaximumRowsParameterName` properties accordingly (such as startIndex for `StartRowIndexParameterName` and maxRows for `MaximumRowsParameterName`).</span></span>
3. <span data-ttu-id="8ea05-289">**ObjectDataSource s 設定[`SelectCountMethod`プロパティ](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.selectcountmethod(VS.80).aspx)を合計数のレコードされているページを返すメソッドの名前に (`TotalNumberOfProducts`)** を思い出してください、`ProductsBLL`クラスの`TotalNumberOfProducts`メソッドを実行する DAL メソッドを使用して、ページングされるレコードの合計数を返します、`SELECT COUNT(*) FROM Products`クエリ。</span><span class="sxs-lookup"><span data-stu-id="8ea05-289">**Set the ObjectDataSource s [`SelectCountMethod` Property](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.selectcountmethod(VS.80).aspx) to the Name of the Method that Returns the Total Number of Records Being Paged Through (`TotalNumberOfProducts`)** recall that the `ProductsBLL` class s `TotalNumberOfProducts` method returns the total number of records being paged through using a DAL method that executes a `SELECT COUNT(*) FROM Products` query.</span></span> <span data-ttu-id="8ea05-290">この情報は、ObjectDataSource 正しくページング インターフェイスを表示するために必要です。</span><span class="sxs-lookup"><span data-stu-id="8ea05-290">This information is needed by the ObjectDataSource in order to correctly render the paging interface.</span></span>
4. <span data-ttu-id="8ea05-291">**削除、`startRowIndex`と`maximumRows` `<asp:Parameter>` ObjectDataSource s 宣言型マークアップから要素**ウィザードで ObjectDataSource を構成するときに Visual Studio に自動的に追加されました 2 つ`<asp:Parameter>`要素`GetProductsPaged`メソッドのパラメーターを入力します。</span><span class="sxs-lookup"><span data-stu-id="8ea05-291">**Remove the `startRowIndex` and `maximumRows` `<asp:Parameter>` Elements from the ObjectDataSource s Declarative Markup** when configuring the ObjectDataSource through the wizard, Visual Studio automatically added two `<asp:Parameter>` elements for the `GetProductsPaged` method s input parameters.</span></span> <span data-ttu-id="8ea05-292">設定して`EnablePaging`に`true`、これらのパラメーターが自動的に渡される; ObjectDataSource は渡すしようとしても宣言構文内で現れる場合*4*パラメーターを`GetProductsPaged`メソッド2 つのパラメーターと、`TotalNumberOfProducts`メソッド。</span><span class="sxs-lookup"><span data-stu-id="8ea05-292">By setting `EnablePaging` to `true`, these parameters will be passed automatically; if they also appear in the declarative syntax, the ObjectDataSource will attempt to pass *four* parameters to the `GetProductsPaged` method and two parameters to the `TotalNumberOfProducts` method.</span></span> <span data-ttu-id="8ea05-293">これらを削除するを忘れた場合`<asp:Parameter>`などのエラー メッセージが届きますブラウザーを使用してページにアクセスすると、要素: *ObjectDataSource 'ObjectDataSource1' は、非ジェネリック メソッドの 'TotalNumberOfProducts' を持つを特定できませんでしたパラメーター: startRowIndex、maximumRows*します。</span><span class="sxs-lookup"><span data-stu-id="8ea05-293">If you forget to remove these `<asp:Parameter>` elements, when visiting the page through a browser you'll get an error message like: *ObjectDataSource 'ObjectDataSource1' could not find a non-generic method 'TotalNumberOfProducts' that has parameters: startRowIndex, maximumRows*.</span></span>

<span data-ttu-id="8ea05-294">これらの変更を行った後、次のよう ObjectDataSource s の宣言型構文になります。</span><span class="sxs-lookup"><span data-stu-id="8ea05-294">After making these changes, the ObjectDataSource s declarative syntax should look like the following:</span></span>


[!code-aspx[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample10.aspx)]

<span data-ttu-id="8ea05-295">なお、`EnablePaging`と`SelectCountMethod`プロパティが設定されていると、`<asp:Parameter>`要素が削除されました。</span><span class="sxs-lookup"><span data-stu-id="8ea05-295">Note that the `EnablePaging` and `SelectCountMethod` properties have been set and the `<asp:Parameter>` elements have been removed.</span></span> <span data-ttu-id="8ea05-296">図 16 は、これらの変更が行われた後に、[プロパティ] ウィンドウのスクリーン ショットを示します。</span><span class="sxs-lookup"><span data-stu-id="8ea05-296">Figure 16 shows a screen shot of the Properties window after these changes have been made.</span></span>


![カスタム ページングを使用するには、ObjectDataSource コントロールを構成します。](efficiently-paging-through-large-amounts-of-data-vb/_static/image18.png)

<span data-ttu-id="8ea05-298">**図 16**: カスタム ページングを使用するには、ObjectDataSource コントロールを構成します。</span><span class="sxs-lookup"><span data-stu-id="8ea05-298">**Figure 16**: To Use Custom Paging, Configure the ObjectDataSource Control</span></span>


<span data-ttu-id="8ea05-299">これらの変更を行った後は、ブラウザーからこのページを参照してください。</span><span class="sxs-lookup"><span data-stu-id="8ea05-299">After making these changes, visit this page through a browser.</span></span> <span data-ttu-id="8ea05-300">表示されている場合、10 個の製品が表示アルファベット順でします。</span><span class="sxs-lookup"><span data-stu-id="8ea05-300">You should see 10 products listed, ordered alphabetically.</span></span> <span data-ttu-id="8ea05-301">一度にデータの 1 つのページをステップに時間がかかります。</span><span class="sxs-lookup"><span data-stu-id="8ea05-301">Take a moment to step through the data one page at a time.</span></span> <span data-ttu-id="8ea05-302">エンドユーザーの観点から既定のページングとカスタム ページングの視覚的な違いはありませんが、カスタム ページングをより効率的のページを大量データのように、特定のページに表示する必要があるレコードのみを取得します。</span><span class="sxs-lookup"><span data-stu-id="8ea05-302">While there is no visual difference from the end user s perspective between default paging and custom paging, custom paging more efficiently pages through large amounts of data as it only retrieves those records that need to be displayed for a given page.</span></span>


<span data-ttu-id="8ea05-303">[![製品名、Ordered、データを使用してカスタム ページングのページは、します。](efficiently-paging-through-large-amounts-of-data-vb/_static/image20.png)](efficiently-paging-through-large-amounts-of-data-vb/_static/image19.png)</span><span class="sxs-lookup"><span data-stu-id="8ea05-303">[![The Data, Ordered by the Product s Name, is Paged Using Custom Paging](efficiently-paging-through-large-amounts-of-data-vb/_static/image20.png)](efficiently-paging-through-large-amounts-of-data-vb/_static/image19.png)</span></span>

<span data-ttu-id="8ea05-304">**図 17**: データ、製品名、Ordered、ページングを使用してのカスタム ページング ([フルサイズの画像を表示する をクリックします](efficiently-paging-through-large-amounts-of-data-vb/_static/image21.png))。</span><span class="sxs-lookup"><span data-stu-id="8ea05-304">**Figure 17**: The Data, Ordered by the Product s Name, is Paged Using Custom Paging ([Click to view full-size image](efficiently-paging-through-large-amounts-of-data-vb/_static/image21.png))</span></span>


> [!NOTE]
> <span data-ttu-id="8ea05-305">カスタムのページングを使用したページは ObjectDataSource s によって返される値をカウント`SelectCountMethod`GridView のビュー ステートに格納されます。</span><span class="sxs-lookup"><span data-stu-id="8ea05-305">With custom paging, the page count value returned by the ObjectDataSource�s `SelectCountMethod` is stored in the GridView�s view state.</span></span> <span data-ttu-id="8ea05-306">他の変数の GridView、 `PageIndex`、 `EditIndex`、 `SelectedIndex`、`DataKeys`コレクション、および具合に格納されている*コントロールの状態*、GridView 秒の値に関係なく保持する`EnableViewState`プロパティ。</span><span class="sxs-lookup"><span data-stu-id="8ea05-306">Other GridView variables the `PageIndex`, `EditIndex`, `SelectedIndex`, `DataKeys` collection, and so on are stored in *control state*, which is persisted regardless of the value of the GridView�s `EnableViewState` property.</span></span> <span data-ttu-id="8ea05-307">`PageCount`値が永続化される最後のページに移動するリンクを含むページング インターフェイスを使用する場合は、ビュー ステートを使用して、ポストバック間で、GridView ビュー状態が有効にすることが重要です。</span><span class="sxs-lookup"><span data-stu-id="8ea05-307">Since the `PageCount` value is persisted across postbacks using view state, when using a paging interface that includes a link to take you to the last page, it is imperative that the GridView�s view state be enabled.</span></span> <span data-ttu-id="8ea05-308">(ページ、ページング インターフェイスは直接リンクを最後に含まれていない場合、ビュー ステートが無効にできます。)</span><span class="sxs-lookup"><span data-stu-id="8ea05-308">(If your paging interface does not include a direct link to the last page, then you may disable view state.)</span></span>


<span data-ttu-id="8ea05-309">最後のページ リンクをクリックすると、ポストバックが発生して、GridView を更新するように指示しますその`PageIndex`プロパティ。</span><span class="sxs-lookup"><span data-stu-id="8ea05-309">Clicking the last page link causes a postback and instructs the GridView to update its `PageIndex` property.</span></span> <span data-ttu-id="8ea05-310">GridView の割り当ての最後のページ リンクをクリックすると、その`PageIndex`プロパティをいずれかの値より小さい、`PageCount`プロパティ。</span><span class="sxs-lookup"><span data-stu-id="8ea05-310">If the last page link is clicked, the GridView assigns its `PageIndex` property to a value one less than its `PageCount` property.</span></span> <span data-ttu-id="8ea05-311">無効にすると、ビュー ステート、`PageCount`ポストバック間で値が失われることと`PageIndex`代わりに最大の整数値が代入されます。</span><span class="sxs-lookup"><span data-stu-id="8ea05-311">With view state disabled, the `PageCount` value is lost across postbacks and the `PageIndex` is assigned the maximum integer value instead.</span></span> <span data-ttu-id="8ea05-312">GridView が乗算することによって開始行インデックスを決定しようとした次に、`PageSize`と`PageCount`プロパティ。</span><span class="sxs-lookup"><span data-stu-id="8ea05-312">Next, the GridView attempts to determine the starting row index by multiplying the `PageSize` and `PageCount` properties.</span></span> <span data-ttu-id="8ea05-313">これは、結果、`OverflowException`のため、製品が許可されている整数値の最大サイズを超えています。</span><span class="sxs-lookup"><span data-stu-id="8ea05-313">This results in an `OverflowException` since the product exceeds the maximum allowed integer size.</span></span>

## <a name="implement-custom-paging-and-sorting"></a><span data-ttu-id="8ea05-314">カスタム ページングを実装および並べ替え</span><span class="sxs-lookup"><span data-stu-id="8ea05-314">Implement Custom Paging and Sorting</span></span>

<span data-ttu-id="8ea05-315">現在のカスタム ページングの実装では、を通じて、データをページングする順序が、作成するときに、静的に指定する必要があります、`GetProductsPaged`ストアド プロシージャ。</span><span class="sxs-lookup"><span data-stu-id="8ea05-315">Our current custom paging implementation requires that the order by which the data is paged through be specified statically when creating the `GetProductsPaged` stored procedure.</span></span> <span data-ttu-id="8ea05-316">ただし、GridView s のスマート タグがページングを有効にするオプションだけでなくで並べ替えを有効にするのチェック ボックスが含まれていることに注意が可能性があります。</span><span class="sxs-lookup"><span data-stu-id="8ea05-316">However, you may have noted that the GridView s smart tag contains an Enable Sorting checkbox in addition to the Enable Paging option.</span></span> <span data-ttu-id="8ea05-317">残念ながら、現在カスタム ページング実装を GridView に並べ替えのサポートを追加しても、データの現在表示されているページのレコードには並べ替えのみです。</span><span class="sxs-lookup"><span data-stu-id="8ea05-317">Unfortunately, adding sorting support to the GridView with our current custom paging implementation will only sort the records on the currently viewed page of data.</span></span> <span data-ttu-id="8ea05-318">などもページングをサポートし、製品名の降順で、データの最初のページを表示するときに並べ替え、GridView を構成する場合は、ページ 1 で、製品の順序が反転されます。</span><span class="sxs-lookup"><span data-stu-id="8ea05-318">For example, if you configure the GridView to also support paging and then, when viewing the first page of data, sort by product name in descending order, it will reverse the order of the products on page 1.</span></span> <span data-ttu-id="8ea05-319">無視、71 他の製品がアルファベット順に; マーガリン後に、逆のアルファベット順の順序で並べ替えるときに、最初の製品としてマーガリンを示しますこのような図 18 に示すよう最初のページのレコードだけが、並べ替え中と見なされます。</span><span class="sxs-lookup"><span data-stu-id="8ea05-319">As Figure 18 shows, such shows Carnarvon Tigers as the first product when sorting in reverse alphabetical order, which ignores the 71 other products that come after Carnarvon Tigers, alphabetically; only those records on the first page are considered in the sorting.</span></span>


<span data-ttu-id="8ea05-320">[![並べ替えられた、データにのみ表示されます、現在のページ](efficiently-paging-through-large-amounts-of-data-vb/_static/image23.png)](efficiently-paging-through-large-amounts-of-data-vb/_static/image22.png)</span><span class="sxs-lookup"><span data-stu-id="8ea05-320">[![Only the Data Shown on the Current Page is Sorted](efficiently-paging-through-large-amounts-of-data-vb/_static/image23.png)](efficiently-paging-through-large-amounts-of-data-vb/_static/image22.png)</span></span>

<span data-ttu-id="8ea05-321">**図 18**: のみ、データ ページに表示される、現在の並べ替え ([フルサイズの画像を表示する をクリックします](efficiently-paging-through-large-amounts-of-data-vb/_static/image24.png))。</span><span class="sxs-lookup"><span data-stu-id="8ea05-321">**Figure 18**: Only the Data Shown on the Current Page is Sorted ([Click to view full-size image](efficiently-paging-through-large-amounts-of-data-vb/_static/image24.png))</span></span>


<span data-ttu-id="8ea05-322">並べ替えのみデータの現在のページに適用されます、BLL s から、データが取得された後、並べ替えが行われているため、`GetProductsPaged`メソッド、およびこのメソッドは、特定のページのレコードを返しますのみです。</span><span class="sxs-lookup"><span data-stu-id="8ea05-322">The sorting only applies to the current page of data because the sorting is occurring after the data has been retrieved from the BLL s `GetProductsPaged` method, and this method only returns those records for the specific page.</span></span> <span data-ttu-id="8ea05-323">正しく並べ替えを実装する必要がある並べ替え式を渡す、`GetProductsPaged`メソッドのデータの特定のページを返す前に、データを適切に付けられるようにします。</span><span class="sxs-lookup"><span data-stu-id="8ea05-323">To implement sorting correctly, we need to pass the sort expression to the `GetProductsPaged` method so that the data can be ranked appropriately before returning the specific page of data.</span></span> <span data-ttu-id="8ea05-324">これで、次のチュートリアルを実行する方法を見ていきます。</span><span class="sxs-lookup"><span data-stu-id="8ea05-324">We'll see how to accomplish this in our next tutorial.</span></span>

## <a name="implementing-custom-paging-and-deleting"></a><span data-ttu-id="8ea05-325">カスタム ページングと削除を実装します。</span><span class="sxs-lookup"><span data-stu-id="8ea05-325">Implementing Custom Paging and Deleting</span></span>

<span data-ttu-id="8ea05-326">最後のページから最後のレコードを削除するときを検索、カスタムのページング手法を使用してデータをページング GridView で削除する機能を有効にする GridView が表示されなくなります適切にデクリメントする操作ではなく GridView の`PageIndex`.</span><span class="sxs-lookup"><span data-stu-id="8ea05-326">If you enabling deleting functionality in a GridView whose data is paged using custom paging techniques you will find that when deleting the last record from the last page, the GridView disappears rather than appropriately decrementing the GridView s `PageIndex`.</span></span> <span data-ttu-id="8ea05-327">このバグを再現するには、同様に先ほど作成したチュートリアルでは、削除を有効にします。</span><span class="sxs-lookup"><span data-stu-id="8ea05-327">To reproduce this bug, enable deleting for the tutorial just we just created.</span></span> <span data-ttu-id="8ea05-328">81 製品、一度に 10 個の製品をページングしますので、1 つの製品を表示する必要があります (9 ページ) の最後のページに移動します。</span><span class="sxs-lookup"><span data-stu-id="8ea05-328">Go to the last page (page 9), where you should see a single product since we are paging through 81 products, 10 products at a time.</span></span> <span data-ttu-id="8ea05-329">この製品を削除します。</span><span class="sxs-lookup"><span data-stu-id="8ea05-329">Delete this product.</span></span>

<span data-ttu-id="8ea05-330">最後の製品では、GridView を削除すると*は*8 番目のページに自動的に移動し、既定のページングを使用したこのような機能が発生しました。</span><span class="sxs-lookup"><span data-stu-id="8ea05-330">Upon deleting the last product, the GridView *should* automatically go to the eighth page, and such functionality is exhibited with default paging.</span></span> <span data-ttu-id="8ea05-331">カスタムのページングを使用したただし、最後のページでその最終製品を削除した後、GridView から消失する画面完全。</span><span class="sxs-lookup"><span data-stu-id="8ea05-331">With custom paging, however, after deleting that last product on the last page, the GridView simply disappears from the screen altogether.</span></span> <span data-ttu-id="8ea05-332">正確な理由*なぜ*これは、このチュートリアルの範囲を超えては少し; を参照してください[カスタム ページングを GridView から最後のページで、最後のレコードを削除する](http://scottonwriting.net/sowblog/posts/7326.aspx)ソースの低レベルの詳細この問題。</span><span class="sxs-lookup"><span data-stu-id="8ea05-332">The precise reason *why* this happens is a bit beyond the scope of this tutorial; see [Deleting the Last Record on the Last Page from a GridView with Custom Paging](http://scottonwriting.net/sowblog/posts/7326.aspx) for the low-level details as to the source of this problem.</span></span> <span data-ttu-id="8ea05-333">要約すると、次の一連の削除 ボタンがクリックされたときに、GridView が行う手順のための s:</span><span class="sxs-lookup"><span data-stu-id="8ea05-333">In summary it s due to the following sequence of steps that are performed by the GridView when the Delete button is clicked:</span></span>

1. <span data-ttu-id="8ea05-334">レコードを削除します。</span><span class="sxs-lookup"><span data-stu-id="8ea05-334">Delete the record</span></span>
2. <span data-ttu-id="8ea05-335">指定した表示する適切なレコードを取得する`PageIndex`と `PageSize`</span><span class="sxs-lookup"><span data-stu-id="8ea05-335">Get the appropriate records to display for the specified `PageIndex` and `PageSize`</span></span>
3. <span data-ttu-id="8ea05-336">確認、 `PageIndex` ; データ ソース内のデータのページ数を超えていない場合は、GridView s を減分は、自動的に`PageIndex`プロパティ</span><span class="sxs-lookup"><span data-stu-id="8ea05-336">Check to ensure that the `PageIndex` does not exceed the number of pages of data in the data source; if it does, automatically decrement the GridView s `PageIndex` property</span></span>
4. <span data-ttu-id="8ea05-337">データの適切なページを手順 2. で取得したレコードを使用して GridView にバインドします。</span><span class="sxs-lookup"><span data-stu-id="8ea05-337">Bind the appropriate page of data to the GridView using the records obtained in Step 2</span></span>

<span data-ttu-id="8ea05-338">そので手順 2、という事実から問題の原因、`PageIndex`は引き続き表示するレコードを取得するときに使用、`PageIndex`の最後のページが唯一のレコードが削除されただけです。</span><span class="sxs-lookup"><span data-stu-id="8ea05-338">The problem stems from the fact that in Step 2 the `PageIndex` used when grabbing the records to display is still the `PageIndex` of the last page whose sole record was just deleted.</span></span> <span data-ttu-id="8ea05-339">そのため、手順 2. で*ありません*データの最終ページには任意のレコードが含まれていないために、レコードが返されます。</span><span class="sxs-lookup"><span data-stu-id="8ea05-339">Therefore, in Step 2, *no* records are returned since that last page of data no longer contains any records.</span></span> <span data-ttu-id="8ea05-340">次に、手順 3 で、GridView は実現しています、`PageIndex`プロパティがデータ ソース内のページの総数よりも大きい (経過したら削除最後のページの最後のレコード) をデクリメントしますのでその`PageIndex`プロパティ。</span><span class="sxs-lookup"><span data-stu-id="8ea05-340">Then, in Step 3, the GridView realizes that its `PageIndex` property is greater than the total number of pages in the data source (since we ve deleted the last record in the last page) and therefore decrements its `PageIndex` property.</span></span> <span data-ttu-id="8ea05-341">手順 4. で、GridView が自体を手順 2.; で取得されたデータにバインドしようただし、レコードが返されなかった手順 2、したがって結果として空の GridView。</span><span class="sxs-lookup"><span data-stu-id="8ea05-341">In Step 4 the GridView attempts to bind itself to the data retrieved in Step 2; however, in Step 2 no records were returned, therefore resulting in an empty GridView.</span></span> <span data-ttu-id="8ea05-342">この問題は t サーフェスため、既定のページングを使用した手順 2. で*すべて*レコードがデータ ソースから取得されます。</span><span class="sxs-lookup"><span data-stu-id="8ea05-342">With default paging, this problem doesn t surface because in Step 2 *all* records are retrieved from the data source.</span></span>

<span data-ttu-id="8ea05-343">この問題を解決するのには、2 つがあります。</span><span class="sxs-lookup"><span data-stu-id="8ea05-343">To fix this we have two options.</span></span> <span data-ttu-id="8ea05-344">1 つは、GridView s のイベント ハンドラーを作成する`RowDeleted`だけ削除されたページに表示されていたレコードの数を決定するイベント ハンドラー。</span><span class="sxs-lookup"><span data-stu-id="8ea05-344">The first is to create an event handler for the GridView s `RowDeleted` event handler that determines how many records were displayed in the page that was just deleted.</span></span> <span data-ttu-id="8ea05-345">かどうか 1 つのレコードが削除されるだけでレコードが最後の 1 つをされている必要があるし、GridView s をデクリメントする必要があります`PageIndex`します。</span><span class="sxs-lookup"><span data-stu-id="8ea05-345">If there was only one record, then the record just deleted must have been the last one and we need to decrement the GridView s `PageIndex`.</span></span> <span data-ttu-id="8ea05-346">もちろん、のみ更新する、`PageIndex`ことで決定削除操作が実際に成功した場合、`e.Exception`プロパティは`null`します。</span><span class="sxs-lookup"><span data-stu-id="8ea05-346">Of course, we only want to update the `PageIndex` if the delete operation was actually successful, which can be determined by ensuring that the `e.Exception` property is `null`.</span></span>

<span data-ttu-id="8ea05-347">このアプローチは、更新されるため、`PageIndex`手順 1 の後、手順 2. の前にします。</span><span class="sxs-lookup"><span data-stu-id="8ea05-347">This approach works because it updates the `PageIndex` after Step 1 but before Step 2.</span></span> <span data-ttu-id="8ea05-348">そのため、手順 2 で、適切なレコード セットが返されます。</span><span class="sxs-lookup"><span data-stu-id="8ea05-348">Therefore, in Step 2, the appropriate set of records is returned.</span></span> <span data-ttu-id="8ea05-349">これを実現するには、次のようなコードを使用します。</span><span class="sxs-lookup"><span data-stu-id="8ea05-349">To accomplish this, use code like the following:</span></span>


[!code-vb[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample11.vb)]

<span data-ttu-id="8ea05-350">別の回避策は、ObjectDataSource s のイベント ハンドラーを作成する`RowDeleted`イベントを設定して、`AffectedRows`プロパティ値の 1 にします。</span><span class="sxs-lookup"><span data-stu-id="8ea05-350">An alternative workaround is to create an event handler for the ObjectDataSource s `RowDeleted` event and to set the `AffectedRows` property to a value of 1.</span></span> <span data-ttu-id="8ea05-351">GridView の更新手順 1. で (ただし、手順 2 でデータを再取得する前に) レコードを削除すると、その`PageIndex`プロパティの場合は、操作の影響を受けた 1 つまたは複数の行。</span><span class="sxs-lookup"><span data-stu-id="8ea05-351">After deleting the record in Step 1 (but before re-retrieving the data in Step 2), the GridView updates its `PageIndex` property if one or more rows were affected by the operation.</span></span> <span data-ttu-id="8ea05-352">ただし、 `AffectedRows` ObjectDataSource でプロパティが設定されていないと、そのためこの手順を省略するとします。</span><span class="sxs-lookup"><span data-stu-id="8ea05-352">However, the `AffectedRows` property is not set by the ObjectDataSource and therefore this step is omitted.</span></span> <span data-ttu-id="8ea05-353">この手順を実行する方法の 1 つが手動で設定するには、`AffectedRows`プロパティの場合は、削除操作が正常に完了します。</span><span class="sxs-lookup"><span data-stu-id="8ea05-353">One way to have this step executed is to manually set the `AffectedRows` property if the delete operation completes successfully.</span></span> <span data-ttu-id="8ea05-354">これは、次のようなコードを使用して実行できます。</span><span class="sxs-lookup"><span data-stu-id="8ea05-354">This can be accomplished using code like the following:</span></span>


[!code-vb[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample12.vb)]

<span data-ttu-id="8ea05-355">これらのイベント ハンドラーの両方のコードの分離コード クラスで見つかる、`EfficientPaging.aspx`例。</span><span class="sxs-lookup"><span data-stu-id="8ea05-355">The code for both of these events handlers can be found in code-behind class of the `EfficientPaging.aspx` example.</span></span>

## <a name="comparing-the-performance-of-default-and-custom-paging"></a><span data-ttu-id="8ea05-356">既定およびカスタム ページングのパフォーマンスを比較します。</span><span class="sxs-lookup"><span data-stu-id="8ea05-356">Comparing the Performance of Default and Custom Paging</span></span>

<span data-ttu-id="8ea05-357">カスタム ページングは、既定のページングを返しますが、のみ、必要なレコードを取得するため*すべて*表示されている各ページのレコードのカスタム ページングが既定のページングよりも効率的であるが明確な。</span><span class="sxs-lookup"><span data-stu-id="8ea05-357">Since custom paging only retrieves the needed records, whereas default paging returns *all* of the records for each page being viewed, it s clear that custom paging is more efficient than default paging.</span></span> <span data-ttu-id="8ea05-358">しかしよりもはるかに効率的なはカスタム ページングでしょうか。</span><span class="sxs-lookup"><span data-stu-id="8ea05-358">But just how much more efficient is custom paging?</span></span> <span data-ttu-id="8ea05-359">カスタム ページングを既定のページングを移動して、どのようなパフォーマンスの向上を見なすことができますか。</span><span class="sxs-lookup"><span data-stu-id="8ea05-359">What sort of performance gains can be seen by moving from default paging to custom paging?</span></span>

<span data-ttu-id="8ea05-360">残念ながら、s がない 1 つのサイズに合ったすべてここに回答します。</span><span class="sxs-lookup"><span data-stu-id="8ea05-360">Unfortunately, there s no one size fits all answer here.</span></span> <span data-ttu-id="8ea05-361">パフォーマンスの向上は、さまざまな要因によって異なります、最も顕著な web サーバーとデータベース サーバー間のデータベース サーバーとの通信チャネルにレコードがページングされると、負荷の数をされている 2 つ配置します。</span><span class="sxs-lookup"><span data-stu-id="8ea05-361">The performance gain depends on a number of factors, the most prominent two being the number of records being paged through and the load placed on the database server and communication channels between the web server and database server.</span></span> <span data-ttu-id="8ea05-362">わずか数十個のレコードを含む小さなテーブル向けのパフォーマンスの違いはごくわずかにあります。</span><span class="sxs-lookup"><span data-stu-id="8ea05-362">For small tables with just a few dozen records, the performance difference may be negligible.</span></span> <span data-ttu-id="8ea05-363">大規模なテーブル、数十万行の数千人からのパフォーマンスの違いは、深刻です。</span><span class="sxs-lookup"><span data-stu-id="8ea05-363">For large tables, with thousands to hundreds of thousands of rows, though, the performance difference is acute.</span></span>

<span data-ttu-id="8ea05-364">僕の本の記事[SQL Server 2005 で ASP.NET 2.0 でカスタム ページング](http://aspnet.4guysfromrolla.com/articles/031506-1.aspx)、これら 2 つのページング手法をデータベース テーブルのページングとの間のパフォーマンスの違いを示すために実行したいくつかのパフォーマンス テストが含まれています50,000 個のレコード。</span><span class="sxs-lookup"><span data-stu-id="8ea05-364">An article of mine, [Custom Paging in ASP.NET 2.0 with SQL Server 2005](http://aspnet.4guysfromrolla.com/articles/031506-1.aspx), contains some performance tests I ran to exhibit the differences in performance between these two paging techniques when paging through a database table with 50,000 records.</span></span> <span data-ttu-id="8ea05-365">これらのテストで SQL Server レベルでクエリを実行する時間の両方を検証しました (を使用して[SQL Profiler](https://msdn.microsoft.com/library/ms173757.aspx)) と、ASP.NET ページを使用して[ASP.NET トレース機能](https://msdn.microsoft.com/library/y13fw6we.aspx)します。</span><span class="sxs-lookup"><span data-stu-id="8ea05-365">In these tests I examined both the time to execute the query at the SQL Server level (using [SQL Profiler](https://msdn.microsoft.com/library/ms173757.aspx)) and at the ASP.NET page using [ASP.NET s tracing features](https://msdn.microsoft.com/library/y13fw6we.aspx).</span></span> <span data-ttu-id="8ea05-366">注意してこれらのテストが 1 人のアクティブなユーザーには、開発ボックス上で実行およびしたがって科学でないロード パターンの一般的な web サイトを模倣しないにしてください。</span><span class="sxs-lookup"><span data-stu-id="8ea05-366">Keep in mind that these tests were run on my development box with a single active user, and therefore are unscientific and do not mimic typical website load patterns.</span></span> <span data-ttu-id="8ea05-367">関係なく、結果は、十分に大量のデータを使用する場合、既定およびカスタム ページングの実行時間の相対的な違いを示しています。</span><span class="sxs-lookup"><span data-stu-id="8ea05-367">Regardless, the results illustrate the relative differences in execution time for default and custom paging when working with sufficiently large amounts of data.</span></span>


|  | <span data-ttu-id="8ea05-368">**平均実行時間 (秒)**</span><span class="sxs-lookup"><span data-stu-id="8ea05-368">**Avg. Duration (sec)**</span></span> | <span data-ttu-id="8ea05-369">**読み取り**</span><span class="sxs-lookup"><span data-stu-id="8ea05-369">**Reads**</span></span> |
| --- | --- | --- |
| <span data-ttu-id="8ea05-370">**既定の SQL Profiler のページング**</span><span class="sxs-lookup"><span data-stu-id="8ea05-370">**Default Paging SQL Profiler**</span></span> | <span data-ttu-id="8ea05-371">1.411</span><span class="sxs-lookup"><span data-stu-id="8ea05-371">1.411</span></span> | <span data-ttu-id="8ea05-372">383</span><span class="sxs-lookup"><span data-stu-id="8ea05-372">383</span></span> |
| <span data-ttu-id="8ea05-373">**カスタム ページング SQL Profiler**</span><span class="sxs-lookup"><span data-stu-id="8ea05-373">**Custom Paging SQL Profiler**</span></span> | <span data-ttu-id="8ea05-374">0.002</span><span class="sxs-lookup"><span data-stu-id="8ea05-374">0.002</span></span> | <span data-ttu-id="8ea05-375">29</span><span class="sxs-lookup"><span data-stu-id="8ea05-375">29</span></span> |
| <span data-ttu-id="8ea05-376">**ページングの既定の ASP.NET トレース**</span><span class="sxs-lookup"><span data-stu-id="8ea05-376">**Default Paging ASP.NET Trace**</span></span> | <span data-ttu-id="8ea05-377">2.379</span><span class="sxs-lookup"><span data-stu-id="8ea05-377">2.379</span></span> | <span data-ttu-id="8ea05-378">*該当なし*</span><span class="sxs-lookup"><span data-stu-id="8ea05-378">*N/A*</span></span> |
| <span data-ttu-id="8ea05-379">**カスタム ページング ASP.NET トレース**</span><span class="sxs-lookup"><span data-stu-id="8ea05-379">**Custom Paging ASP.NET Trace**</span></span> | <span data-ttu-id="8ea05-380">0.029</span><span class="sxs-lookup"><span data-stu-id="8ea05-380">0.029</span></span> | <span data-ttu-id="8ea05-381">*該当なし*</span><span class="sxs-lookup"><span data-stu-id="8ea05-381">*N/A*</span></span> |


<span data-ttu-id="8ea05-382">ご覧のように、データの特定のページを取得する平均 354 未満の読み取りに必要なし、短時間で完了します。</span><span class="sxs-lookup"><span data-stu-id="8ea05-382">As you can see, retrieving a particular page of data required 354 less reads on average and completed in a fraction of the time.</span></span> <span data-ttu-id="8ea05-383">ASP.NET ページで、カスタム ページが 1/100 に近いでレンダリングできる<sup>th</sup>かかった時間の既定のページングを使用する場合。</span><span class="sxs-lookup"><span data-stu-id="8ea05-383">At the ASP.NET page, custom the page was able to render in close to 1/100<sup>th</sup> of the time it took when using default paging.</span></span> <span data-ttu-id="8ea05-384">参照してください[筆者の記事](http://aspnet.4guysfromrolla.com/articles/031506-1.aspx)コードおよびデータベースと共にこれらの結果の詳細については、独自の環境でこれらのテストを再現するためにダウンロードできます。</span><span class="sxs-lookup"><span data-stu-id="8ea05-384">See [my article](http://aspnet.4guysfromrolla.com/articles/031506-1.aspx) for more information on these results along with code and a database you can download to reproduce these tests in your own environment.</span></span>

## <a name="summary"></a><span data-ttu-id="8ea05-385">まとめ</span><span class="sxs-lookup"><span data-stu-id="8ea05-385">Summary</span></span>

<span data-ttu-id="8ea05-386">既定のページングはデータ Web コントロールのスマート タグでページングを有効にするチェック ボックス チェックだけを実装するために簡単ですが、パフォーマンスが犠牲にこのようなわかりやすくするため。</span><span class="sxs-lookup"><span data-stu-id="8ea05-386">Default paging is a cinch to implement just check the Enable Paging checkbox in the data Web control s smart tag but such simplicity comes at the cost of performance.</span></span> <span data-ttu-id="8ea05-387">ユーザーがデータの任意のページを要求したときに既定のページングと*すべて*レコードが返される場合でも、それらのごく一部だけを表示する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="8ea05-387">With default paging, when a user requests any page of data *all* records are returned, even though only a tiny fraction of them may be shown.</span></span> <span data-ttu-id="8ea05-388">このパフォーマンスのオーバーヘッドを対処するには、ObjectDataSource には、代替ページング オプション カスタム ページングが用意されています。</span><span class="sxs-lookup"><span data-stu-id="8ea05-388">To combat this performance overhead, the ObjectDataSource offers an alternative paging option custom paging.</span></span>

<span data-ttu-id="8ea05-389">カスタム ページングが既定の秒のパフォーマンスの問題を表示する必要があるレコードのみを取得することによってページングを改良中に、s カスタム ページングを実装するよりも複雑です。</span><span class="sxs-lookup"><span data-stu-id="8ea05-389">While custom paging improves upon default paging s performance issues by retrieving only those records that need to be displayed, it s more involved to implement custom paging.</span></span> <span data-ttu-id="8ea05-390">最初に、正しく (かつ効率的に) にアクセスするレコードの要求の特定のサブセット、クエリを記述する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8ea05-390">First, a query must be written that correctly (and efficiently) accesses the specific subset of records requested.</span></span> <span data-ttu-id="8ea05-391">これは、さまざまな方法で実現できます。このチュートリアルで調べる 1 つは、新しい SQL Server 2005 の s を使用する`ROW_NUMBER()`ランク付けする関数の結果、し、返されるだけで結果が順位付けが指定した範囲内にあります。</span><span class="sxs-lookup"><span data-stu-id="8ea05-391">This can be accomplished in a number of ways; the one we examined in this tutorial is to use SQL Server 2005 s new `ROW_NUMBER()` function to rank results, and then to return just those results whose ranking falls within a specified range.</span></span> <span data-ttu-id="8ea05-392">さらに、ポケットベル通知でレコードの合計数を決定するための手段を追加する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8ea05-392">Furthermore, we need to add a means to determine the total number of records being paged through.</span></span> <span data-ttu-id="8ea05-393">これらの DAL、BLL メソッドを作成した後も、合計レコードの数がページングされていると、BLL に、開始行インデックスと行の最大数の値を正しく渡すことができますを確認できるように、ObjectDataSource を構成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8ea05-393">After creating these DAL and BLL methods, we also need to configure the ObjectDataSource so that it can determine how many total records are being paged through and can correctly pass the Start Row Index and Maximum Rows values to the BLL.</span></span>

<span data-ttu-id="8ea05-394">カスタム ページングを実装するいくつかの手順では必要でありは既定のページングと同じくらいしない簡単、十分に大量のデータをページングするときカスタム ページングが、必要です。</span><span class="sxs-lookup"><span data-stu-id="8ea05-394">While implementing custom paging does require a number of steps and is not nearly as simple as default paging, custom paging is a necessity when paging through sufficiently large amounts of data.</span></span> <span data-ttu-id="8ea05-395">結果の調査は、カスタム ページング、ASP.NET ページのレンダリング時間から秒を低減でき、1 つ以上桁違いによって、データベース サーバー負荷を軽減することができます。</span><span class="sxs-lookup"><span data-stu-id="8ea05-395">As the results examined showed, custom paging can shed seconds off of the ASP.NET page render time and can lighten the load on the database server by one ore more orders of magnitude.</span></span>

<span data-ttu-id="8ea05-396">満足のプログラミングです。</span><span class="sxs-lookup"><span data-stu-id="8ea05-396">Happy Programming!</span></span>

## <a name="about-the-author"></a><span data-ttu-id="8ea05-397">執筆者紹介</span><span class="sxs-lookup"><span data-stu-id="8ea05-397">About the Author</span></span>

<span data-ttu-id="8ea05-398">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml)、7 つ受け取りますブックおよびの創設者の著者[4GuysFromRolla.com](http://www.4guysfromrolla.com)、Microsoft Web テクノロジと 1998 年から携わっています。</span><span class="sxs-lookup"><span data-stu-id="8ea05-398">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="8ea05-399">Scott は、フリーのコンサルタント、トレーナー、およびライターとして動作します。</span><span class="sxs-lookup"><span data-stu-id="8ea05-399">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="8ea05-400">最新の著書は[ *Sams 教える自分で ASP.NET 2.0 24 時間以内に*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)します。</span><span class="sxs-lookup"><span data-stu-id="8ea05-400">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="8ea05-401">彼に到達できる[mitchell@4GuysFromRolla.comします。](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="8ea05-401">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span> <span data-ttu-id="8ea05-402">彼のブログにあるでまたは[ http://ScottOnWriting.NET](http://ScottOnWriting.NET)します。</span><span class="sxs-lookup"><span data-stu-id="8ea05-402">or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="8ea05-403">[前へ](paging-and-sorting-report-data-vb.md)
> [次へ](sorting-custom-paged-data-vb.md)</span><span class="sxs-lookup"><span data-stu-id="8ea05-403">[Previous](paging-and-sorting-report-data-vb.md)
[Next](sorting-custom-paged-data-vb.md)</span></span>
