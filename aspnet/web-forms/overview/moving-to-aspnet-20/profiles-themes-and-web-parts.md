---
uid: web-forms/overview/moving-to-aspnet-20/profiles-themes-and-web-parts
title: プロファイル、テーマ、および Web パーツ |Microsoft Docs
author: microsoft
description: 主要な構成の変更と ASP.NET 2.0 のインストルメンテーションがあります。 構成の変更を加える pr 新しい ASP.NET 構成 API を使用する.
ms.author: riande
ms.date: 02/20/2005
ms.assetid: 92df4051-77c6-492c-bd34-23d24189cea4
msc.legacyurl: /web-forms/overview/moving-to-aspnet-20/profiles-themes-and-web-parts
msc.type: authoredcontent
ms.openlocfilehash: 98559c2a378c72bc5664faafe5436753050b574f
ms.sourcegitcommit: 45ac74e400f9f2b7dbded66297730f6f14a4eb25
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 08/16/2018
ms.locfileid: "41826791"
---
<a name="profiles-themes-and-web-parts"></a>プロファイル、テーマ、および Web パーツ
====================
によって[Microsoft](https://github.com/microsoft)

> 主要な構成の変更と ASP.NET 2.0 のインストルメンテーションがあります。 新しい ASP.NET 構成 API では、プログラムで実行できる構成の変更ができます。 多くの新しい構成設定が存在するさらに、新しい構成とインストルメンテーションを許可します。


ASP.NET 2.0 では、カスタマイズされた Web サイトの領域も大幅に改善を表します。 既に説明メンバーシップ機能という、だけでなく ASP.NET プロファイル、テーマ、および Web パーツを大幅に改善の Web サイトでのパーソナル化します。

## <a name="aspnet-profiles"></a>ASP.NET プロファイル

ASP.NET のプロファイルは、セッションに似ています。 違いは、プロファイルは、ブラウザーが閉じられたときに、セッションが失われますが、永続的なことです。 セッションとプロファイルのもう 1 つの大きな違いは、プロファイルに、開発プロセス中に IntelliSense を提供する厳密に型指定されたことができます。

プロファイルは、マシン構成ファイルまたはアプリケーションの web.config ファイルのいずれかで定義されます。 (プロファイルはサブフォルダーの web.config ファイルで定義できません)。次のコードでは、まず Web サイトの訪問者を格納し、姓、名のプロファイルを定義します。

[!code-xml[Main](profiles-themes-and-web-parts/samples/sample1.xml)]

プロファイル プロパティの既定のデータ型は、System.String です。 上記の例では、データ型は指定されていません。 したがって、FirstName および LastName プロパティは、文字列型のどちらもします。 既に触れましたが、プロパティが厳密に型指定されたプロファイル。 次のコードでは、Int32 型の有効期間の新しいプロパティを追加します。

[!code-xml[Main](profiles-themes-and-web-parts/samples/sample2.xml)]

プロファイルは、ASP.NET フォーム認証で一般的に使用されます。 各ユーザーが、ユーザー ID に関連付けられている別のプロファイルでフォーム認証と組み合わせて使用する場合 ただし、匿名のアプリケーションを使用して、プロファイルを使用できるようにすることはまた、 &lt;anonymousIdentification&gt;と共に構成ファイル内の要素、 **allowAnonymous**として属性次に示します。

[!code-xml[Main](profiles-themes-and-web-parts/samples/sample3.xml)]

ASP.NET がのインスタンスを作成するときに、匿名ユーザーは、サイトを参照、 **ProfileCommon**ユーザー。 このプロファイルは、一意のビジターとしてユーザーを識別するために、ブラウザーの cookie に格納されている一意の ID を使用します。 この方法では、匿名で参照するユーザーのプロファイル情報を格納できます。

## <a name="profile-groups"></a>プロファイル グループ

プロファイルのグループのプロパティを行うことができます。 プロパティのグループ化では、特定のアプリケーションの複数のプロファイルをシミュレートすることはできます。

次の構成では、2 つのグループの FirstName および LastName プロパティを構成します。購入者率や導入を検討します。

[!code-xml[Main](profiles-themes-and-web-parts/samples/sample4.xml)]

次のように、特定のグループのプロパティを設定することが、できます。

[!code-csharp[Main](profiles-themes-and-web-parts/samples/sample5.cs)]

## <a name="storing-complex-objects"></a>複雑なオブジェクトを格納します。

ここまでは、ここで説明した例がプロファイルに、単純なデータ型が保存されています。 シリアル化を使用する方法を指定することで、プロファイルに複雑なデータ型を格納することも、 **serializeAs**属性を次のようにします。

[!code-xml[Main](profiles-themes-and-web-parts/samples/sample6.xml)]

この場合、型は、PurchaseInvoice です。 PurchaseInvoice クラスは、シリアル化可能としてマーク済みである必要があり、任意の数のプロパティを含めることができます。 たとえば、PurchaseInvoice というプロパティがあります**NumItemsPurchased**コード内でそのプロパティを次のように参照することができます。

[!code-css[Main](profiles-themes-and-web-parts/samples/sample7.css)]

## <a name="profile-inheritance"></a>プロファイルの継承

複数のアプリケーションで使用するプロファイルを作成することになります。 ProfileBase から派生したプロファイル クラスを作成すると、再利用できますいくつかのアプリケーションでプロファイルを使用して、**継承**次に示すように属性します。

[!code-xml[Main](profiles-themes-and-web-parts/samples/sample8.xml)]

この場合は、クラス**PurchasingProfile**になりますようになります。

[!code-csharp[Main](profiles-themes-and-web-parts/samples/sample9.cs)]

## <a name="profile-providers"></a>プロファイル プロバイダー

ASP.NET プロファイルでは、プロバイダー モデルを使用します。 既定のプロバイダーは、情報をアプリでの SQL Server Express データベースに格納\_SqlProfileProvider プロバイダーを使用して Web アプリケーションのデータ フォルダー。 データベースが存在しない場合 ASP.NET が自動的に作成、プロファイル情報を格納しようとしました。

場合によっては、ただし、可能性がある、独自のプロファイル プロバイダーを開発します。 ASP.NET プロファイル機能では、さまざまなプロバイダーを使用して簡単にすることができます。

カスタム プロファイル プロバイダーを作成するとき。

- FoxPro データベースまたは Oracle データベースでは、.NET Framework に含まれているプロファイル プロバイダでサポートされていないをなど、データ ソースのプロファイル情報を格納する必要があります。
- .NET Framework に含まれているプロバイダーによって使用されるデータベース スキーマとは異なるデータベース スキーマを使用して、プロファイル情報を管理する必要があります。 一般的な例は、既存の SQL Server データベース内のユーザー データとプロファイル情報を統合することです。

### <a name="required-classes"></a>必要なクラス

プロファイル プロバイダーを実装するには、System.Web.Profile.ProfileProvider 抽象クラスを継承するクラスを作成します。 **ProfileProvider**抽象クラスがさらに System.Configuration.Provider.ProviderBase 抽象クラスを継承して System.Configuration.SettingsProvider 抽象クラスを継承します。 必要なメンバーに加え、この継承チェーンにより、 **ProfileProvider**クラスに必要なメンバーを実装する必要があります、 **SettingsProvider**と**ProviderBase**クラス。

次の表は、プロパティとメソッドを実装する必要があります、 **ProviderBase**、 **SettingsProvider**、および**ProfileProvider**抽象クラス。

### <a name="providerbase-members"></a>ProviderBase メンバー

| **Member** | **説明** |
| --- | --- |
| Initialize メソッド | プロバイダーのインスタンスの名前と構成設定の NameValueCollection を入力として受け取ります。 オプションと実装に固有の値と、マシンの構成または Web.config ファイルで指定されたオプションを含む、プロバイダーのインスタンスのプロパティの値を設定するために使用します。 |

### <a name="settingsprovider-members"></a>SettingsProvider メンバー

| **Member** | **説明** |
| --- | --- |
| ApplicationName プロパティ | 各プロファイルに格納されているアプリケーション名。 プロファイル プロバイダーでは、アプリケーション名を使用して、アプリケーションごとに個別にプロファイル情報を格納します。 これにより、同じユーザー名が別のアプリケーションで作成した場合、競合することがなく、同じデータ ソースを使用する複数の ASP.NET アプリケーション。 または、複数の ASP.NET アプリケーションでは、同じアプリケーション名を指定することで、プロファイル データ ソースを共有できます。 |
| GetPropertyValues メソッド | SettingsPropertyCollection オブジェクトおよび SettingsContext 入力として受け取ります。 **SettingsContext**ユーザーに関する情報を提供します。 主キーとして、情報を使用するには、ユーザーのプロファイル プロパティ情報を取得します。 使用して、 **SettingsContext**ユーザー名と、ユーザーが認証済みまたは匿名のかどうかを取得するオブジェクト。 **SettingsPropertyCollection** SettingsProperty オブジェクトのコレクションが含まれています。 各**SettingsProperty**オブジェクト プロパティと、プロパティとプロパティは読み取り専用かどうかの既定値などの追加情報の種類と名前を提供します。 **GetPropertyValues**メソッドに基づく SettingsPropertyValue オブジェクトが、SettingsPropertyValueCollection を設定します、 **SettingsProperty**入力として提供されているオブジェクト。 指定したユーザーのデータ ソースからの値が各 PropertyValue プロパティに割り当てられている**SettingsPropertyValue**オブジェクトとコレクション全体が返されます。 指定されたユーザー プロファイルの LastActivityDate 値を現在の日付と時刻を更新もメソッドを呼び出すことです。 |
| SetPropertyValues メソッド | 入力として受け取り、 **SettingsContext**と**SettingsPropertyValueCollection**オブジェクト。 **SettingsContext**ユーザーに関する情報を提供します。 主キーとして、情報を使用するには、ユーザーのプロファイル プロパティ情報を取得します。 使用して、 **SettingsContext**ユーザー名と、ユーザーが認証済みまたは匿名のかどうかを取得するオブジェクト。 **SettingsPropertyValueCollection**のコレクションを含む**SettingsPropertyValue**オブジェクト。 各**SettingsPropertyValue**オブジェクト名、型、およびプロパティと、プロパティとプロパティは読み取り専用かどうかの既定値などの追加情報の値を提供します。 **SetPropertyValues**メソッドは、指定したユーザーのデータ ソース内のプロファイル プロパティ値を更新します。 メソッドを呼び出すことも更新プログラム、 **LastActivityDate**と現在の日付と時刻に指定されたユーザー プロファイルの LastUpdatedDate 値。 |

### <a name="profileprovider-members"></a>ProfileProvider メンバー

| **Member** | **説明** |
| --- | --- |
| DeleteProfiles メソッド | アプリケーション名が一致するユーザーの文字列配列の名前し、データ ソースから削除します。 すべてのプロファイル情報とプロパティ値に対して指定した名前の入力として受け取り、 **ApplicationName**プロパティの値。 データ ソースは、トランザクションをサポートする場合は、すべての削除操作は、トランザクションに含めることと、トランザクションをロールバックして、削除操作が失敗した場合に例外をスローするをお勧めします。 |
| DeleteProfiles メソッド | アプリケーション名が一致する ProfileInfo のコレクション オブジェクトし、データ ソースから削除します。 すべてのプロファイル情報とプロパティ値の各プロファイルの入力として受け取り、 **ApplicationName**プロパティの値。 データ ソースは、トランザクションをサポートする場合は、すべての削除操作をトランザクションに含めると、トランザクションのロールバックを削除操作が失敗した場合に例外をスローをお勧めします。 |
| DeleteInactiveProfiles メソッド | DateTime オブジェクトおよびデータの削除は、すべてのプロファイル情報をソースし、プロパティ値がここで、最後のアクティビティの日付が指定した日付と時刻に小さい ProfileAuthenticationOption 値を入力として受け取り、アプリケーション名一致する、 **ApplicationName**プロパティの値。 **ProfileAuthenticationOption**パラメーターを指定するかどうか認証済みプロファイル、のみのみ匿名プロファイルは、すべてのプロファイルを削除するか。 データ ソースは、トランザクションをサポートする場合は、すべての削除操作をトランザクションに含めると、トランザクションのロールバックを削除操作が失敗した場合に例外をスローをお勧めします。 |
| GetAllProfiles メソッド | 入力として受け取り、 **ProfileAuthenticationOption**値、ページのインデックスを指定する整数、ページ サイズ、およびプロファイルの合計数に設定される整数への参照を指定する整数。 含む ProfileInfoCollection 返します**ProfileInfo**オブジェクトが、アプリケーション名と一致するデータ ソースのすべてのプロファイル、 **ApplicationName**プロパティの値。 **ProfileAuthenticationOption**パラメーターを指定するかどうか認証済みプロファイル、のみのみ匿名プロファイルは、すべてのプロファイルは返されるか。 によって返される結果、 **GetAllProfiles**メソッドは、ページのインデックスとページ サイズの値によって制限されます。 ページ サイズの値の最大数を指定する**ProfileInfo**で返されるオブジェクト、 **ProfileInfoCollection**します。 ページのインデックス値には、結果を返すには、1 が最初のページを識別する場所のどのページを指定します。 合計レコード数のパラメーターは out パラメーター (使用することができます**ByRef** Visual Basic で) プロファイルの合計数に設定されています。 たとえば、データ ストアには、アプリケーションの 13 のプロファイルが含まれている、ページのインデックス値は 2 ページ サイズが 5 の場合、 **ProfileInfoCollection**返されるは 6 ~ 10 番目のプロファイルが含まれています。 メソッドが戻るとき、レコードの合計値は 13 に設定します。 |
| GetAllInactiveProfiles メソッド | 入力として受け取り、 **ProfileAuthenticationOption**値、 **DateTime**オブジェクト、ページのインデックスを指定する整数、ページ サイズ、および設定される整数への参照を指定する整数プロファイルの合計数。 返します、 **ProfileInfoCollection**を格納している**ProfileInfo**オブジェクト、データ ソースの場所を指定した小さいが、最後のアクティビティの日付のすべてのプロファイル**DateTime**アプリケーション名が一致して、 **ApplicationName**プロパティの値。 **ProfileAuthenticationOption**パラメーターを指定するかどうか認証済みプロファイル、のみのみ匿名プロファイルは、すべてのプロファイルは返されるか。 によって返される結果、 **GetAllInactiveProfiles**メソッドは、ページのインデックスとページ サイズの値によって制限されます。 ページ サイズの値の最大数を指定する**ProfileInfo**で返されるオブジェクト、 **ProfileInfoCollection**します。 ページのインデックス値には、結果を返すには、1 が最初のページを識別する場所のどのページを指定します。 合計レコード数のパラメーターは out パラメーター (使用することができます**ByRef** Visual Basic で) プロファイルの合計数に設定されています。 たとえば、データ ストアには、アプリケーションの 13 のプロファイルが含まれている、ページのインデックス値は 2 ページ サイズが 5 の場合、 **ProfileInfoCollection**返されるは 6 ~ 10 番目のプロファイルが含まれています。 メソッドが戻るとき、レコードの合計値は 13 に設定します。 |
| FindProfilesByUserName メソッド | 入力として受け取り、 **ProfileAuthenticationOption**値、ユーザー名、ページのインデックスを指定する整数、ページのサイズとの合計数に設定される整数への参照を指定する整数を含む文字列プロファイル。 返します、 **ProfileInfoCollection**を格納している**ProfileInfo**オブジェクトのすべてのプロファイルで、データ ソースがユーザー名が指定されたユーザー名と一致して、アプリケーション名が一致する、**ApplicationName**プロパティの値。 **ProfileAuthenticationOption**パラメーターを指定するかどうか認証済みプロファイル、のみのみ匿名プロファイルは、すべてのプロファイルは返されるか。 データ ソースは、ワイルドカード文字をなど、追加の検索機能をサポートしている場合は、ユーザー名の検索機能を拡張を行うことができます。 によって返される結果、 **FindProfilesByUserName**メソッドは、ページのインデックスとページ サイズの値によって制限されます。 ページ サイズの値の最大数を指定する**ProfileInfo**で返されるオブジェクト、 **ProfileInfoCollection**します。 ページのインデックス値には、結果を返すには、1 が最初のページを識別する場所のどのページを指定します。 合計レコード数のパラメーターは out パラメーター (使用することができます**ByRef** Visual Basic で) プロファイルの合計数に設定されています。 たとえば、データ ストアには、アプリケーションの 13 のプロファイルが含まれている、ページのインデックス値は 2 ページ サイズが 5 の場合、 **ProfileInfoCollection**返されるは 6 ~ 10 番目のプロファイルが含まれています。 メソッドが戻るとき、レコードの合計値は 13 に設定します。 |
| FindInactiveProfilesByUserName メソッド | 入力として受け取り、 **ProfileAuthenticationOption**値、ユーザーの名前を含む文字列を**DateTime**オブジェクト、ページのインデックスを指定する整数、ページ サイズを指定する整数とプロファイルの合計数に設定される整数への参照します。 返します、 **ProfileInfoCollection**を格納している**ProfileInfo**最後のアクティビティの日付のあるユーザー名が、指定されたユーザー名と一致するデータ ソース内のすべてのプロファイル用のオブジェクトより小さいまたは指定したのと同じ**DateTime**、アプリケーション名が一致して、 **ApplicationName**プロパティの値。 **ProfileAuthenticationOption**パラメーターを指定するかどうか認証済みプロファイル、のみのみ匿名プロファイルは、すべてのプロファイルは返されるか。 データ ソースは、ワイルドカード文字をなど、追加の検索機能をサポートしている場合は、ユーザー名の検索機能を拡張を行うことができます。 によって返される結果、 **FindInactiveProfilesByUserName**メソッドは、ページのインデックスとページ サイズの値によって制限されます。 ページ サイズの値の最大数を指定する**ProfileInfo**で返されるオブジェクト、 **ProfileInfoCollection**します。 ページのインデックス値には、結果を返すには、1 が最初のページを識別する場所のどのページを指定します。 合計レコード数のパラメーターは out パラメーター (使用することができます**ByRef** Visual Basic で) プロファイルの合計数に設定されています。 たとえば、データ ストアには、アプリケーションの 13 のプロファイルが含まれている、ページのインデックス値は 2 ページ サイズが 5 の場合、 **ProfileInfoCollection**返されるは 6 ~ 10 番目のプロファイルが含まれています。 メソッドが戻るとき、レコードの合計値は 13 に設定します。 |
| GetNumberOfInActiveProfiles メソッド | 入力として受け取り、 **ProfileAuthenticationOption**値と**DateTime**オブジェクトし、最後のアクティビティの日付が指定された小さいデータソース内のすべてのプロファイルの数を返します**DateTime**アプリケーション名が一致して、 **ApplicationName**プロパティの値。 **ProfileAuthenticationOption**パラメーターを指定するかどうか認証済みプロファイル、のみのみ匿名プロファイルは、すべてのプロファイルは、カウントするか。 |

### <a name="applicationname"></a>ApplicationName

プロファイル プロバイダーでは、アプリケーションごとに個別にプロファイル情報を格納するため、データ スキーマにアプリケーション名が含まれていると、クエリと更新プログラムもアプリケーション名を含めることを確認する必要があります。 たとえば、次のコマンドはユーザー名と、プロファイルが匿名かどうかに基づいて、データベースからプロパティ値を取得するために使用し、確実、 **ApplicationName**値が、クエリに含まれます。

[!code-sql[Main](profiles-themes-and-web-parts/samples/sample10.sql)]

## <a name="aspnet-themes"></a>ASP.NET のテーマ

## <a name="what-are-aspnet-20-themes"></a>ASP.NET 2.0 テーマとは

Web アプリケーションの最も重要な側面の 1 つは、サイト全体で一貫したルック アンド フィールです。 ASP.NET 1.x の開発者は、通常、一貫したルック アンド フィールを実装するのにカスケード スタイル シート (CSS) を使用します。 ASP.NET 2.0 テーマが大幅に改良 CSS ASP.NET 開発者向けの HTML 要素と同様に ASP.NET サーバー コントロールの外観を定義する機能を提供するためです。 ASP.NET のテーマは、個々 のコントロール、特定の Web ページまたは Web アプリケーション全体に適用できます。 テーマは、イメージが必要な場合に、CSS ファイル、省略可能なスキン ファイル、および、省略可能なイメージ ディレクトリの組み合わせを使用します。 スキン ファイルは、ASP.NET サーバー コントロールの外観を制御します。

## <a name="where-are-themes-stored"></a>テーマの格納にはどこか

テーマの格納場所は、それぞれのスコープに基づいて異なります。 任意のアプリケーションに適用できるテーマは、次のフォルダーに格納されます。

`C:\WINDOWS\Microsoft.NET\Framework\v2.x.xxxxx\ASP.NETClientFiles\Themes\<Theme_Name>`

特定のアプリケーションに固有のテーマに格納されている、 `App\_Themes\<Theme\_Name>` Web サイトのルート ディレクトリ。

> [!NOTE]
> スキン ファイルは、外観に影響するサーバー コントロールのプロパティのみを変更する必要があります。

グローバルのテーマは、任意のアプリケーションまたは Web サーバーで実行されている Web サイトに適用できるテーマです。 これらのテーマは、既定では、v2.x.xxxxx ディレクトリ内にある ASP.NETClientfiles\Themes ディレクトリに格納されます。 Aspnet にテーマ ファイルを移動する代わりに、\_クライアント/システム\_web/[バージョン]/Themes/[テーマ\_名] で、Web サイトのルート フォルダー。

アプリケーション固有のテーマは、ファイルが存在するアプリケーションにのみ適用できます。 これらのファイルが格納されている、 `App\_Themes/<theme\_name>` Web サイトのルート ディレクトリ。

## <a name="the-components-of-a-theme"></a>テーマのコンポーネント

1 つまたは複数の CSS ファイル、省略可能なスキン ファイル、およびオプションのイメージ フォルダーのテーマが構成されます。 CSS ファイルには、任意の名前 (default.css または theme.css など) を希望してテーマ フォルダーのルートである必要がありますを指定できます。 CSS ファイルは、通常の CSS クラス、および特定のセレクターの属性の定義に使用されます。 ページ要素に CSS クラスのいずれかを適用する、 **CSSClass**プロパティを使用します。

スキン ファイルは、ASP.NET サーバー コントロールのプロパティの定義を含む XML ファイルです。 以下に示すコードは、スキン ファイルの例です。

[!code-aspx[Main](profiles-themes-and-web-parts/samples/sample11.aspx)]

**図 1**ないテーマが適用、少量の ASP.NET ページ参照を示しています。 **図 2**テーマが適用された、同じファイルを示しています。 背景色とテキストの色は、CSS ファイルを使用して構成されます。 テキスト ボックス、ボタンの外観は、上記のスキン ファイルで構成されます。


![テーマなし](profiles-themes-and-web-parts/_static/image1.gif)

**図 1**: ないテーマ


![テーマの適用](profiles-themes-and-web-parts/_static/image2.gif)

**図 2**: テーマの適用


上記のスキン ファイルは、すべてのテキスト ボックス コントロールとボタン コントロールの既定のスキンを定義します。 すべての TextBox コントロールとボタン コントロールがページ上に挿入がこの外観になることを意味します。 使用してこれらのコントロールの特定のインスタンスに適用できるスキンを定義することも、 **SkinID**コントロールのプロパティ。

次のコードでは、ボタン コントロールのスキンを定義します。 コントロール ボタンのみを**SkinID**プロパティの**goButton**スキンの外観になる予定です。

[!code-aspx[Main](profiles-themes-and-web-parts/samples/sample12.aspx)]

サーバー コントロールの種類ごとに 1 つの既定スキンのみがあることができます。 その他のスキンを必要とする場合は、SkinID プロパティを使用する必要があります。

## <a name="applying-themes-to-pages"></a>ページ テーマを適用します。

テーマを適用するには、次の方法のいずれかを使用します。

- &lt;ページ&gt;web.config ファイルの要素
- @Pageページのディレクティブ
- プログラムで

## <a name="applying-a-theme-in-the-configuration-file"></a>構成ファイルにテーマを適用します。

アプリケーション構成ファイルにテーマを適用するには、次の構文を使用します。

[!code-xml[Main](profiles-themes-and-web-parts/samples/sample13.xml)]

ここで指定されたテーマ名は、テーマ フォルダーの名前と一致する必要があります。 このフォルダーは、このコースで説明した場所のいずれかのいずれかに存在できます。 ないテーマを適用しようとすると、構成エラーが発生します。

## <a name="applying-a-theme-in-the-page-directive"></a>ページ ディレクティブでテーマを適用します。

@ Page ディレクティブにテーマを適用することもできます。 このメソッドを使用して、特定のページのテーマを使用できます。

テーマを適用する、@Pageディレクティブでは、次の構文を使用します。

[!code-aspx[Main](profiles-themes-and-web-parts/samples/sample14.aspx)]

既に説明したように、ここで指定されたテーマでもう一度、テーマ フォルダーが一致しなければなりませんか。 ないテーマを適用しようとすると、ビルド エラーが発生します。 Visual Studio はまた、属性を強調表示し、このようなテーマが存在しないことを通知します。

## <a name="applying-a-theme-programmatically"></a>プログラムでテーマを適用します。

テーマをプログラムで適用するには、指定する必要があります、**テーマ**内のページのプロパティ、**ページ\_PreInit**メソッド。

プログラムでテーマを適用するには、次の構文を使用します。

[!code-csharp[Main](profiles-themes-and-web-parts/samples/sample15.cs)]

ページのライフ サイクルのための PreInit メソッドでテーマを適用する必要があります。 適用した場合はその後、ページのテーマが適用済み、ランタイムによって、変更がその時点で、ライフ サイクルでは遅すぎます。 存在しないテーマを適用する場合、 **HttpException**に発生します。 テーマを適用すると、プログラムで任意のサーバー コントロールがある SkinID プロパティが指定されたビルドの警告が発生します。 この警告は、テーマが宣言によって適用されませんを無視することを通知するものです。

## <a name="exercise-1--applying-a-theme"></a>手順 1: テーマを適用します。

この演習では、Web サイトに ASP.NET のテーマが適用されます。

> [!IMPORTANT]
> スキン ファイルに情報を入力する Microsoft Word を使用する場合は、引用符で通常の引用符を置き換えるしないことを確認します。 引用符では、スキン ファイルで問題が発生します。

1. 新しい ASP.NET Web サイトを作成します。
2. ソリューション エクスプ ローラーでプロジェクトを右クリックし、新しい項目の追加を選択します。
3. ファイルの一覧から Web 構成ファイルを選択し、[追加] をクリックします。
4. ソリューション エクスプ ローラーでプロジェクトを右クリックし、新しい項目の追加を選択します。
5. スキン ファイルを選択し、[追加] をクリックします。
6. アプリ内のファイルを配置するとかどうかメッセージが表示されたら [はい] をクリックします。\_テーマ フォルダー。
7. アプリ内で SkinFile フォルダーを右クリックして\_テーマ フォルダーをソリューション エクスプ ローラーで新しい項目の追加を選択します。
8. ファイルの一覧からスタイル シートを選択し、[追加] をクリックします。 すべての新しいテーマを実装するために必要なファイルのあるようになりました。 ただし、Visual Studio には、テーマ フォルダー SkinFile がという名前です。 そのフォルダーを右クリックし、CoolTheme に名前を変更します。
9. SkinFile.skin ファイルを開き、ファイルの末尾の次のコードを追加します。 

    [!code-aspx[Main](profiles-themes-and-web-parts/samples/sample16.aspx)]
10. SkinFile.skin ファイルを保存します。
11. スタイル シートを開きます。
12. 次のようにすべてのテキストに置き換えます。 

    [!code-css[Main](profiles-themes-and-web-parts/samples/sample17.css)]
13. スタイル シート ファイルを保存します。
14. Default.aspx ページを開きます。
15. TextBox コントロールと Button コントロールを追加します。
16. ページを保存します。 これで、Default.aspx ページを参照します。 通常の Web フォームとして表示されます。
17. Web.config ファイルを開きます。
18. 開始のすぐ下に次の追加`<system.web>`タグ。 

    [!code-xml[Main](profiles-themes-and-web-parts/samples/sample18.xml)]
19. Web.config ファイルを保存します。 これで、Default.aspx ページを参照します。 テーマを適用したが表示されます。
20. これがまだ開いていない場合は、Visual Studio で、Default.aspx ページを開きます。
21. ボタンを選択します。
22. 変更、 **SkinID** goButton するプロパティ。 Visual Studio がボタン コントロールの有効な SkinID の値を含むドロップダウンを提供することに注意してください。
23. ページを保存します。 お使いのブラウザーでページをもう一度プレビューようになりました。 ボタンは、"go"というメッセージし、外観でより多くする必要があります。

使用して、 **SkinID**プロパティ、サーバー コントロールの特定の種類の異なるインスタンスごとに異なるスキンを簡単に構成できます。

## <a name="the-stylesheettheme-property"></a>StyleSheetTheme プロパティ

ここまでは、テーマのプロパティを使用してテーマを適用することのみについて説明します。 テーマのプロパティを使用する場合、スキン ファイルはすべてのサーバー コントロールの宣言型の設定をオーバーライドします。 たとえば、演習 1 で、Button コントロールには、"goButton"の SkinID が指定されてし、「移動」するボタンのテキストを変更します。 デザイナーでボタンのテキストのプロパティ「ボタン」に設定されましたが、テーマをオーバーライドすることお気付きです。 テーマには、常に、デザイナーでプロパティの設定が上書きされます。

テーマのスキン ファイルで定義されているプロパティを上書きすることができるしたい場合プロパティで指定された、デザイナーを使用することができます、 **StyleSheetTheme**テーマ プロパティではなくプロパティ。 StyleSheetTheme プロパティは、テーマのプロパティと同様、すべての明示的なプロパティ設定をオーバーライドしないことを除いてテーマ プロパティと同じです。

これを実際に見る、演習 1 で、プロジェクトから web.config ファイルを開くし、変更、`<pages>`次の要素。

[!code-xml[Main](profiles-themes-and-web-parts/samples/sample19.xml)]

これで、Default.aspx ページを参照しが「ボタン」の Text プロパティをもう一度ボタン コントロールが表示されます。 デザイナーで、明示的なプロパティの設定が goButton SkinID が設定するテキスト プロパティをオーバーライドするためです。

## <a name="overriding-themes"></a>テーマをオーバーライドします。

グローバルのテーマは、アプリで同じ名前でテーマを適用することでオーバーライドできます\_アプリケーションのテーマ フォルダー。 ただし、テーマは、true の上書きのシナリオでは適用されません。 ランタイムが発生すると、アプリでテーマ ファイル\_テーマ フォルダーをそれらのファイルを使用してテーマを適用し、グローバルのテーマは無視されます。

StyleSheetTheme プロパティは、オーバーライド可能なコードで次のようにオーバーライドできます。

[!code-csharp[Main](profiles-themes-and-web-parts/samples/sample20.cs)]

## <a name="web-parts"></a>Web パーツ

ASP.NET Web パーツは、エンド ユーザー コンテンツ、外観、およびブラウザーから直接 Web ページの動作を変更できるようにする Web サイトを作成するためのコントロールの統合セットです。 サイトのすべてのユーザーに、または個々 のユーザーに、変更を適用できます。 ユーザーは、ページおよびコントロールを変更するときに、パーソナル化と呼ばれる機能を今後のブラウザーのセッション間でユーザーの個人設定を保持する設定を保存できます。 これらの Web パーツ機能は、開発者が開発者または管理者の介入なしに Web アプリケーションを動的に個人用に設定するエンドユーザーを支援できることを意味します。

Web パーツ コントロール セットを使用して、エンドユーザーを有効にできます開発者。

- ページのコンテンツをカスタマイズできます。 ユーザーは、ページに新しい Web パーツ コントロールを追加、削除、非表示にするには、または通常のウィンドウのようにそれらを最小限に抑えることができます。
- ページ レイアウトをカスタマイズできます。 ユーザーでは、別のゾーンに ページでは、Web パーツ コントロールをドラッグしたり、その外観、プロパティ、および動作を変更することができます。
- エクスポートおよびインポート コントロール。 ユーザーでは、インポートしたり、プロパティ、外観、およびコントロールのデータも保持を他のページまたはサイト、Web パーツ コントロールの設定をエクスポートすることができます。 これには、エンドユーザーにデータ エントリと構成の必要性が削減されます。
- 接続を作成します。 ユーザーは、グラフ コントロールが、株式相場表示コントロールでデータのグラフを表示できますなどのように、コントロール間の接続を確立できます。 自体には、接続が、外観と、グラフ コントロールがデータを表示する方法の詳細のだけでなく、ユーザーがパーソナル化でした。
- 管理し、サイト レベルの設定をカスタマイズします。 承認されたユーザーは、サイト レベルの設定を構成する、サイトまたはページへのアクセス、コントロールにロールベースのアクセスを設定、および具合をしたことができますを決定できます。 たとえば、管理者の役割のユーザーでは、すべてのユーザーで共有される Web パーツ コントロールを設定し、以外のユーザーが管理者には、共有コントロールをカスタマイズをできないようにする可能性があります。

通常、3 つの方法のいずれかで Web パーツを操作します。 ページを作成するには、Web パーツ コントロールを使用して、個々 の Web パーツ コントロールの作成、またはポータルなど、パーソナル化できる、完全な Web アプリケーションを作成します。

## <a name="page-development"></a>ページの開発

ページの開発者は、Microsoft Visual Studio 2005 などのビジュアル デ ザイン ツールを使用して、Web パーツを使用してページを作成することができます。 ツールを使用して、Visual Studio が Web パーツ コントロール セットであることなどの利点の 1 つは、ビジュアル デザイナーでの Web パーツ コントロールのドラッグ アンド ドロップの作成と構成の機能を提供します。 たとえば、デザイナーを使用して Web パーツ ゾーン、または Web パーツ エディター コントロールをデザイン画面にドラッグし、コントロールを構成し、Web パーツによって提供される UI を使用して、デザイナーでコントロールのセット。 Web パーツ アプリケーションの開発を高速化して記述したコードの量を減らします。

## <a name="control-development"></a>コントロールの開発

既存の ASP.NET コントロールは、標準の Web サーバー コントロール、カスタム サーバー コントロール、およびユーザー コントロールを含む、Web パーツ コントロールとして使用できます。 環境内の最大のプログラムによる制御の WebPart クラスから派生したカスタムの Web パーツ コントロールを作成することもできます。 個々 の Web パーツ コントロールの開発のするが通常ユーザー コントロールを作成および Web パーツ コントロールとして使用またはカスタム Web パーツ コントロールを開発します。

をカスタム Web パーツ コントロールの開発の例として、パーソナル化可能な Web パーツ コントロールとしてパッケージに立つ可能性のある他の ASP.NET サーバー コントロールによって提供される機能を提供するコントロールを作成する可能性があります: 予定表、リスト、財務情報グラフを動的に、その画面を更新または天気および情報の移動、データベースに接続するニュース、電卓、リッチ テキスト コントロールのコンテンツを編集可能なグリッドを更新します。 コントロールにビジュアル デザイナーを提供する場合 Visual Studio を使用して、ページ開発者ことができます単に Web パーツ ゾーンにコントロールをドラッグし、追加のコードを記述することがなくデザイン時に構成します。

パーソナル化は、Web パーツの機能の基盤です。 パーソナル化レイアウト、外観、およびページ上の Web パーツ コントロールの動作を変更するには--またはことができます。 個人用の設定は有効期間が長い: だけでなく、現在のブラウザー セッション中に永続化する (ビュー ステートと同様) が、長期的なストレージにも後のブラウザーのセッションのユーザーの設定を保存できるようにします。 パーソナル化は、Web パーツ ページについて既定で有効です。

UI 構造コンポーネントは、パーソナル化に依存し、コア構造とすべての Web パーツ コントロールで必要なサービスを提供します。 すべての Web パーツ ページに必要な UI 構造コンポーネントの 1 つは、WebPartManager コントロールです。 このコントロールを表示されませんが、ページ上のすべての Web パーツ コントロールの調整の重要なタスクがあります。 たとえば、個々 のすべての Web パーツ コントロールを追跡します。 (ページ上の Web パーツ コントロールが含まれているリージョン) の Web パーツ ゾーンを管理するゾーン内のコントロールにあるとします。 また、追跡し、[参照]、接続、編集、またはモードでは、カタログとすべてのユーザーまたは個々 のユーザーに個人的な変更が適用するかどうかで、このようなページ使用されるさまざまな表示モードを制御します。 最後に、開始し、Web パーツ コントロール間の接続と通信を追跡します。

2 つ目の種類の UI の構造的なコンポーネントでは、ゾーンです。 ゾーンは、Web パーツ ページ上でレイアウト マネージャーとして機能します。 含まれていると (パーツ コントロール) のパーツ クラスから派生したコントロールを編成および向きが水平または垂直のいずれかのモジュール ページ レイアウトを実行する機能を提供します。 ゾーンの各コントロールが含まれている; も提供して (ヘッダーとフッターのスタイル、タイトル、境界線のスタイル、動作設定ボタンなど) の一般的なと一貫性のある UI 要素これらの一般的な要素は、コントロールのクロムと呼ばれます。 いくつかの特殊な種類のゾーンは、さまざまなコントロールを使用してさまざまな表示モードで使用されます。 さまざまな種類のゾーンについては、以下の Web パーツの重要なコントロールのセクションで説明します。

派生するすべての Web パーツ UI コントロール、**一部**クラス、Web パーツ ページ上の主要な UI を構成します。 Web パーツ コントロール セットは柔軟性ができ、オプションの包括的なパーツ コントロールを作成するためです。 に加えて、独自のカスタム Web パーツ コントロールを作成するには、使用することできますも既存の ASP.NET サーバー コントロール、ユーザー コントロール、またはカスタム サーバー コントロールの Web パーツ コントロールとして。 Web パーツ ページの作成に最もよく使用される重要なコントロールは、次のセクションで説明します。

## <a name="web-parts-essential-controls"></a>Web パーツの不可欠なコントロール

Web パーツ コントロールのセットが大きいが、するのには、Web パーツに必要なため、または Web パーツ ページに最もよく使用されるコントロールであるために、一部のコントロールは不可欠です。 Web パーツの使用を開始すると、基本的な Web パーツ ページを作成するは、次の表で説明されている重要な Web パーツ コントロールを理解するのに役立ちます。

| **Web パーツ コントロール** | **説明** |
| --- | --- |
| WebPartManager | ページ上のすべての Web パーツ コントロールを管理します。 いずれか (および 1 つだけ) **WebPartManager**コントロールが Web パーツ ページごとに必要です。 |
| CatalogZone | CatalogPart コントロールが含まれています。 このゾーンを使用すると、ユーザーがページに追加するのにコントロールを選択できる Web パーツ コントロールのカタログを作成します。 |
| EditorZone | EditorPart コントロールが含まれています。 ユーザーを編集し、ページ上の Web パーツ コントロールのカスタマイズを有効にするのにには、このゾーンを使用します。 |
| WebPartZone | 含まれ、ページのメイン UI を構成する web パーツ コントロールの全般的なレイアウトを提供します。 Web パーツ コントロールにページを作成するたびに、このゾーンを使用します。 ページは、1 つまたは複数のゾーンを含めることができます。 |
| ConnectionsZone | WebPartConnection コントロールが含まれてし、接続を管理するための UI を提供します。 |
| Web パーツ (GenericWebPart) | 主な UI を表示します。ほとんどの Web パーツ UI コントロールは、このカテゴリに分類されます。 ベースから派生するカスタムの Web パーツ コントロールを作成する、プログラムを最大限に制御を**WebPart**コントロール。 Web パーツ コントロールとして、また既存のサーバー コントロール、ユーザー コントロール、またはカスタム コントロールを使用することができます。 ゾーン内のこれらのコントロールは、ときに、 **WebPartManager**では、コントロールが自動的に折り返さ**GenericWebPart**実行時にコントロールを Web パーツ機能で使用することができるようにします。 |
| CatalogPart | ユーザーがページに追加できる利用可能な Web パーツ コントロールの一覧が含まれています。 |
| WebPartConnection | ページ上の 2 つの Web パーツ コントロール間の接続を作成します。 接続は、(データ) のプロバイダーとコンシューマーとして、その他の Web パーツ コントロールのいずれかを定義します。 |
| EditorPart | 特殊なエディター コントロールの基底クラスとして機能します。 |
| EditorPart コントロール (AppearanceEditorPart、LayoutEditorPart、BehaviorEditorPart、および PropertyGridEditorPart) | ページ上の Web パーツ UI コントロールのさまざまな側面を個人用に設定するユーザーを許可します。 |

## <a name="lab-create-a-web-part-page"></a>Web パーツ ページを作成するラボ。

このラボでは、ASP.NET のプロファイルを使用して情報を保持する Web パーツ ページを作成します。

### <a name="creating-a-simple-page-with-web-parts"></a>Web パーツを含む単純なページを作成します。

このチュートリアルでは、Web パーツ コントロールを使用して静的コンテンツを表示するページを作成します。 Web パーツの操作の最初の手順では、必要な 2 つの構造体要素でページを作成します。 最初に、Web パーツ ページには、WebPartManager コントロールを追跡し、すべての Web パーツ コントロールを調整する必要があります。 第 2 に、Web パーツ ページには、1 つまたは複数のゾーン、web パーツやその他のサーバー コントロールを含めるし、ページの指定した領域を占有した複合コントロールである必要があります。

> [!NOTE]
> Web パーツのパーソナル化を有効にすることが何もする必要はありません。既定では、Web パーツ コントロール セットには有効です。 サイトで Web パーツ ページを初めて実行すると、ASP.NET はユーザーの個人用設定を格納する既定のパーソナル化プロバイダーを設定します。 パーソナル化の詳細については、Web パーツ パーソナル化の概要を参照してください。


### <a name="to-create-a-page-for-containing-web-parts-controls"></a>Web パーツ コントロールを格納するためのページを作成するには

1. 既定のページを閉じて、閉じという名前のサイトに新しいページを追加します。
2. 切り替える**デザイン**ビュー。
3. **ビュー** ] メニューの [ことを確認します、**非ビジュアル コントロール**と**詳細**レイアウト タグと、UI がないコントロールを表示できるようにオプションを選択します。
4. 前にカーソルを置き、`<div>`で新しい行を追加するには ENTER キーを押して、デザイン画面にタグを付けます。 カーソルを改行文字の前に、をクリックして、**ブロック形式**ドロップダウン リストは、メニューで、制御し、選択、**見出し 1**オプション。 見出しのテキストを追加**Web パーツのデモ ページ**します。
5. **WebParts** 、ツールボックスのタブ、 **WebPartManager**とする前に改行文字の直後後に配置する、ページ上にコントロール、`<div>`タグ。   
  
   **WebPartManager**デザイナー画面に灰色のボックスとして表示されるように、コントロールで、任意の出力が表示されません。
6. 内でカーソルを置きます、`<div>`タグ。
7. **レイアウト** メニューのをクリックして**Insert Table**、1 つの行と 3 つの列を持つ新しいテーブルを作成します。 をクリックして、**セル プロパティ**ボタンを選択**上部**から、**垂直方向の配置**ドロップダウン リストでは、をクリックして **[ok]** をクリックします **。OK**テーブルを作成するには、もう一度です。
8. WebPartZone コントロールは、左側のテーブル列にドラッグします。 右クリックし、 **WebPartZone**コントロールを選択**プロパティ**、次のプロパティを設定します。   
  
   ID: SidebarZone   
  
   HeaderText: サイドバー
9. 1 秒あたりのドラッグ**WebPartZone**中間テーブル列に制御し、次のプロパティを設定します。   
  
   ID: MainZone   
  
   HeaderText: メイン
10. ファイルを保存します。

ページでは、個別に制御可能な 2 つのゾーンできるようになりました。 ただし、どちらのゾーンでは、次の手順は、コンテンツを作成するために、任意のコンテンツがあります。 このチュートリアルでは、静的コンテンツのみを表示する Web パーツ コントロールを使用します。

Web パーツ ゾーンのレイアウトがで指定された、&lt;テンプレート&gt;要素。 ゾーンのテンプレート内でカスタム Web パーツ コントロール、ユーザー コントロール、または既存のサーバー コントロールがあるかどうか、任意の ASP.NET コントロールを追加できます。 ここで、ラベル コントロールを使用しているしするには、単に静的テキストを追加することことに注意してください。 通常のサーバー コントロールを配置するとき、 **WebPartZone**ゾーン、ASP.NET コントロールとして扱います Web パーツ コントロールをコントロール上の Web パーツ機能を有効にすると、実行時にします。

**メインのゾーンのコンテンツを作成するには**

1. **デザイン**ビューで、ドラッグ、**ラベル**コントロールから、**標準**、ゾーンの内容領域に、ツールボックスのタブが**ID**プロパティMainZone に設定されます。
2. 切り替える**ソース**ビュー。 注意を&lt;テンプレート&gt;をラップする要素が追加された、**ラベル**MainZone 内のコントロール。
3. という名前の属性を追加**タイトル**を&lt;asp: ラベル&gt;要素、コンテンツにその値を設定します。 テキストを削除する ="Label"属性から、 &lt;asp: ラベル&gt;要素。 開始タグと終了タグの間、 &lt;asp: ラベル&gt;要素などいくつかのテキストの追加**ホーム ページへようこそ**内の&lt;h2&gt;要素タグ。 コードのようになります。 

    [!code-aspx[Main](profiles-themes-and-web-parts/samples/sample21.aspx)]
4. ファイルを保存します。

次に、Web パーツ コントロールとしてページに追加することもユーザー コントロールを作成します。

### <a name="to-create-a-user-control"></a>ユーザー コントロールを作成するには

1. 検索コントロールとして機能するためにサイトを新しい Web ユーザー コントロールを追加します。 オプションの選択を解除**別のファイルにソース コードを配置**します。 閉じ ページと同じディレクトリに追加して、SearchUserControl.ascx という名前を付けます。   
  
    > [!NOTE]
    > このチュートリアルでは、ユーザー コントロールが実際の検索機能を実装していませんWeb パーツの機能を示す場合にのみ使用されます。
2. 切り替える**デザイン**ビュー。 **標準** タブ、ツールボックスの TextBox コントロールをページにドラッグします。
3. テキスト ボックスを追加した後にカーソルを置き、新しい行を追加するには ENTER キーを押します。
4. ボタン コントロールを追加したテキスト ボックスの下の新しい行に、ページにドラッグします。
5. 切り替える**ソース**ビュー。 次の例のようなユーザー コントロールのソース コードは次のことを確認します。 

    [!code-aspx[Main](profiles-themes-and-web-parts/samples/sample22.aspx)]
6. ファイルを保存して閉じます。

これでサイドバーのゾーンに Web パーツ コントロールを追加できます。 サイドバーのゾーンに 2 つのコントロールを追加する、前の手順で作成したユーザー コントロールであるリンクの一覧を含む 1 つ。 リンクは標準として追加**ラベル**サーバー コントロール、静的なテキストをメインのゾーンを作成する方法に似ています。 ただし、個々 のサーバー コントロールに含まれる (ラベル コントロール) のようなゾーンで直接ユーザー コントロールが含まれている可能性がありますが、ここではありません。 代わりに、前の手順で作成したユーザー コントロールの一部であります。 これは、コントロールと、ユーザー コントロールで必要な追加の機能をパッケージ化し、そのコントロールを Web パーツ コントロールとしてのゾーンで参照する一般的な方法を示しています。

実行時に、Web パーツ コントロール セットは両方のコントロールを GenericWebPart コントロールをラップします。 ときに、 **GenericWebPart**コントロール、Web サーバー コントロールをラップする、汎用パーツ コントロールが親コントロール、およびサーバー コントロールを親コントロールの ChildControl プロパティを通じてアクセスできます。 この汎用パーツ コントロールの使用により、標準の Web サーバー コントロールを同じ基本的な動作と属性を持ち、Web パーツ コントロールから派生すると、 **WebPart**クラス。

### <a name="to-add-web-parts-controls-to-the-sidebar-zone"></a>サイドバーのゾーンに Web パーツ コントロールを追加するには

1. 閉じページを開きます。
2. 切り替える**デザイン**ビュー。
3. ドラッグして、ユーザー コントロール ページを作成した SearchUserControl.ascx、**ソリューション エクスプ ローラー**ゾーンにある**ID**プロパティが SidebarZone に設定されているし、ドロップがあります。
4. 閉じページを保存します。
5. 切り替える**ソース**ビュー。
6. 内で、 &lt;asp: webpartzone&gt; 、ユーザー コントロールへの参照のすぐ上、SidebarZone の要素を追加、 &lt;asp: ラベル&gt;を持つ要素に、リンクが含まれている場合、次の例に示すようにします。 また、追加、**タイトル**属性の値を持つ、ユーザー コントロール タグを**検索**に示すように、します。 

    [!code-aspx[Main](profiles-themes-and-web-parts/samples/sample23.aspx)]
7. ファイルを保存して閉じます。

今すぐお使いのブラウザーでを参照して、ページをテストできます。 ページには、2 つのゾーンが表示されます。 次のスクリーン ショットでは、ページを示します。

**2 つのゾーンでの web パーツ デモ ページ**


![Web パーツ VS チュートリアル 1 のスクリーン ショット](profiles-themes-and-web-parts/_static/image3.gif)

**図 3**: Web パーツ VS チュートリアル 1 のスクリーン ショット


タイトルには、各コントロールのバーは、コントロールで実行できる使用可能なアクションの動詞メニューへのアクセスを提供する下向き矢印です。 コントロールのいずれかの動詞メニューをクリックし、クリックして、**最小化**動詞と、コントロールが最小化されたことに注意してください。 動詞メニューからクリックして**復元**、通常のサイズに、制御が返されます。

### <a name="enabling-users-to-edit-pages-and-change-layout"></a>ユーザーによる編集のページとレイアウトの変更を有効にします。

Web パーツは、ユーザー別に 1 つのゾーンからドラッグして、Web パーツ コントロールのレイアウトを変更するための機能を提供します。 ユーザーを移動することだけでなく**WebPart**を別の 1 つのゾーンからコントロールの外観、レイアウト、および動作を含む、コントロールのさまざまな特性を編集するユーザーを許可できます。 基本的な編集機能を提供する、Web パーツ コントロール セット**WebPart**コントロール。 このチュートリアルでこれを行うはの機能の編集を許可するカスタム エディター コントロールを作成することも**WebPart**コントロール。 場所を変更すると同様、 **WebPart**コントロール、コントロールのプロパティを編集するユーザーが加えた変更を保存する ASP.NET のパーソナル化に依存します。

このチュートリアルでは、ユーザーがいずれかの基本的な特性を編集する機能を追加する**WebPart**ページ上のコントロール。 これらの機能を有効にする別のカスタム ユーザー コントロール ページに追加する、と共に、 &lt;asp: editorzone&gt;要素と 2 つの編集コントロール。

### <a name="to-create-a-user-control-that-enables-changing-page-layout"></a>ページ レイアウトの変更をできるようにするユーザー コントロールを作成するには

1. Visual Studio での**ファイル**メニューの 、**新規**サブメニューで開くをクリックして、**ファイル**オプション。
2. **新しい項目の追加**ダイアログ ボックスで、 **Web ユーザー コントロール**します。 新しいファイルの名前を付けます。 オプションの選択を解除**別のファイルにソース コードを配置**します。
3. 新しいコントロールを作成する追加 をクリックします。
4. 切り替える**ソース**ビュー。
5. 新しいファイルですべての既存のコードを削除し、次のコードを貼り付けます。 このユーザー コントロールのコード ページのビューを変更または表示モードを有効にする、Web パーツ コントロール セットの機能を使用して、物理の外観を変更することもできしている間にページのレイアウトは、特定の表示モードでは。 

    [!code-aspx[Main](profiles-themes-and-web-parts/samples/sample24.aspx)]
6. 保存 をクリックしてファイルを保存または選択して、ツールバーのアイコン**保存**上、**ファイル**メニュー。

### <a name="to-enable-users-to-change-the-layout"></a>レイアウトを変更するユーザーを有効にするには

1. 閉じ ページを開き、切り替える**デザイン**ビュー。
2. 内のカーソルの位置、**デザイン**直後に表示、 **WebPartManager**先ほど追加したコントロール。 テキストの後に改行を追加後に空白行があるように、 **WebPartManager**コントロール。 空白行にカーソルを置きます。
3. 作成したユーザー コントロールをドラッグします (ファイルの DisplayModeMenu.ascx 名前は)、閉じにページし、空白行の上にドロップします。
4. EditorZone コントロールからドラッグ、 **WebParts**閉じページの残りのテーブルを開くセルに、ツールボックスのセクション。
5. **WebParts**セクション、ツールボックスのドラッグ、AppearanceEditorPart コントロールとに LayoutEditorPart コントロール、 **EditorZone**コントロール。
6. 切り替える**ソース**ビュー。 テーブルのセルに、結果のコードは、次のコードのようになります。 

    [!code-aspx[Main](profiles-themes-and-web-parts/samples/sample25.aspx)]
7. 閉じファイルを保存します。 使用すると、表示モードを変更して、ページのレイアウトを変更するユーザー コントロールを作成して、プライマリ Web ページへのコントロールを参照している場合。

ページを編集し、レイアウトを変更する機能をテストできます。

### <a name="to-test-layout-changes"></a>レイアウトの変更をテストするには

1. ブラウザーでページを読み込みます。
2. をクリックして、**表示モード**ドロップダウン メニューを選択し、**編集**します。 ゾーンのタイトルが表示されます。
3. ドラッグ、**個人用リンク**Main ゾーンの一番下にサイドバー ゾーンからのタイトル バー コントロール。 ページには、次のスクリーン ショットのようになります。

### <a name="web-parts-demo-page-with-my-links-control-moved"></a>Web パーツ デモ ページ個人用リンク コントロールの移動


![Web パーツ VS チュートリアル 2 のスクリーン ショット](profiles-themes-and-web-parts/_static/image4.gif)

**図 4**: Web パーツ VS チュートリアル 2 のスクリーン ショット


1. をクリックして、**表示モード**ドロップダウン メニューを選択し、**参照**します。 ページが更新される、ゾーン名が消え、および**個人用リンク**まま配置する場所を制御します。
2. にパーソナル化が動作していることを示すために、ブラウザーを閉じて、ページを再度読み込みます。 加えた変更は、今後のブラウザー セッションに保存されます。
3. **表示モード**メニューの **編集**します。   
  
   ページ上の各コントロールは、動詞ドロップダウン メニューが含まれているタイトル バーの下向きの矢印で表示されています。
4. ある動詞メニューを表示する矢印をクリックして、**個人用リンク**コントロール。 をクリックして、**編集**動詞。   
  
   **EditorZone**コントロールが表示される、追加したコントロール、EditorPart を表示します。
5. **外観**エディット コントロール、変更のセクション、**タイトル**、お気に入り を使用して、**枠の種類**を選択するドロップダウン リスト**タイトルのみ**、 をクリックし、**適用**します。 次のスクリーン ショットは、編集モードでページを示します。

### <a name="web-parts-demo-page-in-edit-mode"></a>編集モードでの web パーツ デモ ページ


![Web パーツ VS チュートリアル 3 スクリーンショット](profiles-themes-and-web-parts/_static/image5.gif)

**図 5**: Web パーツ VS チュートリアル 3 のスクリーン ショット


1. をクリックして、**表示モード**メニューを選択し、**参照**ブラウズ モードに戻ります。
2. 次のスクリーン ショットに示すように、タイトルが更新され、境界線コントロールようになりましたが。

### <a name="edited-web-parts-demo-page"></a>編集した Web パーツのデモ ページ


![Web パーツ VS チュートリアル 4 スクリーンショット](profiles-themes-and-web-parts/_static/image6.gif)

**図 4**: Web パーツ VS チュートリアル 4 のスクリーン ショット


### <a name="adding-web-parts-at-run-time"></a>実行時に Web パーツの追加

実行時に、ページへの Web パーツ コントロールを追加するユーザーも許可できます。 これを行うには、ユーザーに使用できるようにする Web パーツ コントロールの一覧を含む、Web パーツのカタログでページを構成します。

**実行時に Web パーツを追加するユーザーを許可するには**

1. 閉じ ページを開き、切り替える**デザイン**ビュー。
2. **WebParts**  タブのテーブルの右側の列にドラッグして CatalogZone コントロールを下に、ツールボックスの**EditorZone**コントロール。   
  
   同時に表示されませんので、同じテーブルのセルに両方のコントロールができます。
3. プロパティ ペインで、文字列を割り当てる**Web パーツの追加**の HeaderText プロパティに、 **CatalogZone**コントロール。
4. **WebParts**セクションのコンテンツ領域にドラッグします DeclarativeCatalogPart コントロールをツールボックスの**CatalogZone**コントロール。
5. 右上隅にある矢印をクリックして、 **DeclarativeCatalogPart** 、タスク メニューの公開を制御し、**テンプレートの編集**します。
6. **標準**、ツールボックスのセクションを**FileUpload**コントロールと**カレンダー**にコントロールを**WebPartsTemplate**セクション、 **DeclarativeCatalogPart**コントロール。
7. 切り替える**ソース**ビュー。 ソース コードを調べ、 &lt;asp: catalogzone&gt;要素。 注意、 **DeclarativeCatalogPart**コントロールが含まれる、 &lt;webpartstemplate&gt;カタログから、ページに追加できる 2 つのサーバーが含まれているコントロールを持つ要素。
8. 追加、**タイトル**に次のコード例では、各タイトルの表示文字列値を使用して、カタログに追加したコントロールの各プロパティ。 タイトルは、プロパティではない場合でも通常設定できますこれらの 2 つのサーバー コントロールにユーザーがこれらのコントロールを追加するとき、デザイン時に、 **WebPartZone**ゾーンから実行時にカタログをそれぞれラップされると、 **GenericWebPart**コントロール。 これにより、タイトルを表示できるように、Web パーツ コントロールとして機能することができます。   
  
   含まれている 2 つのコントロールのコード、 **DeclarativeCatalogPart**コントロールは次のようになります。 

    [!code-aspx[Main](profiles-themes-and-web-parts/samples/sample26.aspx)]
9. ページを保存します。

カタログをテストできます。

### <a name="to-test-the-web-parts-catalog"></a>Web パーツのカタログをテストするには

1. ブラウザーでページを読み込みます。
2. をクリックして、**表示モード**ドロップダウン メニューを選択し、**カタログ**します。   
  
   タイトルのカタログ**Web パーツの追加**が表示されます。
3. ドラッグ、 **[お気に入り]** サイドバーのゾーンのページのトップへ Main ゾーンから制御し、ドロップがあります。
4. **Web パーツの追加**カタログ、両方のチェック ボックスを選択し、 **Main**使用可能なゾーンを含むドロップダウン リストから。
5. クリックして**追加**カタログにします。 コントロールは、メインのゾーンに追加されます。 する場合は、カタログから、ページにコントロールの複数のインスタンスを追加できます。   
  
   次のスクリーン ショットでは、メイン ゾーンのファイル アップロード コントロールとの予定表のページを示します。 

![カタログからメインのゾーンに追加されたコントロール](profiles-themes-and-web-parts/_static/image7.gif)

    **Figure 5**: Controls added to Main zone from the catalog
6. をクリックして、**表示モード**ドロップダウン メニューを選択し、**参照**します。 カタログが表示されなくなり、ページを更新します。
7. ブラウザーを閉じます。 ページを再度読み込みます。 変更の内容を保持します。
